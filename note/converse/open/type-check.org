* 題解
  * 術語表格
    | 動態類型 | 類型編碼於值                     |
    | 靜態類型 | 類型不編碼於值                   |
    | 類型檢查 | 定義函數時 檢查函數              |
    |          | 看 所聲明 與 所算得 類型是否匹配 |
    | 類型推導 | 避免 直接寫 函數類型聲明         |
    |          | 讓機器根據函數所作用於的值來推導 |
  * 決策
    1. 靜態類型
    2. 類型檢查
  * 評論
    在運行時 類型信息不被編碼在值中
    而是被記錄在 函數中
    做爲函數的元數據
* 問題
  * 聲明類型的語法如何
  * 與 代碼生成機制 之綜合
* 討論 <2015-06-17>
  - x ::
       我們發現 類型檢查機制 必須與 代碼生成機制 綜合起來討論
  - k ::
       那麼我們就先考慮二者之間相互影響的部分
  - x ::
       在此之前
       我本想去實現函數來問詢文件大小
       誰知道 它卻引我 實現 代碼生成機制 機制
       進而 來到最刺激的 類型檢查機制
       我以爲 去實現函數來問詢文件大小 只是實現 類型檢查機制 之前的消遣而已
  - k ::
       此謂計劃之必失
  - x ::
       類型檢查機制 是我認爲最有趣的機制之一
       首先說其特點
    1. 可選擇開啓與否
    2. 需要更改很多代碼工作量很大
    3. 關乎代碼優化 即 編譯時期提前作用
       之前看來
       其難度在於類型編碼
       現在有了 name-hash-table
       這已經有望解決了
  - k ::
       我們可以回顧一下之前關於類型的筆記
  - x ::
       但是那有是浪費鋒芒
       不是嘛
  - k ::
       也許吧
  - x ::
       我們嘗試鋒芒畢露一下
       快速羅列一些要點
    1. 可計算性 可計算的不限於傳統的類型 也可以包含副作用
    2. <type> 可以做爲一個 variable-jo 存在
    3. 不必處理局部變元
    4. 全局變元也需要有類型聲明
    5. 孤獨者用 name 編碼
       因複合而嵌套者通過就地嵌套 name 的向量編碼
    6. 所謂 因複合而嵌套者 有一下各種
       1. 同類型的數據所組成的向量
       2. 不同類型的數據所組成的向量 [匿名結構]
       3. 高階函數
  - k ::
  - x ::
