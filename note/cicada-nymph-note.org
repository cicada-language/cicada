#+TITLE:  小蟬記 / cicada-nymph-note
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* 原則
** 認知負擔
   * 人以程序語言與機器對話
     正如人與人對話
     其思想互交流兩相影響
     笨機器 成人的認知負擔
     正如笨人 成我的認知負擔
     而程序語言之設計 只爲減少這種認知負擔
** 莫若以名
   * 少使機器自動處理
     多以人工明顯表達
** 順序
   * 一個文件中代碼 之 處理順序
     一個函數定義 之 處理順序
     定義好的函數 之 作用順序
** 底層
   * 我要能完全控制底層機器資源
     如果把類型信息編碼到值中 [即 所謂的動態語言]
     因爲要對編碼和數值做轉換
     那麼這種對底層的控制就成了一種負擔
     是故 小蟬 不用動態類型編碼
     只爲更好控制底層資源
** 簡單
   * 複雜性狀都在解釋器中實現
     解釋器本身是一個很簡單的匯編程序
   * 我一直維持着上面所聲明的這個特性
     只爲將來能夠快速把解釋器移植到各種機器上
   * 但是我所使用的匯編器能力有限
     這就導致了一下幾點
     1. name-hash-table 在解釋器中實現
        在解釋器中把 link 中的名字加載到 name-hash-table 中
     2. 如果有靜態類型檢查的話
        在匯編代碼中 可能很難做好類型聲明
        也必須在解釋器中 順着 link 來重新把聲明補上
* 語義
** 基本語義
   * 所謂基本語義有兩點
     對每個程序語言來說都一樣
     1. 如何讓函數作用於參數
     2. 如何定義新的函數
** 函數定義
   * 我稱函數爲珠
     我稱函數體爲珠珠
     珠 與 珠珠 形成嵌套
   * 又有名來給珠命名
     函數體中保存的是珠而不是名
     其重要特點是
     名動 而 珠靜
   * 返回棧 即 珠珠之棧
** 函數作用
   * 參數棧 即 函數作用時所取參數之所
     函數所取參數之個數與形態 不受語法控制
   * 有名參數沒有默認值
     實爲函數作用本性所致
* 機制 與 性狀
** 術語
   * 一個機制 實現 一個性狀
     一組機制 可以被成爲 一組性狀的實現
** 參數棧
   * 實現函數的參數傳遞
** 返回棧
   * 實現對函數體中的返回地址的記憶
   * 對返回棧的查找與直接操縱
     實現異常處理
   * 在返回棧中保存兩個局部數據區域的指針
     實現 有名的局部變元 和 局部的內存分配
** 閱讀棧
   * 使得閱讀地點可以被重新定向到字符串
     實現對字符串的解釋
   * 實現 把括號識別爲詞
** 語法棧
   * 實現對語境的靈活轉換
   * 語法棧中保存的規則集
     實現對語法動態添加與刪除
** 鏈
   * 只有唯一一個鏈
     記錄函數被定義的線性線性順序
** 名散表
   * 實現對函數的快速查找
** 期待棧
   * 用以實現非局部退出
** 姓
   * 讓命名更加規則
** 撤銷棧
   * 用以保存某一時刻的全局狀態
     以實現撤銷
** 加載棧
   * 用以保存被加載的代碼的信息
     使得代碼可以被分散到不同的文件
     以形成相對獨立的的模塊
* >< 語法
** 語境
   * reading-stack
   * syntax-stack
   * rule-set
** >< 括號
   * 應該如何使用 保留的括號 ()
     所謂 mixfix notation ?
     所謂 borderfix notation ?
* 類型
** >< 靜態類型檢查
   * 目前是完全無類型的語言
     是否應該引入靜態類型檢查
     應該如何引入
     類型檢查可能是很簡單的
     否則 對參數註釋 做爲信息 就被機器浪費了
   * 對類型的處理
     其實是要植入 函數語義的接口 當中
     即 函數作用 與 函數定義 當中
   * 所謂 靜態
     與動態相對
     其含義爲
     類型信息不以類型標籤的形式編碼在數據中
   * 所謂 類型檢查
     函數有類型聲明
     定義函數時
     可由函數體算出其實際類型是否與聲明類型相符合
     不符則拒絕定義
   * 類型有編碼
     只是編碼不保存在這個類型的數據當中
     而保存函數當中
     類型編碼只能用 name 和 數組 進行
     而不應該用字符串
   * 副作用應該如何處理
     也應該有編碼 ?
   * 保存在函數中的元數據可以用於計算
     當做出上面這種論斷的時候
     需要明確的是計算所使用的代數結構是什麼
   * 我可不可以把這個代數結構變得特別靈活 ?
     不光對棧的副作用可以用於計算
     對別的數據結構的副作用也可以被用於計算
     如果我能提供機制來定製各種各樣的計算規則
     那麼我就達到了我所說的靈活性
   * 棧所形成的 所謂 最一般的結合代數 也是一個代數結構
     重範疇論的角度觀察
     兩個代數結構之間相差一個遺忘函子
     忘了數據本身的值 只記住其類型
** >< 類型與姓的關係
   * 當說 類型應該用 name 來編碼的時候
     其實就是說類型應該用 姓 來編碼
   * 但是 <title> name 完全是一種命名機制
     函數本身的類型可以是完全與 <title> 無關的
     也就說 在名字中的 <title> 是對 在提醒函數類型可能與 <title> 有關
** >< 不加檢查之時
   * 在形成類型檢查機制之前 有不加檢查之時
     必須保證兩種狀態的順利銜接
   * 這也就是說
     在形成類型檢查機制之前
     我還是能去設計和增加別的機制
     很多機制的設計不必等待類型檢查
     [比如 加載機制]
** 優化
   * 有了類型信息
     就有可能在定義函數的時候把某些可以執行的計算進行掉
     如果引入這種優化
     那麼 就有必要 區分變元與常元了
* 評論
** 命名 與 分解 與 匿名
   * 命名
     命名有兩種
     1. 局部的
     2. 全局的
   * 分解
     分解有兩種
     1. 利用函數作用的
        這種分解利用了局部的名
     2. 利用函數複合的
        這種分解利用了全局的名
   * 許多 forth 所崇尚的分解
     其實是單純爲了緩解 置換棧 的壓力的
   * 匿名
     緩解命名壓力的方式是匿名
     實現匿名的方式有兩種
     1. lambda
        其實是一種標記語言
        lambda 的參數名字 是用來標記代入點用的
        這裏
        理解上的壓力來源於
        對標記的分析
     2. 組合子
        每個組合子都是一個全局的名字
        從 lambda 的角度看
        每個組合子捕捉某種代入模式
        然後給這種代入模式一個名字
        這裏
        理解上的壓力來源於
        對名字所捕捉的模式的熟悉
** 圓上的點
   * 一個點在圓上移動
     它的位置在變 但是它到圓心的距離始終相等
* 命名
** 鍊
   * 之所以需要 鍊
     是因爲匯編語言的能力太弱
     直接在其中實現 名散表 太費心力
   * 一旦解釋器被執行起來之後
     連就會被拋棄
** 名散表
   * 名散表 是處理命名的唯一數據結構
     其中每個 名欄 之 珠域 對珠的保存
     就是命名過程
   * 珠子本身還是有名字的
     但是這些名字只用來打印函數體
     而別無他用
     來自模塊的珠子
     其名字中的前綴指示其模塊
     這樣我就能在出錯時從文件中找到這個珠子的位置
     也許有多個位置 因爲可能有重複命名
** 名備份區
   * 需要備份的原因是
     1. 我需要記錄珠被命名的順序
     2. 我需要能夠把 名散表 恢復到之前的狀態
** 珠 到 名
   * 很難從 珠 找到它當時的命名
     正確的做法是
     在函數提中的每個位置增加一個名
   * 假設這種 珠 到 名 的函數
     只爲除錯所用
     那麼在 *global-naming-stack* 中搜索 珠 的名字
     也是可以接受的
     我選擇這種方式
     並且把 名域 從 珠中剔除
* 姓
** 目的
   * 在 小蟬 中
     姓 可以被理解爲 接口管理器
     或者 名字管理器
     其目的是
     在需要的時候
     將命名過程變得更加正規
   * 姓 的
     1. 編碼數據類型的功能
     2. 簡化函數調用語法的功能
     只有在 有類型的 蟬語 中
     才能實現
   * 接口管理器 可以用來建立 數據結構的概念
     但是 接口管理器 本身的機制是與 數據結構的機制相互分離的
** 實現
   * 每個 <title> 在全局的 link 中
     做爲一個 variable-jo 而存在
     其中保存一個 link
   * 這個 link 中的 jo 就是登記在 這個 <title> 下的 jo
     同時也會在 name-hash-table 中登記
     此時
     比如 function 會被登記到 "<title> function" 這個 name 下
** 接口
   * (define-function,with-title)
     直接製作新的東西
     並註冊新的 function 到 <title> 下
     與 (define-function) 完全類似
     當第一次遇到某個 <title> 時
     初始化這個 <title> 做爲 variable-jo 的存在
   * (alias)
     把已有舊的東西
     給一個 name 以註冊到 <title> 下
     可以讓它處理一個列表的東西
     同樣初的版本可以是最簡單的
   * 在着兩個底層函數之後
     應該重新定義 (define-function)
     使得他們能夠處理 帶有 <title> 的情形
** implementation
   * a title is a link
     a name under title can be found
     by normal link interface
   * a title also has some special meaning to the name-hash-table
     a name under title can NOT be found
     by normal name-hash-table interface
     to be found
     the name must be prefix by the string "<title> "
* 命名
  * 命名行爲有很多類型
    令人困惑 列舉如下
    1. 首先是全局變量
       一個全局變量 是一個有名字的盒子
       裏面可以保存值
    2. 其次是有 名域 的數據結構
       比如 珠 和 鍊
    3. 再次是 名散表 中
       一個 名 下所保存的值
  * 特點是
    1. 由值不能找回名字
    2. 值本身是一個數據結構的地址
       可以用以找回名字
       因爲名字只是這個數據結構的一個域
    3. 目前 名散表 中所保存的值
       只限於 珠
       一個 珠 可以存在於很多 名散表 中的 名欄 中
       每個 名欄 之名 都是這個珠的別名
       珠 做爲數據結構其內所保存的名字
       纔是這個珠的真名
  * 問題
    1. 珠 內的真名 是有必要的還是沒必要的
       這個名字的唯一目的就是 用以打印於顯示
       完全沒有查找的功能
  * 這種混亂的原因在於
    1. 函數體中所保存的
       不是 名散表 中的 名欄
       而是 函數的真正地址
  * 這導致動態性的喪失
    即 重新定義一個函數的時候
    有時必須重新定義所有依賴於它的函數
    才能達到所期望的效果
    同時獲得靜態性
    即 重新定義一個函數時
    不會破壞以前的定義
* 局部變元的語法
  * joy 中的匿名謂詞
    在作用於棧中的值的時候
    不必複製它所作用的值
  * 而 cicada-nymph 必須以明顯的方式複製棧中的值
    如果每一組函數對棧中的值的消耗都能夠被編譯器計算出來
    那麼就可以省略這些明顯的複製了
    這些是可能實現的
    只要把註釋信息設計成 良好的 可以被自動處理的 格式 就可以了
  * 然而
    在沒有對棧的註釋的自動推演的情況下
    我也可以通過設計特殊的語法來實現比較好的效果
  * a macro to pickup values from stack by index
    index starts from 0
    #+begin_src cicada-nymph
    :0 :1 :2 :3
    ::0 ::1

    :0 as dup
    ::0 as dup2
    #+end_src
  * a macro to pickup values from stack by name
    #+begin_src cicada-nymph
    << string[address, length], counter -- >>

    << do not eat >>
    :2 :1 >::string :0 >:counter
    ::2 >::string :0 >:counter
    =>[::string :counter]

    << eat >>
    >:counter >::string
    >[::string :counter]
    #+end_src
  * by the above example
    we know that
    we also need
    #+begin_src cicada-nymph
    =>::name
    #+end_src
    to replace
    #+begin_src cicada-nymph
    dup2 >::name
    #+end_src
* 結構化數據的初始化語法
  * [ ] 是 匿名的 jo 這種結構化數據的初始化語法
    然而
    別的結構化的數據應該如何呢 ?
  * 比如 path: directory-name file-name ;
    是一種用來初始化 特殊的[代表 path 的]字符串的語法
  * 需要類似的語法的地方還有
    1. vector of name
    2. vector of string
    注意這裏的 vector 都是類型良好的
    必須是這樣
    因爲我根本沒有對類型編碼
  * 對於上面所欠缺的兩種語法
    我可以很容易想出很多設計方式
    但是要知道
    語法是可以靈活轉換的
    所以可以先實現幾個語法試試效果
* 局部變元代入嵌套的無名函數
  * 局部變元代入嵌套的無名函數 是可以實現的
    可以實現特殊的標記語法來支持這個特性
    並且
    當些無名函數需要被做爲返回值返回時
    去返回無名函數的複製
    而不返回在大函數體內的無名函數本身 就行了
    此時的複製有兩種
    1. 複製到圈狀內存中
       此時所返回的值必須在短時間內被用掉
    2. 複製到靜態內存中
       這樣就提供了一種生成函數的方式了
* data-structure
  * a data-structure is a pattern of bit [thus byte [thus jo]] in memory
  * a data-structure is referenced by is address in memory
  * what a low level programming language should provide
    is a flexible way [a mechanism]
    to manage the interfaces of all kinds of data-structures
    including
    1. define
    2. allocate & init
    3. get & set
    4. equal & copy
    and other operating functions
  * that is to say
    the interface of a data-structure is a set of functions
    what should be managed are
    1. how to define these functions
       maybe to generate these functions group by group
    2. how to apply these functions on their arguments
       i.e. to call these functions
  * the mechanism implemented here is very flexible
    thus
    it usage is not limited to help to form the concept about data-structure
* 匯編器
** 能夠編譯自己之後之後才能實現的性狀
   * jotionary 中 jojo 的長度
   * 把對 棧註釋 處理成 元數據
     利用這些元數據 就能夠實現簡單的類型推導
   * 一個 debug 模式
     在其中 對所有的基本的 棧的接口加上保護
   * jojo 的頭部 和 jojo 本身的分離
     這樣就能在 link 方面增加一層間接
     而實現別名機制
** 對匯編器的需要
   * 爲了實現上面的性狀
     把 cicada-nymph 編譯到任何一個語言都是可以的
     [比如 Fasm]
   * 但是我還是需要自己實現匯編器
     因爲就工作量而言 二者相當
     就所形成的實現策略的靈活性而言
     根據 自己的匯編器 所制定的實現策略 要靈活很多
** 小蟬 與 蟬語
   * 關係如下
     #+begin_src return-stack
     (machine) -> (cicada-nymph)
     (assembler) & (vm) -> (cicada-language)
     #+end_src
   * 可移植性由小蟬的易實現性來維護
   * (vm) 是
     實現與 cicada-nymph 中的
     對底層機器的特殊屬性依賴很弱的
     線串碼解釋器
   * (assembler) 是
     以 cicada-nymph 所提供的交叉匯編器框架爲基礎的
* 交叉匯編器構架
  * cross assembler framework
  * 目的 爲了寫 cicada-language 的 VM 的 匯編器
  * 在 name-hash-table 中貢獻出一個域
    來分離 匯編器 的命名空間
  * memory buffer editor
    1. bit buffer editor
    2. byte buffer editor
  * 多光標編輯
    * cursor = 1 cursor
    * buffer = 2 cursor
    * xxxxxx = 3 cursor
  * line editor 外加各種 mode
