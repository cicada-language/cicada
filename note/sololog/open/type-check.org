* 題解
  * 術語表格
    | 動態類型 | 類型編碼於值                     |
    | 靜態類型 | 類型不編碼於值                   |
    | 類型檢查 | 定義函數時 檢查函數              |
    |          | 看 所聲明 與 所算得 類型是否匹配 |
    | 類型推導 | 避免 直接寫 函數類型聲明         |
    |          | 讓機器根據函數所作用於的值來推導 |
  * 決策
    1. 靜態類型
    2. 類型檢查
  * 評論
    在運行時 類型信息不被編碼在值中
    而是被記錄在 函數中
    做爲函數的元數據
* 問題
  * 聲明類型的語法如何
  * 與 代碼生成機制 之綜合
* 討論 <2015-06-17>
  - x ::
       我們發現 類型檢查機制 必須與 代碼生成機制 綜合起來討論
  - k ::
       那麼我們就先考慮二者之間相互影響的部分
  - x ::
       在此之前
       我本想去實現函數來問詢文件大小
       誰知道 它卻引我 實現 代碼生成機制 機制
       進而 來到最刺激的 類型檢查機制
       我以爲 去實現函數來問詢文件大小 只是實現 類型檢查機制 之前的消遣而已
  - k ::
       此謂計劃之必失
  - x ::
       類型檢查機制 是我認爲最有趣的機制之一
       首先說其特點
    1. 可選擇開啓與否
    2. 需要更改很多代碼工作量很大
    3. 關乎代碼優化 即 編譯時期提前作用
       之前看來
       其難度在於類型編碼
       現在有了 name-hash-table
       這已經有望解決了
  - k ::
       我們可以回顧一下之前關於類型的筆記
  - x ::
       但是那有是浪費鋒芒
       不是嘛
  - k ::
       也許吧
  - x ::
       我們嘗試鋒芒畢露一下
       快速羅列一些要點
    1. 可計算性 可計算的不限於傳統的類型 也可以包含副作用
    2. <type> 可以做爲一個 variable-jo 存在
    3. 不必處理局部變元
    4. 全局變元也需要有類型聲明
    5. 孤獨者用 name 編碼
       因複合而嵌套者通過就地嵌套 name 的向量編碼
    6. 所謂 因複合而嵌套者 有一下各種
       1. 同類型的數據所組成的向量
       2. 不同類型的數據所組成的向量 [匿名結構]
       3. 高階函數
       對於嵌套的類型編碼 高階函數語法上用掉 {}
       向量重載 []
    7. 需要處理 scope 就像局部變元的 scope-stack 一樣
       也許應該共用一個 scope-stack
    8. 多類型函數返回值的函數也被處理
       比如以 find 爲後綴的函數
       只要一種類型能行即可
       但是這可能嘛
       對於 find 而言是可能的
       因爲多出來的 類型可以被 if 消去
    9. 類型變元
  - k ::
       我想我們可以嘗試把想像具體化了
       並且舉幾個具體的例子
  - x ::
       首先是類型編碼
       根據複合與否有兩類
    1. 素類型
       其編碼用 形如 <type> 的 name
       {<number> -- <number>}
    2. 複合類型
       其編碼用 用 素類型 的數組
       目前我能想到三種類型
       1. 同類數組
          {[<number>*] -- }
       2. 異類數組
          { -- [<number> <gamber> <string>]}
       3. 函數
          {{<number> -- <number>} -- {<number> -- <number>}}
       比如
       {<number> -- <number>}
       做爲數組是
       | {        |
       | length   |
       | <number> |
       | --       |
       | <number> |
       | length   |
       | }        |
       這樣就能夠前後遍歷了
       類型變元就是 不帶 <> 的 name
       比如 {a a -- a}
       這樣 類型就是 一等公民了
       並且使用新的類型的時候也不需要定義
  - k ::
       其次是對類型的計算
  - x ::
       沒錯
       我可以嘗試窮舉所需要處理的情況
    1. 函數複合
       [平凡的]
    2. 全局變元
       [平凡的]
    3. 函數作用
       [古典的]
    4. 類型變元
    5. 分支
  - k ::
       (4) (5) 比較困難
  - x ::
       的確
       我們來讓問題變得更具體
       所謂計算有輸入值和輸出值
       用於計算類型函數本身也可以被加上類型標籤
       {<string> <type> -- <bool>}
       也許返回值不應該如此單薄
       畢竟我們要做詳細的報錯
  - k ::
       先看難點 (4)
  - x ::
       這並不難處理
       假設我給 類型變元 以額外的語法
       比如 +type-variable+
       那麼這種東西就可以出現在類型中的任何地方
    1. 同類數組
       {[+aaa+*] -- }
    2. 異類數組
       { -- [<number> <gamber> <string> +aaa+]}
    3. 函數
       {{<number> -- +aaa+} -- {<number> -- <number>}}
       變元在於賦值
       只要知道賦值如何發生即可
       比如棧中有
       {<number>}
       有類型爲 {+aaa+ -- <string>} 的函數作用於棧
       那麼 +aaa+ 就會被賦值爲 <number>
       又比如
       棧中有 {+aaa+}
       有類型爲 {<number> -- <string>} 的函數作用於棧
       就會失敗
       因爲 +aaa+ 不一定爲 <number>
       不過看來我需要形成更好的數學模型
       來討論類型系統的一般性質
       上面這些舉例並不能保證其設計良好
  - k ::
       還有 (5) 呢
  - x ::
       這又引發了額外的問題
       比如
       {<string>
        -- <string> true
        -- false}
       有 <bool> literal 在棧中
       這就要求類型中能夠出現 literal
       此時
       產生分歧 後面一定要有 if
       if 會處理分歧
       如果假設 if 是唯一的產生分支的語法
       那麼處理完這種情況之後
       就完備了
       但是
       如果今後增添處理 if 的關鍵詞
       那麼就必須擴展類型計算以處理新的語法關鍵詞
       也就是說
       沒增添一個語法關鍵詞
       如果想要它在 REPL 中能用就要爲解釋器重新實現一遍
       如果想要它在 類型檢查 中能用就要在類型檢查器中重新實現一遍
       沒有別的辦法了
  - k ::
       這裏 literal 應該如何處理
       語法如何設計
       編碼如何
  - x ::
       比如 我將一般的 沒有 <title> 前綴的 詞做爲 literal
       這樣就能處理 數字 還有 bool
       這種素 literal
       複合數據的 literal 還不行
       尤其是考錄到 內存就地分配的問題
       我明白了
       我們必須先設計完備的 向量處理機制
       然後把 type 用向量來實現
       這裏要求的性狀是
       每個向量中都能夠就地保存各種類型的 素數據 或 複合數據
  - k ::
       如果這樣 處動態類型標籤一定要被保存在 向量中了
       這樣不就成了動態類型語言
  - x ::
       我們來仔細考察一下向量這個東西
       首先
       我假設
       所有向量處理函數 如果改變了向量的長度
       那麼就一定要 生成新的向量 而不是在原有的向量上做副作用
       其次
       向量之在 棧中的存在如同 <string>
       而向量在內存中的存在必須包含其長度
       也就是說
       向量這個數據結構必須要有豐富的元數據
       因爲它將是 cicada-nymph 的主要數據結構
       所有的東西都依賴與它
       最主要的元數據是向量的長度
       這個長度需要被包含到向量的開頭和結尾
       以實現兩個方向的遍歷
       用來遍歷向量的函數 就如目前用來處理 <string> 的類似
       通過不同的接口函數可以以不同的語義來理解向量
    1. 最簡單的語義是 cell
    2. 類型系統所需要的語義是 element [暫且命名如此]
  - k ::
       然而
       如果可以嵌套
       那麼獲取 element 的函數所能取得的值就可以能是 <name> 和 <vector>
       也就是說 <vector> 這個數據類型 不是同質的
       不光能夠有 vector of <number>
       即 [<number> *]
       還能有 vector of <number> or <vector>
       即 [<number>|<vector>]
       這樣
       之前所說的 異質向量類型
       [<number> <gamber> <string>]
       其實是不存在的
  - x ::
       首先在設計決策上
       我放棄所謂類型的絕對安全
       這樣上面的異質向量就是可以容忍的
       但是
       是否可能
       因爲這算是又出現了一種類型分歧
       我可以通過定義新的類型來包含 <number> 和 <vector>
       以使得 上面的向量 變爲同質的
       而直接的 [<number>|<vector>] 相當於是匿名的類型
       其實
       所有複合類型的出現都可以看成是匿名類型
       但是
       如果說上面的 <number> 和 <vector> 可以被定義爲一個新的類型的話
       這無疑是說 類型不是簡單的 name 了
       類型之間是有關係的
  - k ::
       沒錯
       其他語言的類型系統也是如此
       這樣使用類型之前就必須要明顯定義了
  - x ::
       如果大量使用匿名類型的話
       可否避免這種情況
  - k ::
       不可以
       這又回到了
       名與匿名之間的平衡
       命名是一種抽象方法
       複雜的匿名類型不能總以全稱出現
       必須有方法以命名它
  - x ::
       不過
       上面的把異質的向量變成同質
       看似是絕對需要定義新複合類型的地方
       比如 定義 <vexp> 爲 <name> | <vector>
       那麼處理 <vexp> 的函數又該如何
       是使用 <vector> 爲前綴者
       還是使用 新的 <vexp> 爲前綴者
       還有
       [<number>]
       其實是 vector of <number>
       也就說是一種類型構造子
       這種類型構造子的使用能否一般化
       比如 {<number> -- <gamber>}
       其實是 function of <number> -- <gamber>
       也是一種類型構造子
  - k ::
       這樣就有兩個層次的可以自由定義的東西了
       一個是 類型構造子
       一個是 類型本身
  - x ::
       我現在想類型系統對與 cicada-nymph 來說
       是否可能
  - k ::
       注意
       我們不需要完全的類型安全
  - x ::
       但是這是什麼意思
       那些地方是可以不安全的
  ----------------------------------
  - x ::
       我回顧了一下之前的筆記
    1. 類型構造子這個概念必須被引入
       每個類型構造子對應於
       一組類型解構子
    2. 類型推導
       所有函數必須都有類型前綴
       這些類型前綴在推導器的幫助下
       可以被完全省略
       類型信息之使用
       是爲了進行推導
       以回覆類型前綴
       從而找到需要被編譯到函數體中的函數
    3. 類型檢查
       不要求名每個函數都有類型前綴
       類型信息之使用
       函數體中必須使用函數的全名
       在於檢查所聲明者
       是否與所計算者相互匹配
  - k ::
       如上二者對類型信息的使用方式不同
       但是對類型的計算方式可能完全相同
  - x ::
       沒錯
       現在需要知道的問題是
    1. 類型構造子 如何用向量實現
       類型結解構子是什麼
    2. 定義新的類型意謂着什麼
    3. 如何處理 異質 向量
       必須要命名碼
       是否能用類型構造子匿名
       既然 [<number>] 代表匿名的類型
       那麼
       類型構造子其實就是一種匿名機制
       既然匿名 其內信息就必須完整出現
  - k ::
       需要兩個機制
       一個是匿名
       一個是命名
       匿名需要用到類型造子
       命名需要用到代入語義 即 區分 素與複合
       一個類型名字 <type> 可能是一個素類型
       也可能是一個複合類型的名字
       每個複合類型都是用各種類型構造子來構造的
       類型構造子可以用戶定義
       每個類型構造子都對已一些類型解構子
       我來簡化下問題
       這在於去除語法糖
       要知道 如果考慮類型構造子的話
       那麼 {} 和 [] 其實都是特殊的語法糖
       所以爲了簡化問題
       必須設計 不帶語法糖的一般語法
  - x ::
       以 {} 類型構造子之邊綴
       之前的
       [<number>]
       對應於
       {vector: <number>}
       之前的
       {{<number> -- <number>} -- {<number> -- <number>}}
       對應於
       {function: {function: <number> -- <number>} -- {function: <number> -- <number>}}
       或者
       {function:
        {{function: {<number>} {<number>}}}
        {{function: {<number>} {<number>}}}}
       它們都是特殊的嵌套的向量
       其實所謂嵌套
       就是把向量的長度包含進去 然後將向量的接口做特殊處理 以利用這些長度信息
  - k ::
       這種語法看來並不令人滿意
  - x ::
       我明白了
       所謂構造子與解構子
       其構造子可以直接被實現爲嵌套的 name 的 vector
       而解構子是對這種類型的數據的模式匹配
       上面的語法並不令人滿意
       其實
       {{<number> -- <number>} -- {<number> -- <number>}}
       應該保持其簡潔
       這種模式的 name vector 所代表的是棧中元素類型的變化
       這是最主要的模式
       其他的模式以 [] 爲邊 比如 [aaa:]
       默認者 [] 可以做爲一種省略情形
       (apply) 的類型是
       {+a1+ ... +an+ {+a1+ ... +an+ -- +b1+ ... +bn+} -- +b1+ ... +bn+}
       我明白了
       每個函數的類型聲明其實也是一個函數
       只不過是在編譯時期作用
       因 這類函數很特殊
       而 用特殊的語法寫成
  - k ::
       可以將這個概念一般化嘛
  - x ::
       還有對其他副作用的計算等等
       都可以用這種編譯時期的作用來理解
       還有優化也是
       還有代碼生成也是
  - k ::
       我認爲這是非常有趣的理解方式
       認識方式比處理手段更重要
       可以說現在我們已經獲得最重要的東西了
  - x ::
       沒錯
       我對整個系統的理解方式都改變了
       需要好好反思以調和新認識方式所帶來的衝突
* 討論 <2015-06-18>
  - x ::
       我的意思是
       函數中保存類型信息的方式
       可以不是一個有待一般解釋器解釋的語法
       而是一個被編譯好的代碼
       比如 {<number> -- <number>} 可以被編譯成
       [ << '<number> -- '<number> >>
         '<number> equal? if
           '<number>
           end
         then
         'error awake ]
       而不被處理爲一個有待解釋器解釋的 name 的 vector
       但是其實不應該這樣
       因爲被編譯好的代碼 易於執行 但是不易於閱讀
       也就是不適合做爲函數的類型元數據
       正確的做法是使用 name 的數組
       用專門的解釋器來解釋這個數組
       爲了更豐富的處理
       可以在計算時不使用 參數棧
       而另行開闢類型棧
       有待解釋的是 type-vector
       解釋的過程中
       會處理 type-stack 中的 type-record
       type-record 做爲數據結構 其域可以不只包含 name
       還可以有各種擴展
  - k ::
       如此已經確定
       下面就看對 type-vector 的解釋應該如何進行
  - x ::
       有兩個類似解釋器的東西
       注意
       每個 <type-vector> 代表在 type-stack 中
       以 <type-record> 爲單位的計算
       或者說 rewrite
       注意 rewrite 和 計算 是 同義詞
       比如 用 argument-stack 做計算
       即使就是對 argument-stack 的 rewrite
    1. (<type-vector> interpreter)
       * 用途
         匹配 type-stack 失敗時通過 awake 報錯
         成功時形成對 type-stack 的 rewrite
       * 參數
         <type-vector>
       * 副作用
         type-stack
    2. (type-checker)
       * 用途
         檢查所聲明的 <type-vector>
         是否與 用函數體所算得的 <type-vector> 相互匹配
       * 參數
         <type-vector>
         <string> 函數體
       * 注意
         檢查不匹配時 需要報錯
         報錯時要非常詳細並說明出錯位置
       * 實現方式
         就像 (basci-REPL) 在一個循環中調用 (word-interpreter)
         (type-checker) 在一個循環中調用 (<type-vector> interpreter)
  - k ::
       語法關鍵詞所導致的特殊情形 如何處理
       構造子 和 模式匹配 如何處理
       用已有的類型定義新的類型 即 類型之間的關係如何處理
  - x ::
       首先看最後一個問題
       類型之間的關係
       素函數複合而形成複合函數
       素類型形成更複雜的類型的方式就是構造子
       按照之前所言
       類型構造子之定義是相當任意的
       就像語法擴展一樣可以隨時添加隨時減少
       所有的複合類型都應該能夠被類型構造子來實現
  - k ::
       包含 literal 的類型 也應該被類型構造子實現
  - x ::
       假設其行
       構造子 和 模式匹配 用類似語法擴展的機制來實現
       而 特殊的語法關鍵詞就是語法擴展
       那麼就剩下類型之間的關係了
       這在於給用類型構造子所構造的類型命名
       命名素類型不必分說
       但是
       命名複合類型之後
       解釋器應該如何處理他們呢
       簡單的代入語義麼
  ----------------------------------
  - x ::
       我發現抽象模型還很薄弱
       必須充分考慮從抽象理論
       然後才能計劃實現
       之前我想
       類型限制函數的複合方式
       但是
       在實際的計算中
       對複合的限制其實是通過對函數作用的檢查而來的
  - k ::
       也許正如之前所說
       只有重新發明一個理論
       人才能夠良好理解一個理論
       如果不考慮所有複雜情形的話
       其實我們已經在重新發明簡單的類型論了
       之後就看如何發展這個簡單的理論
  - x ::
       所謂的簡單理論
       我可以總結如下
       [可以先不考慮 (type-checker)]
       利用 *type-stack* 中的 <type-record> 來做計算
       編碼計算的是 <type-vector>
       求職 <type-vector> 的是 (<type-vector> interpreter)
  - k ::
       也許類型之間沒有關係
  - x ::
       有兩種認識
    1. 類型之間的關係是
       去命名用類型構造子所構造的複合類型
    2. 類型之間的關係是爲了不重新 alias 接口函數
       使得同樣的接口函數可以作用於不同類型的數據
       也許我想要做 alias 以集成一些接口
       而不是使用原來的接口的名字
       並經類型前綴改變了
       我還發現
       所謂的 dependent type
       所說的是
       <type-vector> 中所能包含的不只是 形如 <type> 的 name
       還能包含類型變量 +aaa+
       還能包含值的變量
       還要能夠包含 literal
       同樣的函數接受的參數不同 返回的值的類型也不同
       就像
       {<string>
        -- <string> true
        -- false}
       中的 true 和 false 一樣
       這些 literal 是最複雜的情形
       依法上不容易設計
       語義上
       有兩方面
       首先 要豐富 <type-record> 的域
       其次 要使得數據結構能夠直接分配到向量中
       後者是在要求動態類型
       這可能是沒法接受的
  - k ::
       也許限制這種類型標籤只能出現在 <type-vector> 中就行
  - x ::
       是否要求 <type-vector> 中所保存的也不單單是單薄的 name
       而是 <type-record> 呢
       這樣 上面的兩種情形就劃歸爲一種了
       並且因爲數據結構變豐富
       更多的性狀也易行了
       我想正應該如此
       畢竟 <name> 要和 <type> 有區分
       <type-record> 可以直接被更名爲 <type>
       <type-vector> 其實也是 <type> 只不過是帶有構造子的
       如果使用遞歸定義記號的話
       <type> := <type-atom> | <type-vector>
       <type-atom>
       | name |
       | ...  |
       <type-vector>
       | length |
       | vector |
       | ...    |
  - k ::
       之前提到新的認識方式
       這裏我們可以回到 joy 的純粹函數語義中試試
  - x ::
       這樣 現有的系統本身 還是類型系統可以被理解爲 兩次計算
    1. 用 argument-stack 計算
       以 value 爲單位
    2. 用 type-stack 計算
       以 type 爲單位
       後者 遇到分支語句時 會遍歷每個分支
       前者 遇到分支語句時 只會進入一個分支
       兩種計算都是對 stack 的轉寫
  - k ::
       繼續回顧古典的知識
       我發現類型系統是個非常豐富的領域
       就像橋樑一樣它把各種其他理論鏈接起來
       古典的解釋是值屬於類型
       然而你這裏的類型似乎沒有值與類型之間的關係
  - x ::
       其實聲明一個函數的類型
       就是值與類型之間的關係
  - k ::
       是這樣
  - x ::
       這裏的特點是每個值屬於類型之聲明都形如 {<number> -- <gamber>}
       沒有 1 : <number> 這類聲明
  - k ::
       其實應該有
       不是嘛
       要知道 { -- } 只不過是特殊的類型構造子而已
  - x ::
       <type-vector> 和 <type-atom> 同時保存在 *type-stack* 中會有衝突
       正確的方式是把 *type-stack* 本身理解爲一個 <type-vector>
       只不過只有 -- 之前的部分
       其實
       沒有 1 : <number>
       但有 1 : { -- <number>}
       或者 既然 值本身能夠存在與 類型向量中的話
       那麼 1 : { -- 1}
       在語義上保存在 <type> 這個數據結構必須要足夠豐富
       以至於橫鉤保存 類似 1 這類的 佔用一個 cell 的原子數據
       還要能夠保存 佔用一片內存的複合數據
       並且在語法上 上面的 1 : { -- 1} 是不充分的
       即 語法所表達的信息是不充分的 不足以初始化 <type> 這個數據結構
  - k ::
       想好語法之後我們就能用我們的語法來表達古典的知識了
  - x ::
       沒錯
       那麼將是很好的學習機會
       一個 <type> 可以是四種東西
    1. 類型 <number>
    2. 類型變元 .type-variable
    3. 某個類型的值 (<number> 1) (<bool> true)
    4. 一般變元 (<bool> .b)
       這樣就有
       {<string>
        -- <string> (<bool> true)
        -- (<bool> false)}
       這樣
       dependent type 就是
       {(<number> .type-variable) -- (<number> .type-variable)}
       所謂依賴
       一定是 -- 前面的變元在後面重複出現
       重複出現方式中 最簡單的情形就是在 棧中重複
       而複雜的情形是被代入類型構造子中
  - k ::
       我想我們應該讀更多的古典東西
       在這個過程中檢驗並修正我們的語法和語義
  - x ::
       關於具體實現
       當計算類型時遇到了函數體中的一個常量 1
       我們應該得到類型 (<number> 1)
       而不是 <number>
       否則就浪費了信息
       有就是說
       信息的具體化程度是有層次的
  - k ::
       我發現
       之前的 <title>
       現在和類型名稱的語法重載在一起
       也許不是到的性狀
  - x ::
       只有發現這種性質極端不好時我才會分裂語法
* 討論 <2015-06-19>
  - x ::
       我發現理論方面
       做爲不同認識方式
       重不在聲明差異和強調優越
       而在於建立關係
       以揭示理解方式之間如何相互轉換
  - k ::
       其實在模仿嘲鳥的筆記裏
       你已經在構建相關的聯繫了
       不是嘛
  - x ::
       沒錯
       即 語法爲函數複合優化的組合子邏輯
       外加棧語義
       而之後
       我又有了局部變元語義
       現在我需要構建爲函數複合而優化的類型聲明語法
       之後理論之間的對飲關係就完備了
  - k ::
       所以古典的知識是相當必要的
  - x ::
       所以我們來回顧它們
       筆記要做圖所以我在紙質筆記本上記了
* 討論 <2015-06-21>
  - x ::
       我嘗試了理論基礎方面的探索
       但是完備而簡潔的理論遠非朝夕之功
       不妨先信其行
  - k ::
       在這個過程中你設計了新的語法不是嘛
  - x ::
       沒錯
       #+begin_src cicada-nymph
       {
       <類>
       +類+
       (<類> 值)
       (<類> :變)
       [構 (<類> 值)]
       {<類> -- <類>}
       --
       +類+
       [構 (<類> :變)]
       [構 +類+]
       }
       #+end_src
  - k ::
       新的語法並不足以讓你來觀察古典的結構嘛
  - x ::
       不足
       考慮範疇論 就知道新語法所代表的結構與古典差異很大
  - k ::
       那麼我們在回來考慮實現問題
       所謂 先信其行
       有兩個難點
       一是
       <address> <length> as <string>
       一是
       任意 <address>
  - x ::
       先考慮 {} 的實現問題
       這在於複雜化 type-stack 的接口
       使得其中的值本身可以是變長的
       每個變長 <type> 前後要有 <type-delimiter>
       有三種需要 <type-delimiter> 的地方
       構造子 []
       高階函數 {}
       其他結構化的值 (<類> 值)
       而 (<類> :變) 中也要保存位置
* 討論 <2015-09-05>
  - x ::
       思維散漫
       形式體系 證明論
       構造主義 構造主義的分析學
       攝影幾何 雙曲幾何 有理三角學
       我們好像已經忘記設計類型系統這個目標了
       漂泊忙亂
       我們現在需要重新調整作息時間
       適應新的環境 把經歷重新集中起來
  - k ::
       沒錯
       從 整理筆記 安排新計劃開始吧
  - x ::
       我還記得 bishop 的啓蒙
       我們應該 以計算語義爲主
       按照語義來設計形式系統和數學結構
       這樣才能使得理論實用
       新的計劃將以
       則式 的模式匹配 所形成的代數結構 爲主
       這個代數是範疇論的推廣
       這種推廣強調了可構造性和計算
       我將以此爲主線 重新整理筆記
  - k ::
       今天先休息吧
       讓新的探索在新的一天開始
  - x ::
       好的
