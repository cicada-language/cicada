* 題解
  * 術語表格
    | 動態類型 | 類型編碼於值                     |
    | 靜態類型 | 類型不編碼於值                   |
    | 類型檢查 | 定義函數時 檢查函數              |
    |          | 看 所聲明 與 所算得 類型是否匹配 |
    | 類型推導 | 避免 直接寫 函數類型聲明         |
    |          | 讓機器根據函數所作用於的值來推導 |
  * 決策
    1. 靜態類型
    2. 類型檢查
  * 評論
    在運行時 類型信息不被編碼在值中
    而是被記錄在 函數中
    做爲函數的元數據
* 問題
  * 聲明類型的語法如何
  * 與 代碼生成機制 之綜合
* 討論 <2015-06-17>
  - x ::
       我們發現 類型檢查機制 必須與 代碼生成機制 綜合起來討論
  - k ::
       那麼我們就先考慮二者之間相互影響的部分
  - x ::
       在此之前
       我本想去實現函數來問詢文件大小
       誰知道 它卻引我 實現 代碼生成機制 機制
       進而 來到最刺激的 類型檢查機制
       我以爲 去實現函數來問詢文件大小 只是實現 類型檢查機制 之前的消遣而已
  - k ::
       此謂計劃之必失
  - x ::
       類型檢查機制 是我認爲最有趣的機制之一
       首先說其特點
    1. 可選擇開啓與否
    2. 需要更改很多代碼工作量很大
    3. 關乎代碼優化 即 編譯時期提前作用
       之前看來
       其難度在於類型編碼
       現在有了 name-hash-table
       這已經有望解決了
  - k ::
       我們可以回顧一下之前關於類型的筆記
  - x ::
       但是那有是浪費鋒芒
       不是嘛
  - k ::
       也許吧
  - x ::
       我們嘗試鋒芒畢露一下
       快速羅列一些要點
    1. 可計算性 可計算的不限於傳統的類型 也可以包含副作用
    2. <type> 可以做爲一個 variable-jo 存在
    3. 不必處理局部變元
    4. 全局變元也需要有類型聲明
    5. 孤獨者用 name 編碼
       因複合而嵌套者通過就地嵌套 name 的向量編碼
    6. 所謂 因複合而嵌套者 有一下各種
       1. 同類型的數據所組成的向量
       2. 不同類型的數據所組成的向量 [匿名結構]
       3. 高階函數
       對於嵌套的類型編碼 高階函數語法上用掉 {}
       向量重載 []
    7. 需要處理 scope 就像局部變元的 scope-stack 一樣
       也許應該共用一個 scope-stack
    8. 多類型函數返回值的函數也被處理
       比如以 find 爲後綴的函數
       只要一種類型能行即可
       但是這可能嘛
       對於 find 而言是可能的
       因爲多出來的 類型可以被 if 消去
    9. 類型變元
  - k ::
       我想我們可以嘗試把想像具體化了
       並且舉幾個具體的例子
  - x ::
       首先是類型編碼
       根據複合與否有兩類
    1. 素類型
       其編碼用 形如 <type> 的 name
       {<number> -- <number>}
    2. 複合類型
       其編碼用 用 素類型 的數組
       目前我能想到三種類型
       1. 同類數組
          {[<number>*] -- }
       2. 異類數組
          { -- [<number> <gamber> <string>]}
       3. 函數
          {{<number> -- <number>} -- {<number> -- <number>}}
       比如
       {<number> -- <number>}
       做爲數組是
       | {        |
       | length   |
       | <number> |
       | --       |
       | <number> |
       | length   |
       | }        |
       這樣就能夠前後遍歷了
       類型變元就是 不帶 <> 的 name
       比如 {a a -- a}
       這樣 類型就是 一等公民了
       並且使用新的類型的時候也不需要定義
  - k ::
       其次是對類型的計算
  - x ::
       沒錯
       我可以嘗試窮舉所需要處理的情況
    1. 函數複合
       [平凡的]
    2. 全局變元
       [平凡的]
    3. 函數作用
       [古典的]
    4. 類型變元
    5. 分支
  - k ::
       (4) (5) 比較困難
  - x ::
       的確
       我們來讓問題變得更具體
       所謂計算有輸入值和輸出值
       用於計算類型函數本身也可以被加上類型標籤
       {<string> <type> -- <bool>}
       也許返回值不應該如此單薄
       畢竟我們要做詳細的報錯
  - k ::
       先看難點 (4)
  - x ::
       這並不難處理
       假設我給 類型變元 以額外的語法
       比如 +type-variable+
       那麼這種東西就可以出現在類型中的任何地方
    1. 同類數組
       {[+aaa+*] -- }
    2. 異類數組
       { -- [<number> <gamber> <string> +aaa+]}
    3. 函數
       {{<number> -- +aaa+} -- {<number> -- <number>}}
       變元在於賦值
       只要知道賦值如何發生即可
       比如棧中有
       {<number>}
       有類型爲 {+aaa+ -- <string>} 的函數作用於棧
       那麼 +aaa+ 就會被賦值爲 <number>
       又比如
       棧中有 {+aaa+}
       有類型爲 {<number> -- <string>} 的函數作用於棧
       就會失敗
       因爲 +aaa+ 不一定爲 <number>
       不過看來我需要形成更好的數學模型
       來討論類型系統的一般性質
       上面這些舉例並不能保證其設計良好
  - k ::
       還有 (5) 呢
  - x ::
       這又引發了額外的問題
       比如
       {<string>
        -- <string> true
        -- false}
       有 <bool> literal 在棧中
       這就要求類型中能夠出現 literal
       此時
       產生分歧 後面一定要有 if
       if 會處理分歧
       如果假設 if 是唯一的產生分支的語法
       那麼處理完這種情況之後
       就完備了
       但是
       如果今後增添處理 if 的關鍵詞
       那麼就必須擴展類型計算以處理新的語法關鍵詞
       也就是說
       沒增添一個語法關鍵詞
       如果想要它在 REPL 中能用就要爲解釋器重新實現一遍
       如果想要它在 類型檢查 中能用就要在類型檢查器中重新實現一遍
       沒有別的辦法了
  - k ::
       這裏 literal 應該如何處理
       語法如何設計
       編碼如何
  - x ::
       比如 我將一般的 沒有 <title> 前綴的 詞做爲 literal
       這樣就能處理 數字 還有 bool
       這種素 literal
       複合數據的 literal 還不行
       尤其是考錄到 內存就地分配的問題
       我明白了
       我們必須先設計完備的 向量處理機制
       然後把 type 用向量來實現
       這裏要求的性狀是
       每個向量中都能夠就地保存各種類型的 素數據 或 複合數據
  - k ::
       如果這樣 處動態類型標籤一定要被保存在 向量中了
       這樣不就成了動態類型語言
  - x ::
       我們來仔細考察一下向量這個東西
       首先
       我假設
       所有向量處理函數 如果改變了向量的長度
       那麼就一定要 生成新的向量 而不是在原有的向量上做副作用
       其次
       向量之在 棧中的存在如同 <string>
       而向量在內存中的存在必須包含其長度
       也就是說
       向量這個數據結構必須要有豐富的元數據
       因爲它將是 cicada-nymph 的主要數據結構
       所有的東西都依賴與它
       最主要的元數據是向量的長度
       這個長度需要被包含到向量的開頭和結尾
       以實現兩個方向的遍歷
       用來遍歷向量的函數 就如目前用來處理 <string> 的類似
       通過不同的接口函數可以以不同的語義來理解向量
    1. 最簡單的語義是 cell
    2. 類型系統所需要的語義是 element [暫且命名如此]
  - k ::
       然而
       如果可以嵌套
       那麼獲取 element 的函數所能取得的值就可以能是 <name> 和 <vector>
       也就是說 <vector> 這個數據類型 不是同質的
       不光能夠有 vector of <number>
       即 [<number> *]
       還能有 vector of <number> or <vector>
       即 [<number>|<vector>]
       這樣
       之前所說的 異質向量類型
       [<number> <gamber> <string>]
       其實是不存在的
  - x ::
       首先在設計決策上
       我放棄所謂類型的絕對安全
       這樣上面的異質向量就是可以容忍的
       但是
       是否可能
       因爲這算是又出現了一種類型分歧
       我可以通過定義新的類型來包含 <number> 和 <vector>
       以使得 上面的向量 變爲同質的
       而直接的 [<number>|<vector>] 相當於是匿名的類型
       其實
       所有複合類型的出現都可以看成是匿名類型
       但是
       如果說上面的 <number> 和 <vector> 可以被定義爲一個新的類型的話
       這無疑是說 類型不是簡單的 name 了
       類型之間是有關係的
  - k ::
       沒錯
       其他語言的類型系統也是如此
       這樣使用類型之前就必須要明顯定義了
  - x ::
       如果大量使用匿名類型的話
       可否避免這種情況
  - k ::
       不可以
       這又回到了
       名與匿名之間的平衡
       命名是一種抽象方法
       複雜的匿名類型不能總以全稱出現
       必須有方法以命名它
  - x ::
       不過
       上面的把異質的向量變成同質
       看似是絕對需要定義新複合類型的地方
       比如 定義 <vexp> 爲 <name> | <vector>
       那麼處理 <vexp> 的函數又該如何
       是使用 <vector> 爲前綴者
       還是使用 新的 <vexp> 爲前綴者
       還有
       [<number>]
       其實是 vector of <number>
       也就說是一種類型構造子
       這種類型構造子的使用能否一般化
       比如 {<number> -- <gamber>}
       其實是 function of <number> -- <gamber>
       也是一種類型構造子
  - k ::
       這樣就有兩個層次的可以自由定義的東西了
       一個是 類型構造子
       一個是 類型本身
  - x ::
       我現在想類型系統對與 cicada-nymph 來說
       是否可能
  - k ::
       注意
       我們不需要完全的類型安全
  - x ::
       但是這是什麼意思
       那些地方是可以不安全的
  ----------------------------------
  - x ::
       我回顧了一下之前的筆記
    1. 類型構造子這個概念必須被引入
       每個類型構造子對應於
       一組類型解構子
    2. 類型推導
       所有函數必須都有類型前綴
       這些類型前綴在推導器的幫助下
       可以被完全省略
       類型信息之使用
       是爲了進行推導
       以回覆類型前綴
       從而找到需要被編譯到函數體中的函數
    3. 類型檢查
       不要求名每個函數都有類型前綴
       類型信息之使用
       函數體中必須使用函數的全名
       在於檢查所聲明者
       是否與所計算者相互匹配
  - k ::
       如上二者對類型信息的使用方式不同
       但是對類型的計算方式可能完全相同
  - x ::
       沒錯
       現在需要知道的問題是
    1. 類型構造子 如何用向量實現
       類型結解構子是什麼
    2. 定義新的類型意謂着什麼
    3. 如何處理 異質 向量
       必須要命名碼
       是否能用類型構造子匿名
       既然 [<number>] 代表匿名的類型
       那麼
       類型構造子其實就是一種匿名機制
       既然匿名 其內信息就必須完整出現
  - k ::
       需要兩個機制
       一個是匿名
       一個是命名
       匿名需要用到類型造子
       命名需要用到代入語義 即 區分 素與複合
       一個類型名字 <type> 可能是一個素類型
       也可能是一個複合類型的名字
       每個複合類型都是用各種類型構造子來構造的
       類型構造子可以用戶定義
       每個類型構造子都對已一些類型解構子
       我來簡化下問題
       這在於去除語法糖
       要知道 如果考慮類型構造子的話
       那麼 {} 和 [] 其實都是特殊的語法糖
       所以爲了簡化問題
       必須設計 不帶語法糖的一般語法
  - x ::
       以 {} 類型構造子之邊綴
       之前的
       [<number>]
       對應於
       {vector: <number>}
       之前的
       {{<number> -- <number>} -- {<number> -- <number>}}
       對應於
       {function: {function: <number> -- <number>} -- {function: <number> -- <number>}}
       或者
       {function:
        {{function: {<number>} {<number>}}}
        {{function: {<number>} {<number>}}}}
       它們都是特殊的嵌套的向量
       其實所謂嵌套
       就是把向量的長度包含進去 然後將向量的接口做特殊處理 以利用這些長度信息
  - k ::
       這種語法看來並不令人滿意
  - x ::
       我明白了
       所謂構造子與解構子
       其構造子可以直接被實現爲嵌套的 name 的 vector
       而解構子是對這種類型的數據的模式匹配
       上面的語法並不令人滿意
       其實
       {{<number> -- <number>} -- {<number> -- <number>}}
       應該保持其簡潔
       這種模式的 name vector 所代表的是棧中元素類型的變化
       這是最主要的模式
       其他的模式以 [] 爲邊 比如 [aaa:]
       默認者 [] 可以做爲一種省略情形
       (apply) 的類型是
       {+a1+ ... +an+ {+a1+ ... +an+ -- +b1+ ... +bn+} -- +b1+ ... +bn+}
       我明白了
       每個函數的類型聲明其實也是一個函數
       只不過是在編譯時期作用
       因 這類函數很特殊
       而 用特殊的語法寫成
  - k ::
       可以將這個概念一般化嘛
  - x ::
       還有對其他副作用的計算等等
       都可以用這種編譯時期的作用來理解
       還有優化也是
       還有代碼生成也是
  - k ::
       我認爲這是非常有趣的理解方式
       認識方式比處理手段更重要
       可以說現在我們已經獲得最重要的東西了
  - x ::
       沒錯
       我對整個系統的理解方式都改變了
       需要好好反思以調和新認識方式所帶來的衝突
  ----------------------------------
