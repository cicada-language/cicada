;;;; before you compile the code
;;;; do not forget to choose your platform
;;;; in the following code

linux? equ yes
windows? equ no

;; in fasm, "dup" is a reserved word
dup equ duplicate

;; in fasm, "end" is a reserved word
finish equ end
end equ exit

if linux? eq yes

define sys_6_r8  r8
define sys_5_r9  r9
define sys_4_r10 r10
define sys_3_rdx rdx
define sys_2_rsi rsi
define sys_1_rdi rdi
define sys_n_rax rax

;; the only three linux syscall we will use
define syscall_read    0
define syscall_write   1
define syscall_exit    60

finish if

if linux? eq yes

format elf64 executable 3

finish if

if linux? eq yes

entry begin_to_interpret_threaded_code
segment readable executable writeable

finish if

if windows? eq yes

STD_INPUT_HANDLE     = -10
STD_OUTPUT_HANDLE    = -11

define fun_4_r9   r9
define fun_3_r8   r8
define fun_2_rdx  rdx
define fun_1_rcx  rcx

finish if

if windows? eq yes

format PE64 console

finish if

if windows? eq yes

entry begin_to_interpret_threaded_code
section '.text' code writeable readable executable

finish if

jo_size = 8 ;; (byte)
xx equ dq

;; if you want to extend cicada in assembly
;; the following registers must NOT be used

;; =================================
define pointer$argument_stack   r15
define pointer$return_stack     r14
;; =================================

macro push_argument_stack register {
   mov [pointer$argument_stack], register
   add pointer$argument_stack, jo_size
   }
macro pop_argument_stack register {
   sub pointer$argument_stack, jo_size
   mov register, [pointer$argument_stack]
   }

macro push_return_stack register {
   mov [pointer$return_stack], register
   add pointer$return_stack, jo_size
   }
macro pop_return_stack register {
   sub pointer$return_stack, jo_size
   mov register, [pointer$return_stack]
   }

current_free_address$un_initialized_memory = address$un_initialized_memory

labeling  equ = current_free_address$un_initialized_memory
preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +

macro next {
   pop_return_stack rbx
     mov rax, qword [rbx]
   add rbx, jo_size
   push_return_stack rbx
     jmp qword [rax]
}

if linux? eq yes

__exit_with_TOS:
   pop_argument_stack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

finish if

if linux? eq yes

__exit_with_zero:
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

finish if

if linux? eq yes

__exit_with_six:
   mov sys_1_rdi, 6
   mov sys_n_rax, syscall_exit
   syscall

finish if

if windows? eq yes

__exit_with_TOS:
   number_of_arguments = 4
   push rbp
   mov rbp, rsp

   mov rax, rsp
   add rax, 8*number_of_arguments
   mov rbx, 1111b
   and rbx, rax

   sub rsp, 16
   add rsp, rbx

   sub rsp, 8*4
   pop_argument_stack fun_1_rcx
   call [ExitProcess]

   mov rsp, rbp
   pop rbp

finish if

if windows? eq yes

__exit_with_zero:
   number_of_arguments = 4
   push rbp
   mov rbp, rsp

   mov rax, rsp
   add rax, 8*number_of_arguments
   mov rbx, 1111b
   and rbx, rax

   sub rsp, 16
   add rsp, rbx

   sub rsp, 8*4
   xor fun_1_rcx, fun_1_rcx
   call [ExitProcess]

   mov rsp, rbp
   pop rbp

finish if

if windows? eq yes

__exit_with_six:
   number_of_arguments = 4
   push rbp
   mov rbp, rsp

   mov rax, rsp
   add rax, 8*number_of_arguments
   mov rbx, 1111b
   and rbx, rax

   sub rsp, 16
   add rsp, rbx

   sub rsp, 8*4
   mov fun_1_rcx, 15
   call [ExitProcess]

   mov rsp, rbp
   pop rbp

finish if

;; initial link to point to 0 (as null)
link = 0

size$primitive_string_heap = 100 * 1024 ;; (byte)

address$primitive_string_heap:
   times size$primitive_string_heap db 0

current_free_address$primitive_string_heap = address$primitive_string_heap

macro make_primitive_string string {

virtual at 0
.start$string:
   db string
.end$string:
   dw (.end$string - .start$string)
   load .length word from (.end$string)
finish virtual
store word .length at (current_free_address$primitive_string_heap)

current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

repeat .length
   virtual at 0
      db string
      load .char byte from (% - 1)
   finish virtual
   store byte .char at (current_free_address$primitive_string_heap)
   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
finish repeat

}

macro define_function string, jo {

define_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$function

   ;; here follows a jojo as function-body

   }

explain$function:
   add rax, jo_size
   push_return_stack rax
   next

macro define_primitive_function string, jo {

define_primitive_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx assembly_code__#jo

assembly_code__#jo:

   ;; here follows assembly code
   ;; as primitive function body

   }

macro define_variable string, jo {

define_variable__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$variable

   ;; here follows a value of jo_size
   ;; only one value is allowed

   }

explain$variable:
   add rax, jo_size
   mov rbx, [rax]
   push_argument_stack rbx
   next

define_primitive_function "end", end
   pop_return_stack rbx
   next

if linux? eq yes

begin_to_interpret_threaded_code:

   cld ;; set DF = 0, then rsi and rdi are incremented

   mov pointer$argument_stack,  address$argument_stack
   mov pointer$return_stack,    address$return_stack

   mov rax, first_jojo
   push_return_stack rax
   next

finish if

if windows? eq yes

;;;; for windows
_output_handle:
   dq 0
_input_handle:
   dq 0
;;;;

begin_to_interpret_threaded_code:

   cld ;; set DF = 0, then rsi and rdi are incremented


   ;;;; for windows
   number_of_arguments = 4
   push rbp
   mov rbp, rsp
   mov rax, rsp
   add rax, 8*number_of_arguments

   mov rbx, 1111b
   and rbx, rax

   sub rsp, 16
   add rsp, rbx


   sub rsp, 8*4
   mov fun_1_rcx, STD_INPUT_HANDLE
   call [GetStdHandle]
   mov [_input_handle], rax


   mov rsp, rbp
   pop rbp



   number_of_arguments = 4
   push rbp
   mov rbp, rsp

   mov rax, rsp
   add rax, 8*number_of_arguments
   mov rbx, 1111b
   and rbx, rax

   sub rsp, 16
   add rsp, rbx

   sub rsp, 8*4
   mov fun_1_rcx, STD_OUTPUT_HANDLE
   call [GetStdHandle]
   mov [_output_handle], rax

   mov rsp, rbp
   pop rbp
   ;;;;


   mov pointer$argument_stack,  address$argument_stack
   mov pointer$return_stack,    address$return_stack

   mov rax, first_jojo
   push_return_stack rax
   next

finish if

first_jojo:
   xx little_test

define_primitive_function "bye", exit_with_TOS
   call __exit_with_TOS

define_variable "", V__little_test_number
   xx 3


define_function "little_test", little_test

   ;;;; variable
   xx V__little_test_number
   xx exit_with_TOS
   ;;;; 3

preserve 64 * jo_size
address$argument_stack labeling
   preserve 1024 * 1024 * jo_size

preserve 64 * jo_size
address$return_stack labeling
   preserve 1024 * 1024 * jo_size

if linux? eq yes

size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

segment readable writeable
address$un_initialized_memory:
   rb size$un_initialized_memory

finish if

if windows? eq yes

size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

section '.data' data readable writeable
address$un_initialized_memory:
   rb size$un_initialized_memory

finish if

if windows? eq yes


;; Macroinstructions for making import section (64-bit)

macro library [name,string]
 { common
    import.data:
   forward
    local _label
    if defined name#.redundant
     if ~ name#.redundant
      dd RVA name#.lookup,0,0,RVA _label,RVA name#.address
     finish if
    finish if
    name#.referred = 1
   common
    dd 0,0,0,0,0
   forward
    if defined name#.redundant
     if ~ name#.redundant
      _label db string,0
             rb RVA $ and 1
     finish if
    finish if }

macro import name,[label,string]
 { common
    rb (- rva $) and 7
    if defined name#.referred
     name#.lookup:
   forward
     if used label
      if string eqtype ''
       local _label
       dq RVA _label
      else
       dq 8000000000000000h + string
      finish if
     finish if
   common
     if $ > name#.lookup
      name#.redundant = 0
      dq 0
     else
      name#.redundant = 1
     finish if
     name#.address:
   forward
     if used label
      if string eqtype ''
       label dq RVA _label
      else
       label dq 8000000000000000h + string
      finish if
     finish if
   common
     if ~ name#.redundant
      dq 0
     finish if
   forward
     if used label & string eqtype ''
     _label dw 0
            db string,0
            rb RVA $ and 1
     finish if
   common
    finish if }


section '.idata' import data readable writeable

library kernel32,'KERNEL32.DLL'

import kernel32,\
       ExitProcess,'ExitProcess',\
       ReadFile,'ReadFile',\
       WriteFile,'WriteFile',\
       GetStdHandle,'GetStdHandle'


finish if
