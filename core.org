#+TITLE:  core of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** syntax for exception handling in cicada-nymph
* ===================================
* misc
  #+begin_src cicada-nymph :tangle core.cn
  : cr << cr denotes carriage return >>
    << -- >>
    10 write-byte
    end
  ; define-function
  #+end_src
* -----------------------------------
* if & else & then
  * one predicate can make two branchs
    three predicates can make four branchs
    three predicates may only make three branchs
    but indeed there must be an invisible branch
  #+begin_src cicada-nymph :tangle core.cn
  : if
    << string[address, length] --
       address, string[address, length] >>
    *false?branch* save-into,jo-heap
    *current-free-address,jo-heap* xx|swap|x
    0 save-into,jo-heap
    end
  ; define-macro

  : else
    << address, string[address, length] --
       address, string[address, length] >>
    *branch* save-into,jo-heap
    x|swap|xx
    *current-free-address,jo-heap* xxx|swap|x
    0 save-into,jo-heap
    << address, string[address, length], address >>
    *current-free-address,jo-heap*
    over sub *jo-size* div
    swap save
    end
  ; define-macro

  : then
    << address, string[address, length] --
       string[address, length] >>
    x|swap|xx
    *current-free-address,jo-heap*
    over sub *jo-size* div
    swap save
    end
  ; define-macro
  #+end_src
* test
  #+begin_src cicada-nymph
  : kkk
    "kkk took my baby away !" write-string
    cr
    end
  ; define-function

  : factorial
    << number -- number >>
    dup
    one? if
      end
    then
    dup sub1 factorial
    mul
    end
  ; define-function


  1 factorial .
  2 factorial .
  3 factorial .
  4 factorial .
  5 factorial .
  6 factorial .
  7 factorial .
  8 factorial .
  9 factorial .
  10 factorial .
  11 factorial .
  12 factorial .
  13 factorial .
  14 factorial .
  15 factorial .
  16 factorial .
  17 factorial .
  18 factorial .
  19 factorial .
  20 factorial .


  : .12
    << 1 2 -- >>
    2 equal? if
      "(^-^)" write-string
      1 equal? if
        "\^o^/" write-string
      else
        "     " write-string
      then
    else
      "     " write-string
      1 equal? if
        "\^o^/" write-string
      else
        "     " write-string
      then
    then
    end
  ; define-function

  cr
  1 2 .12 cr
  6 2 .12 cr
  1 6 .12 cr
  6 6 .12 cr
  #+end_src
* -----------------------------------
* re-define execute-word & basic-REPL
  * to protect macro & exception from be called from basic-REPL
  #+begin_src cicada-nymph :tangle core.cn
  : execute-word
    << word[address, length] -- unknown >>
    dup2 integer-string? if
      string->integer
      end
    then
    dup2
    find if
      dup macro-jo? if
        drop
        "* (execute-word) CAN NOT EXECUTE MACRO DIRECTLY : " write-string
        write-string cr
        end
      then
      dup exception-jo? if
        drop
        "* (execute-word) CAN NOT EXECUTE EXCEPTION DIRECTLY : " write-string
        write-string cr
        end
      then
      << function & primitive-function & variable >>
      xx|swap|x drop2
      execute-jo
      end
    else
    "* (execute-word) MEETS UNDEFINED WORD : " write-string
    write-string cr
    then
    end
  ; define-function

  : basic-REPL
    << unknown -- unknown >>
    read-word-for-REPL
    execute-word
    <> basic-REPL
  ; define-function

  basic-REPL
  #+end_src
* report
** show-dictionary,primitive-function
   #+begin_src cicada-nymph :tangle core.cn
   : loop,show-dictionary,primitive-function
     << counter, jo -- >>
     dup zero? if
       drop
       end
     then
     dup primitive-function-jo? false? if
       jo->pre-jo
       <> loop,show-dictionary,primitive-function
     then
     swap
       "  " write-string
       dup . add1
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "UN-NAMED" write-string cr
     else
       write-string cr
     then
     jo->pre-jo
     <> loop,show-dictionary,primitive-function
   ; define-function

   : show-dictionary,primitive-function
     << -- >>
     "* ALL PRIMITIVE-FUNCTION IN DICTIONARY :" write-string cr
     1
     *first-jo-in-dictionary*
     loop,show-dictionary,primitive-function
     end
   ; define-function
   #+end_src
** show-dictionary,function
   #+begin_src cicada-nymph :tangle core.cn
   : loop,show-dictionary,function
     << counter, jo -- >>
     dup zero? if
       drop
       end
     then
     dup function-jo? false? if
       jo->pre-jo
       <> loop,show-dictionary,function
     then
     swap
       "  " write-string
       dup . add1
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "UN-NAMED" write-string cr
     else
       write-string cr
     then
     jo->pre-jo
     <> loop,show-dictionary,function
   ; define-function

   : show-dictionary,function
     << -- >>
     "* ALL FUNCTION IN DICTIONARY :" write-string cr
     1
     *first-jo-in-dictionary*
     loop,show-dictionary,function
     end
   ; define-function
   #+end_src
** show-dictionary,macro
   #+begin_src cicada-nymph :tangle core.cn
   : loop,show-dictionary,macro
     << counter, jo -- >>
     dup zero? if
       drop
       end
     then
     dup macro-jo? false? if
       jo->pre-jo
       <> loop,show-dictionary,macro
     then
     swap
       "  " write-string
       dup . add1
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "UN-NAMED" write-string cr
     else
       write-string cr
     then
     jo->pre-jo
     <> loop,show-dictionary,macro
   ; define-function

   : show-dictionary,macro
     << -- >>
     "* ALL MACRO IN DICTIONARY :" write-string cr
     1
     *first-jo-in-dictionary*
     loop,show-dictionary,macro
     end
   ; define-function
   #+end_src
** show-dictionary,exception
   #+begin_src cicada-nymph :tangle core.cn
   : loop,show-dictionary,exception
     << counter, jo -- >>
     dup zero? if
       drop
       end
     then
     dup exception-jo? false? if
       jo->pre-jo
       <> loop,show-dictionary,exception
     then
     swap
       "  " write-string
       dup . add1
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "UN-NAMED" write-string cr
     else
       write-string cr
     then
     jo->pre-jo
     <> loop,show-dictionary,exception
   ; define-function

   : show-dictionary,exception
     << -- >>
     "* ALL EXCEPTION IN DICTIONARY :" write-string cr
     1
     *first-jo-in-dictionary*
     loop,show-dictionary,exception
     end
   ; define-function
   #+end_src
** show-dictionary,variable
   #+begin_src cicada-nymph :tangle core.cn
   : loop,show-dictionary,variable
     << counter, jo -- >>
     dup zero? if
       drop
       end
     then
     dup variable-jo? false? if
       jo->pre-jo
       <> loop,show-dictionary,variable
     then
     swap
       "  " write-string
       dup . add1
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "UN-NAMED" write-string cr
     else
       write-string cr
     then
     jo->pre-jo
     <> loop,show-dictionary,variable
   ; define-function

   : show-dictionary,variable
     << -- >>
     "* ALL VARIABLE IN DICTIONARY :" write-string cr
     1
     *first-jo-in-dictionary*
     loop,show-dictionary,variable
     end
   ; define-function
   #+end_src
** show-dictionary
   * different types of words in dictionary
     are showed separately
   #+begin_src cicada-nymph :tangle core.cn
   : show-dictionary
     << -- >>
     show-dictionary,primitive-function
     show-dictionary,function
     show-dictionary,macro
     show-dictionary,exception
     show-dictionary,variable
     end
   ; define-function
   #+end_src
** report-memory
   #+begin_src cicada-nymph :tangle core.cn
   : report-memory
     << -- >>
     "* *un-initialized-memory*" write-string cr
     "  * SIZE : " write-string
          *size,un-initialized-memory*
          . cr
     "  * USED : " write-string
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub . cr
     "  * FREE : " write-string
          *size,un-initialized-memory*
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub sub . cr
     "* *primitive-string-heap*" write-string cr
     "  * SIZE : " write-string
          *size,primitive-string-heap*
          . cr
     "  * USED : " write-string
          *current-free-address,primitive-string-heap*
          *primitive-string-heap*
          sub . cr
     "  * FREE : " write-string
          *size,primitive-string-heap*
          *current-free-address,primitive-string-heap*
          *primitive-string-heap*
          sub sub . cr
     "* *jo-heap*" write-string cr
     "  * SIZE : " write-string
          *size,jo-heap* . cr
     "  * USED : " write-string
          *current-free-address,jo-heap*
          *jo-heap*
          sub . cr
     "  * FREE : " write-string
          *size,jo-heap*
          *current-free-address,jo-heap*
          *jo-heap*
          sub sub . cr
     end
   ; define-function
   #+end_src
* -----------------------------------
* allocate
  * an interface of *un-initialized-memory*
  #+begin_src cicada-nymph :tangle core.cn
  : allocate
    << size -- address >>
    *un-initialized-memory* tuck
    add address *un-initialized-memory* save
    end
  ; define-function
  #+end_src
* ===================================
很高興收到你的郵件^-^

1. 未济 是我朋友的金屬樂隊
   四月份有演出 可以一起來玩 ^-^
   我大二大三的時候有在民謠樂隊裏演出過(吹口琴)
   我那個時候還和朋友辦演出(還在中大辦過呢)
   不過現在朋友們都各自有別的事業了
   就只有 未济主唱 來找我的時候
   還偶爾在排練房一起玩
2. 我是數學專業的
   不過我覺得數學和計算機科學都應該是融會貫通的
   (我也不知道將來會不會以寫程序爲職業 對前途也有點迷茫呢)
   網站主要是方便大家瀏覽代碼用的
   所以設計的主要思路就是
   把我編輯代碼時候的效果展示出來
   所以看起來當然有在編輯代碼的感覺了
   (雖然你只能瀏覽而不能真正編輯它)
3. 相似的還有
   * 蘋果核戰紀
   * 星際牛仔
   另外 攻殼 還有別的劇場版
   還有四集新劇場(人設有些變動)


 關於程序語言
 * 人們使用的程序語言因人之喜好而異
   每個程序語言都有不同的特點
   就像 漢語 拉丁語 德語 英語 各自有不同的特點一樣
 * 人類用人類的語言來相互交流
   同時一個人所使用和熟悉的語言
   又影響着這個人的 思考方式 和 表達方式
 * 程序語言也是一樣
   人們用程序語言來和機器交流(控制機器)
   而在使用每種不同的程序語言的過程中
   你也能體會到不同的 思維範式 和 表達範式
 * 我所學會的第一個程序語言叫 scheme 
   第二個是 forth
   (而我想要教大家的 cicada-nymph 就是類似與 forth 的)
   我熟悉這兩個語言的技術細節和實現方式
 * 我還瞭解很多其他的語言
   但是都不如我對這兩個語言的瞭解深入
   比如
   - common-lisp
   - coq
   - emacs-lisp
   - erlang
   - haskell
   - joy
   - minikanren
   - ml 
   - racket
   - shen
   - smalltalk
   - tcl
 * 就像當你熟悉 拉丁語 和 梵語 之後
   學習 德語 法語 和 世界語 就會很容易一樣
   只要你瞭解程序語言的基本原理
   再學習一個新的語言
   可能只要 兩個小時 或 一個週末 而已
   所以
   瞭解很多語言 也沒有什麼了不起的
 * 而z在我看來
   去瞭解和學習各種語言的特性和實現技術
   本身就是非常有趣的   
   就像是小孩在玩積木一樣 ^-^
