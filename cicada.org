#+TITLE:  蟬語 / cicada
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com
* name-hash-table
  * some function to do report about name-hash-table
* todo
** title-name-table
** data-giver
* ===================================
* note
** notation
   * use ","
** data section in cicada-nymph
** style
   * to use global-variable more
     may will make code be better
     for stack operations are less
   * another way is to design good macro for operations
* -----------------------------------
* name-hash-table
** note naming & factoring
   * open addressing
     for we do not need to delete
   * math
     * hash
     * probe
   * memory
     * insert
     * search
   * function
     * map
     * reverse
** memory allocation
   * the following are some prime number
     ready to be used
     * 1000003   about 976 k
     * 1000033
     * 1000333
     * 100003    about 97 k
     * 100333
     * 997
     * 499
   #+begin_src cicada-nymph :tangle cicada.cn
   1000333
   : *name-hash-table,size*
   ; define-variable

   *jo-size* 4 mul
   : *name-hash-table,unit*
   ; define-variable

   *name-hash-table,size*
   *name-hash-table,unit* mul
   allocate-memory
   : *name-hash-table*
   ; define-variable

   0
   : *name-hash-table,counter*
   ; define-variable
   #+end_src
** hash
   * prime table size
   * linear probing
   #+begin_src cicada-nymph :tangle cicada.cn
   : name-hash-table,hash
     << number, counter -- index >>
     add *name-hash-table,size* mod
     end
   ; define-function
   #+end_src
** string->finite-carry-sum
   #+begin_src cicada-nymph :tangle cicada.cn
   16
   : *max-carry-position*
   ; define-variable

   : string->finite-carry-sum,loop
     << carry-sum, string[address, length], counter -- carry-sum >>
     over zero? if
       drop drop2
       end
     then
     dup *max-carry-position* greater-than? if
       drop 0 << re-start from 0 >>
     then
     xx|over|x
     string-head,char over
     2 swap power
     mul
     x|swap|xxxx add xxx|swap|x
     add1 xx|swap|x
     string-tail,char x|swap|xx
     <> string->finite-carry-sum,loop
   ; define-function

   : string->finite-carry-sum
     << string[address, length] -- carry-sum >>
     0 xx|swap|x << carry-sum >>
     0 << counter >>
     string->finite-carry-sum,loop
     end
   ; define-function
   #+end_src
** name
*** note
    * a name is an index into name-hash-table
    * an entry can be viewed
      1. as a point
      2. as an orbit
    * in a name entry we have the following fields
      |-------------------------------+-------------------------|
      |                               | note                    |
      |-------------------------------+-------------------------|
      | primitive-string              | 0 denotes               |
      | [address]                     | name not used           |
      |-------------------------------+-------------------------|
      | title                         | 0 denotes               |
      | [index into name-title-table] | name not used as title  |
      |-------------------------------+-------------------------|
      | orbit-length                  | as an orbit             |
      | [number]                      | its length gets updated |
      |-------------------------------+-------------------------|
      | orbiton                       | as a point              |
      | [address]                     | it is on an orbit       |
      |-------------------------------+-------------------------|
*** name->address
    #+begin_src cicada-nymph :tangle cicada.cn
    : name->address
      << name -- address >>
      *name-hash-table,unit* mul
      *name-hash-table* add
      end
    ; define-function
    #+end_src
*** name,used?
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,used?
      << name -- bool >>
      name->address
      fetch zero? false?
      end
    ; define-function
    #+end_src
*** name,used-as-title?
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,used-as-title?
      << name -- bool >>
      name->address
      *jo-size* add
      fetch zero?
      end
    ; define-function
    #+end_src
*** name,fetch-string
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,fetch-string
      << name -- string[address, length] >>
      name->address
      fetch
      address->primitive-string
      end
    ; define-function
    #+end_src
*** name,fetch-title-index
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,fetch-title-index
      << name -- index >>
      name->address
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbit-length
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,fetch-orbit-length
      << name -- length >>
      name->address
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbiton
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,fetch-orbiton
      << name -- address >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,save-string
    * note that
      primitive-string-heap is used
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,save-string
      << string[address, length], name -- >>
      *current-free-address,primitive-string-heap*
      xx|swap|xx
      save-into,primitive-string-heap
      swap
      name->address
      save
      end
    ; define-function
    #+end_src
*** name,save-title-index
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,save-title-index
      << index, name -- >>
      name->address
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbit-length
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,save-orbit-length
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbiton
    #+begin_src cicada-nymph :tangle cicada.cn
    : name,save-orbiton
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
** search
   #+begin_src cicada-nymph :tangle cicada.cn
   : name-hash-table,search,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     xx|tuck|xx name-hash-table,hash
     xx|tuck|x
     << number, counter, name, string[address, length], name >>
     name,used? false? if
       drop2 xx|swap|x drop2
       false
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-string
     xx|over|xx string-equal? if
       drop2 xx|swap|x drop2
       true
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-orbit-length
     x|over|xxxx equal? if
       drop2 xx|swap|x drop2
       false
       end
     then
     << number, counter, name, string[address, length] >>
     x|swap|xx drop
     xx|swap|xx add1
     <> name-hash-table,search,loop
   ; define-function

   : name-hash-table,search
     << string[address, length]
        -- name, true
        -- false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,search,loop
     end
   ; define-function
   #+end_src
** insert
   * I found that (insert) can not re-use (search)
   #+begin_src cicada-nymph :tangle cicada.cn
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name
        -- false >>
     xx|tuck|xx name-hash-table,hash
     xx|tuck|x
     << number, counter, name, string[address, length], name >>
     name,used? false? if
       x|over|xx name,save-string
         xx|tuck|x << name as return value >>
       x|over|xx 0 name-hash-table,hash
       swap name,save-orbiton
       swap 0 name-hash-table,hash
       name,save-orbit-length
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-string
     xx|over|xx string-equal? if
       drop2 xx|swap|x drop2
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-orbit-length
     *name-hash-table,size* equal? if
       drop2 drop drop2
       false
       end
     then
     << number, counter, name, string[address, length] >>
     x|swap|xx drop
     xx|swap|xx add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name
        -- false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** string->name & name->string
   * error handling here
   #+begin_src cicada-nymph :tangle cicada.cn
   : string->name
     << string[address, length] -- name >>
     name-hash-table,insert
     dup false? if
       drop
       "* (string->name) *name-hash-table* IS FULL!" write-string cr
       end
     then
     end
   ; define-function

   : name->string
     << name -- string[address, length]] >>
     name,fetch-string
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph :tangle cicada.cn
   : name-hash-table,test
     << -- name >>
     "a-string-to-test-name-hash-table"
     name-hash-table,insert . cr
     "a-string-to-test-name-hash-table"
     name-hash-table,search . . cr
     "a-string-to-test-name-hash-table,2"
     name-hash-table,search . . cr
     "a-string-to-test-name-hash-table,2"
     name-hash-table,insert . cr
     "a-string-to-test-name-hash-table,2"
     name-hash-table,search . . cr

     "a-string-to-test-name-hash-table"
     string->name dup . cr
     name->string write-string cr
     "a-string-to-test-name-hash-table,2"
     string->name dup . cr
     name->string write-string cr
     end
   ; define-function
   #+end_src
** report
   #+begin_src cicada-nymph :tangle cicada.cn
   
   #+end_src
* >< title-name-table
* -----------------------------------
* >< return-stack
* >< argument-stack
* >< frame-stack
* -----------------------------------
* ===================================
