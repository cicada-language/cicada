* 題解
  * 本身是爲了討論 加載機制
    最和覺得去實現 模塊機制
* 模塊機制
  - x :: 是實現 加載機制 的時候了
       我們剛纔把 undo 機制 做爲因子從 加載機制 中提取了出去
       現在看看還能不能提取出別的 因子
  - k :: 但是 其實這種 對因子的提取 是在解決問題的過程中才被發現的
       我們還是試試看先去解決眼前的問題吧
  - x :: 好的
       已經知道需要實現的東西的效果了
       試着描述一下步驟就行了
    1. 首先是讀文件
       有一些謂詞來聞訊 元碼 的情況
       元碼有問題就報錯
    2. 元碼中會包含 need 語句
       用來 聲明依賴關係
       當所依賴的 代碼 沒有被加載時
       need 會遞歸調用 load 來加載它們
    3. 然後就是對 代碼 的 eval
       這裏實際的對代碼的加載反而是最簡單的部分
  - k :: 先忽略錯誤處理步驟的話
       那麼就是
       讀文件 返回兩個字符串 一個是 元碼 一個是 代碼
       分別傳遞給兩個語境來解釋
       元碼的語法可以和代碼完全不同
       那麼 元碼 的語境應該如何呢
       其語法應該如何設計
  - x :: 也就是說 我們有
       <string> eval
       和
       <meta-code> eval
       前者並不切換語境
       後者切換語境
  - k :: 我發現
       <meta-code> eval 應該在
       <string> eval 成功之後進行
       但是等等
       我們好像連元碼的具體作用是什麼還沒有搞清楚
       我們只知道它的必要行而已
       當加入這樣一些元數據在代碼的開頭之後
       我們應該如何利用這些元數據所包含的信息
  - x :: 首先
       需要把這些元數據中的一部分保存在 loading-stack 中
       這些元數據中的其他部分可能只起到文檔作用還有註釋作用
       其次
       這些 元碼 中能夠包含一些東西
       在 <string> eval 之前和之後 被執行
       尤其是 我們需要檢驗 <string> eval 的執行效果 以避免洪水一般地報錯信息
  - k :: 沒錯
       也就是說 文件頭部的這個 string 可能被掃描多次
       每次的用意都不同
       但是 對 <string> eval 的執行效果 的檢驗 可能是無法實現的
       因爲出錯的時候 並不能返回到 load 的函數體內部來
       所以只能放棄對錯誤的檢驗了
       而且你可以自己再反思一下 你所說的 前後 hook 有什麼不妥的地方
       我覺得這裏的某些錯誤是顯然的
  - x :: 前後 hook 可能會影響對加載過程的理解
       增加認知的負擔
       也就是說 當一個讀者需要弄明白整個代碼的機理的時候
       這些前後被執行的代碼會讓這個過程更加困難
       但是
       我們也可以試着例舉一些用性
    1. 加載前後打印出某些信息
    2. 聲明函數的入口點
       或者測試點
       也就是說
       code 部分可以全然包含對函數的定義
       和少量的函數調用
       而這個 meta-code 中可以包含大量的函數調用
       這樣 爲了弄清楚這段代碼的運行和使用方式
       我就不必跑到文件的底部 去看所有的函數都定義完了之後
       這些已經被定義的函數是如何被調用的了
  - k :: 這確實是個好的性質
       要知道我們評價好壞的標準是 "降低認知的負擔"
    1. 首先這個新的性狀不是壞的 因爲它沒有增加認知的負擔
       理解上只要想這些前面的函數調用是在所有函數都定義好了之後進行的就行了
    2. 其次這個新的性狀是好的 因爲它降低認知的負擔
       因爲我不用每每跑到文件的末尾了
  - x :: 設計了一個好的性狀之後 休息一下吧
  - k :: 好的
  -------------------------------
  - x :: 我找來了我曾經喜歡的譯者所翻譯的法國小說
       惺辣的諷刺也漠然無味
       憂鬱的敘述也漠然無味
       漫無目的的 少年的閱讀時代已經過去了嗎
       金色的少年時代已經過去了嗎
  - k :: 你還可以去讀 k 或者 k 或者 k
       但是
       好像你已經可以停止尋找了
       儘管所找尋的東西還沒被找到
  - x :: 我們還是回到對之前的性狀的討論吧
  - k :: 你說過你要讓這裏的 元碼 的語法變得可擴展
       你將如何實現這種擴展機制呢
  - x :: 我先來試着說一下目前所確定了的
       基礎的 在元碼中需要實現的效果有那些
    1. 首先是 name:
    2. 其次是 need:
    3. 最後是 do:
       這三個是核心重要的了
       如果做一些限制 來把 形如 <word>: 的 string
       認爲是 元碼中 word 的保留形態
       那麼 我就可以 既把這類詞當作開頭詞 又把這類詞當作結尾詞
       而使得元數據部分非常易讀了
       name: 必須在最前面
       do: 必須在最後
       這樣 do: 中的字符串中所包含的 形如 <word>: 的這類詞
       就不會影響語法解析了
  - k :: 沒錯
       易讀性確實是非常重要的
       那麼擴展機制呢
  - x :: 我可以把這類詞稱作 元詞 meta-word 或者 meta-function
       通過增加 meta-word
       來實現對這個區域的語義的擴展
       在 core 文件裏
       我提供基本的 我所需要的 meta-word
       如果你定義了自己的 meta-word
       那麼在使用之前必須先定義他們
       不認識的 meta-word 會被忽略
       我發現了
       我所需要實現的效果是每當我需要 load 一個 code 的時候
       我單純的 load 這個 code 就行了
       這個 code 所依賴的東西會被自動加載
       這樣 如果你自己定義了新的 meta-word
       那麼 定義這些新的 meta-word 的 code 也應該被做爲依賴加載
       這樣
       need: 就必須出現在你所自己定義的 meta-word 之前了
       重要的是
       每次在 need: 中所聲明的依賴 必須都是充分必要的
       在這裏我想我們可以停下來思考一下這裏依賴關係所形成的數學結構
       以及這種數學結構應該如何在代碼中被體現出來
  - k :: 好的
       在這之前 再休息一下吧
       是吃飯的時間了
  ------------------------------
  ------------------------------
  ------------------------------
  - x :: 過了很長時間了我還是沒有真正記錄下數學結構
       但是我想到了新的返回結構化數據的方式
       就是讓子函數直接把返回值返回到父函數的棧裏
  - k :: 我確實從來沒有見到過這種方式
       還需要更細緻的討論來覺得其是否可行
       還有這種方式的速度問題
       還有語法 等等
  - x :: 確實還有很多的東西需要思考
       所以
       我們還是先回到 加載機制 上來吧
  - k :: 好的
       首先是去畫那個數學結構
  - x :: 有限格總可以被簡化成沒有多餘的邊表示其序關係
       link 是一條線
       格 是一個網
       我需要把網拆成線
  - x :: 我發現了一個問題
       所有的函數都被定義到一個全局的命名空間中
       不同 code 中 可能會定義同名函數
       這種衝突不可調和
       其實
       我可以想一些辦法來自動處理這點
       但是這是不好的
       因爲
       你可能無意間覆蓋了別的名字而不自知
  - k :: 解法其實很顯然 不是嘛
  - x :: 沒錯
       解法很顯然
       正確的處理方式是 不允許一般的對函數的定義覆蓋已有的定義
       只有明確聲明需要重新定義的時候 才允許重新定義
       也就是 設計原則之一
       莫若以名
  - k :: 那麼這個問題就過去了
       還有呢
  - x :: 我還發現這個接口中需要做很多的異常處理
       比如 這裏必須設置一個 undo-point
       並且在遞歸調用 load 的過程中
       遇到失敗的情況的時候就要撤銷之前 load 的東西
       或者
       每每首先檢查 所聲明的 load 之網 是否存在
  - k :: 哦
       我突然發現 顯式的 (redefine) 可能是不行的
       因爲 這樣就假設了 每個 code 的作者對 整個 code 之網中的名字的全知
  - x :: 我們還是先不考慮這些
       而先考慮實現的步驟吧
    1. 設置準備函數 等待 exception
    2. 分配內存
    3. <file> read
    4. 分成兩個字符串
    5. 處理 need
       不成功則 報錯
       成功則 遞歸調用 load
       - 注意這裏其實這裏不能遞歸調用 load
         - 因爲異常處理機制 並不健全
         如果每次 load 都等待 exception
         那麼在遞歸調用 load 的過程中
         當遇到 exception 的時候
         就是局部退出了
         所以應該有兩個版本的 load
         1. 調用 exception
            而不等待 exception
            [這個函數是遞歸函數]
         2. 等待 exception
            而不調用 exception
            [這個函數本身不是遞歸函數 但是它調用上面的函數]
    6. 存元數據入 *loading-stack*
    7. eval-string
  - k :: 現在就只有 如何在 *loading-stack* 中儲存元數據 了
  - x :: undo 其實是把 link 當成是 stack
       這裏的 *loading-stack* 其實和 link 的作用類似
       說 code 所形成的是一個 code 之網
       即 格 這個數據結構
       其實 function 何嘗不是同樣
       function 之間的依賴關係
       與 code 之間的依賴關係
       極其類似
  - k :: function 之間的關係不是 樹 而是 網
       這是我之前沒有觀察到的
  - x :: 我們可以試着畫圖說明 爲什麼兩個層次的抽象結構要同時存在
       我們爲什需要他們
       首先要知道
       函數體是對算法的編碼
       而這裏所說的函數之間的依賴關係所形成的 網
       就是這種編碼 忘記函數體內 被依賴的函數的 順序
       在分析的時候
       需要注意 loop 和 recur 這兩個標記 對這個 網 的性質的影響
       其實沒有影響 是嗎
       我明白了
       這種雙層的結構完全沒有任何區別
       一個 code 就是 在 function 之網中
       視 多個點的子網 爲 一個點
  - k :: 既然有相似性
       那麼在實現過程中我們就要把這種相似性反映出來
  - x :: 沒錯
       但是先吃飯吧
  -------------------------------
  - x :: 我發現必須再給每個名字增加一個前綴
       這個前綴就是 code 的名字
       code 中的函數 在 name-hash-table 中都有這個前綴
       然後
       我必須實現一個 import 機制 這個機制專門用來定義 alias 以省略前綴
       否則 如果只有一個全局命名空間的話 是根本沒辦法解決名稱之間的衝突的
       [我可以很容易製造出極端例子使得全局名命空間之弱點暴露無遺]
  - k :: 我想到一個簡化接口的方法
       前綴可以不影響函數調用的接口
       [當然也影響函數作用的接口]
       只要規定 除非用 need 來 加載加載某個 code 否則 沒有任何方法能夠讓你使用的這個 code 中的函數
       這個限制就簡化了接口
  - x :: 這樣每次 need 所做的就是
    1. 如果還沒有加載 就加載
       如果已將加載就 不再次加載
       注意
       這裏的加載都包含前綴的
       也就是說 被加載的函數 在 name-hash-table 中的存在都是 有前綴的
    2. 給某個 code 製造 alias
  - k :: 我建議術語上的一些改變
       name:
       need:
       宜被改成
       module:
       import:
       我還建議用 |module| 這種命名規則來做爲 module 的名字
       讓它看起來像一個小方塊一樣
       這個名字當讓是在函數調用接口上用的 也就是說是儲存在 name-hash-table 中的前綴
       但是
       我發現
       這樣就徹底改變了 網 做爲數學結構的性質
       同時也改變了 使用體驗
       比如
       m3 直接用到 m2 m1 中的函數名字
       m2 直接用到 m1 中的函數名字
       在 module 機制之後
       在定義 m3 的時候 必須說
       import: m2 m1
       module: m3
       雖然 m2 已經 import 了 m1
       但是這裏必須重新 import 才能用其函數名
    1. 使用體驗
       變地 更羅嗦了 或者說 更明顯了
       即 沒有隱含地 import
       這個模塊所用到的所有名字 都可以在 import 中找到
    2. 數學結構
       import 關係沒有傳遞性
       有傳遞性 有 "路" 可走
       沒有傳遞性 就只有 "邊" 有義了
  - x :: 不錯不錯 正合我意
       兩層網同時存在的意義也可以明瞭了
       我的感覺是 module 這個層次的 網 中的邊 像是 "橋" 一樣
       把各個 module 中的函數聯起來了
       並且 各個 module 中的函數 如果想要聯合起來 就只有 利用這種 "橋"
       解法如此完美
       我想要息一下了
       之後我們可以總結一下這次的討論
       然後着手實現
  - k :: 另外 我們的這種討論形式應該如何處理
       讓這些文字留在文檔中
       或者 刪除它們
       或者 給它們另外找地方保存
       或者 直接保留在版本管理器的版本信息裏
  - x :: 我也不知道
       休息的時候考錄一下這個問題吧
  -----------------------------------
