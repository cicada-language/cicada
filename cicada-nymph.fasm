include "include/linux-header.inc"
format elf64 executable 3
entry begin_to_interpret_threaded_code
segment readable executable writeable
;; in fasm, "dup" is a reserved word
dup equ duplicate
bead_size = 8 ;; (byte)
xx equ dq
;; if you want to extend cicada in assembly
;; the following registers must NOT be used

;; =================================
define pointer$argument_stack   r15
define pointer$return_stack     r14
;; =================================

macro push_argument_stack register {
   mov [pointer$argument_stack], register
   add pointer$argument_stack, bead_size
   }
macro pop_argument_stack register {
   sub pointer$argument_stack, bead_size
   mov register, [pointer$argument_stack]
   }

macro push_return_stack register {
   mov [pointer$return_stack], register
   add pointer$return_stack, bead_size
   }
macro pop_return_stack register {
   sub pointer$return_stack, bead_size
   mov register, [pointer$return_stack]
   }
current_free_address$un_initialized_memory = address$un_initialized_memory

labeling  equ = current_free_address$un_initialized_memory
preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
exit = 0
macro next {
   pop_return_stack rbx
     mov rax, qword[rbx] 
   add rbx, bead_size
     mov rcx, qword[rbx] 
     test rcx, rcx
     jz @f
   push_return_stack rbx 
@@:  jmp qword[rax]
   }
;; initial link to point to 0 (as null)
link = 0
size$primitive_string_heap = 100 * 1024 ;; (byte)

address$primitive_string_heap:
   times size$primitive_string_heap db 0

current_free_address$primitive_string_heap = address$primitive_string_heap
macro make_primitive_string string {

virtual at 0
.start$string:
   db string
.end$string:
   dw (.end$string - .start$string)
   load .length word from (.end$string)
end virtual
store word .length at (current_free_address$primitive_string_heap)

current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

repeat .length
   virtual at 0
      db string
      load .char byte from (% - 1)
   end virtual
   store byte .char at (current_free_address$primitive_string_heap)
   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
end repeat

}
macro define_function string, jo {

define_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$function

   ;; 後面跟着作爲 function 的函數體的一串珠珠

   }
explain$function:
   add rax, bead_size
   push_return_stack rax
   next
macro define_macro string, jo {

define_macro__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$macro

   ;; 後面跟着作爲 macro (特殊的 function) 的函數體的一串珠珠

   }
explain$macro:
   add rax, bead_size
   push_return_stack rax
   next
macro define_primitive_function string, jo {

define_primitive_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx assembly_code__#jo

assembly_code__#jo:
   ;; 後面跟着作爲 primitive_function 的函數體的匯編代碼

   }
macro define_variable string, jo {

define_variable__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$variable

   ;; 後面跟着作爲 全局變元之值的 bead_size 大小的數值
   ;; 只能有一個值

   }
explain$variable:
   add rax, bead_size
   mov rbx, [rax]
   push_argument_stack rbx
   next
macro define_exception string, jo {

define_exception__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_primitive_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$exception

   ;; 後面跟着作爲 exception (特殊的 function) 的函數體的一串珠珠

   }
explain$exception:
define_primitive_function "execute-jo", execute_jo
   ;; << jo -- unknown >>
   pop_argument_stack rax
   jmp qword [rax]
define_function "jo->name", jo_to_name
   ;; << jo -- string[address, length] >>
   xx literal, bead_size, subtraction
   xx literal, bead_size, subtraction
   xx fetch
   xx dup
   xx   literal, 2, addition, swap
   xx fetch_two_bytes
   xx exit
define_function "jo->link", jo_to_link
   ;; << jo -- link >>
   xx literal, bead_size, subtraction
   xx exit
define_function "null-jo?", null_jo?
   ;; << jo -- bool >>
   xx jo_to_link
   xx fetch
   xx zero?
   xx exit
define_function "jo->pre-jo", jo_to_pre_jo
   ;; << jo -- pre-jo >>
   xx jo_to_link
   xx fetch
   xx literal, bead_size, addition
   xx exit
define_function "jo->type", jo_to_type
   ;; << jo -- type >>
   xx dup

   xx dup, fetch
   xx swap, subtraction, literal, 8, equal?, false?branch, 4
   xx   drop, zero
   xx   exit

   xx fetch
   xx exit
define_function "primitive-function-jo?", primitive_function_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx zero?
   xx exit
define_function "function-jo?", function_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$function
   xx equal?
   xx exit
define_function "macro-jo?", macro_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$macro
   xx equal?
   xx exit
define_function "variable-jo?", variable_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$variable
   xx equal?
   xx exit
begin_to_interpret_threaded_code:

   cld ;; set DF = 0, then rsi and rdi are incremented

   mov pointer$argument_stack,  address$argument_stack
   mov pointer$return_stack,    address$return_stack

   mov rax, first_jojo
   push_return_stack rax
   next


first_jojo:
   xx basic_REPL

   ;; xx little_test
define_primitive_function "bye", exit_with_TOS
   pop_argument_stack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
define_variable "", V__little_test_number
   xx 3


define_function "little_test", little_test

   ;;;; variable
   ;; xx V__little_test_number
   ;; xx exit_with_TOS
   ;;;; 3

   ;;;; literal
   ;; xx literal, 4
   ;; xx exit_with_TOS
   ;;;; 4

   ;;;; address
   ;; xx address, V__little_test_number, fetch, add2
   ;; xx address, V__little_test_number, save
   ;; xx V__little_test_number
   ;; xx exit_with_TOS
   ;;;; 5

   ;;;; write_byte
   ;; xx literal, 64, write_byte
   ;; xx literal, 10, write_byte
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; @

   ;;;; read_byte
   ;; xx read_byte, write_byte
   ;; xx exit_with_TOS
   ;;;;

   ;;;; branch
   ;; xx read_byte, write_byte
   ;; xx branch, -3
   ;;;; read a string that ended by <return>
   ;;;; write the readed string
   ;;;; or we can say
   ;;;; read line and write line
   ;;;; or we can say
   ;;;; echo line

   ;;;; false?branch
   ;; xx V__false, false?branch, 9
   ;; xx   literal, 64, write_byte
   ;; xx   literal, 10, write_byte
   ;; xx   zero
   ;; xx   exit_with_TOS
   ;; xx V__true, false?branch, 9
   ;; xx   literal, 65, write_byte
   ;; xx   literal, 10, write_byte
   ;; xx   zero
   ;; xx   exit_with_TOS
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; A

   ;;;; read_word & write_string
   ;; xx read_word, write_string
   ;; xx literal, 10, write_byte
   ;; xx read_word_for_REPL, write_string
   ;; xx literal, 10, write_byte
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; read line
   ;;;; write first two words of the line

   ;;;; string->integer
   ;; xx read_word, string_to_integer
   ;; xx exit_with_TOS
   ;;;;

   ;;;; use jo_to_name to test the macro make_primitive_string
   ;; xx literal, jo_to_name, jo_to_name, write_string
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;;

   ;;;; basic-REPL (without the ability to define function)
   ;;;; after this test
   ;;;; we will use basic-REPL to do further tests
   xx basic_REPL
   ;;;; 1 2 add .
preserve 64 * bead_size
address$argument_stack labeling
   preserve 1024 * 1024 * bead_size
define_primitive_function "drop", drop
   ;; << a -- >>
   pop_argument_stack rax
   next

define_primitive_function "drop2", drop2
   ;; << a b -- >>
   pop_argument_stack rax
   pop_argument_stack rax
   next
define_primitive_function "dup", dup
   ;; << a -- a a >>
   mov  rax, [pointer$argument_stack - (1 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "dup2", dup2
   ;; << a b -- a b a b >>
   mov  rbx, [pointer$argument_stack - (1 * bead_size)]
   mov  rax, [pointer$argument_stack - (2 * bead_size)]
   push_argument_stack rax
   push_argument_stack rbx
   next
define_primitive_function "over", over
   ;; << a b -- a b | a >>
   mov  rax, [pointer$argument_stack - (2 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xx", xoverxx
   ;; << a | b c -- a | b c | a >>
   mov  rax, [pointer$argument_stack - (3 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|x", xxoverx
   ;; << a b | c -- a b | c | a b >>
   mov  rax, [pointer$argument_stack - (3 * bead_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (3 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xx", xxoverxx
   ;; << a b | c d -- a b | c d | a b >>
   mov  rax, [pointer$argument_stack - (4 * bead_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (4 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xxx", xoverxxx
   ;; << a | b c d -- a | b c d | a >>
   mov  rax, [pointer$argument_stack - (4 * bead_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xxxx", xxoverxxxx
   ;; << a b | c d e f -- a b | c d e f | a b >>
   mov  rax, [pointer$argument_stack - (6 * bead_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (6 * bead_size)]
   push_argument_stack rax
   next
define_primitive_function "tuck", tuck
   ;; << a b -- b | a b >>
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "x|tuck|xx", xtuckxx
   ;; << a | b c -- b c | a | b c >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|tuck|x", xxtuckx
   ;; << a b | c -- c | a b | c >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|tuck|xx", xxtuckxx
   ;; << a b | c d -- c d | a b | c d >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next

define_primitive_function "xxx|tuck|x", xxxtuckx
   ;; << a b c | d -- d | a b c | d >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next
define_primitive_function "swap", swap
   ;; << a b -- b a >>
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rax
   next

define_primitive_function "x|swap|xx", xswapxx
   ;; << a | b c -- b c | a >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rax
   next

define_primitive_function "xx|swap|x", xxswapx
   ;; << a b | c -- c | a b >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "x|swap|xxx", xswapxxx
   ;; << a | b c d -- b c d | a >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   next

define_primitive_function "xxx|swap|x", xxxswapx
   ;; << a b c | d -- d | a b c >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|swap|xx", xxswapxx
   ;; << a b | c d -- c d | a b >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   next


define_primitive_function "x|swap|xxxx", xswapxxxx
   ;; << a | b c d e -- b c d e | a >>
   pop_argument_stack r8 ;; e
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack r8 ;; e
   push_argument_stack rax
   next

define_primitive_function "xxxx|swap|x", xxxxswapx
   ;; << a b c d | e --  e | a b c d >>
   pop_argument_stack r8 ;; e
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack r8 ;; e
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next


define_primitive_function "xx|swap|xxxx", xxswapxxxx
   ;; << a b | c d e f -- c d e f | a b >>
   pop_argument_stack r9 ;; f
   pop_argument_stack r8 ;; e
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack r8 ;; e
   push_argument_stack r9 ;; f
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "xxxx|swap|xx", xxxxswapxx
   ;; << a b c d | e f --  e f | a b c d >>
   pop_argument_stack r9 ;; f
   pop_argument_stack r8 ;; e
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack r8 ;; e
   push_argument_stack r9 ;; f
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next
preserve 64 * bead_size
address$return_stack labeling
   preserve 1024 * 1024 * bead_size
define_variable "*literal*", V__literal
   xx literal

define_primitive_function "", literal
   ;; << -- fixnum >>
   ;; 如果在一串珠珠末尾
   ;;     就抽出這串珠珠
   pop_return_stack rbx
   mov rax, [rbx]
   push_argument_stack rax
   add rbx, bead_size
   mov rax, [rbx]
   test rax, rax
   jz .meet_end
   push_return_stack rbx
.meet_end:
   ;; 不放回 就算抽出
   next
define_variable "*address*", V__address
   xx address

define_primitive_function "", address
   ;; << -- address >>
   ;; 如果在一串珠珠末尾
   ;;     就抽出這串珠珠
   ;; 當調用到這個 primitive function 的時候
   ;; 就已經是運行時了
   ;; 所以這裏沒有對 address 之後的珠子的類型檢查
   ;; 類型檢查可以在編譯器中做
   pop_return_stack rbx
   mov rax, [rbx]
   add rax, bead_size
   push_argument_stack rax
   add rbx, bead_size
   mov rax, [rbx]
   test rax, rax
   jz .meet_end
   push_return_stack rbx
.meet_end:
   ;; 不放回 就算抽出
   next
define_primitive_function "", branch
   pop_return_stack rbx
   mov rax, [rbx]
   imul rax, bead_size
   add rbx, rax
   ;; the following handles branching to "exit"
   mov rax, [rbx]
   test rax, rax
   jz .meet_end
   push_return_stack rbx
.meet_end:
   next
define_primitive_function "", false?branch
   ;; << true of false -- >>
   pop_argument_stack rax
   test rax, rax
   jnz help__false?branch__not_to_branch

   pop_return_stack rbx
   mov rax, [rbx]
   imul rax, bead_size
   add rbx, rax
   ;; the following handles branching to "exit"
   mov rax, [rbx]
   test rax, rax
   jz .meet_end
   push_return_stack rbx
.meet_end:
   next

help__false?branch__not_to_branch:
   pop_return_stack rbx
   add rbx, bead_size
   mov rax, [rbx]
   test rax, rax
   jz .meet_end
   push_return_stack rbx
.meet_end:
   next
define_primitive_function "", prepare_for
   ;; << -- >>

   next
define_primitive_function "", exception_header
   ;; << -- >>

   next
define_primitive_function "false", false
   ;; << -- false >>
   xor rax, rax
   push_argument_stack rax
   next

define_primitive_function "true", true
   ;; << -- true >>
   xor rax, rax
   inc rax
   push_argument_stack rax
   next
define_function "false?", false?
   ;; << bool -- bool >>
   xx false, equal?
   xx exit

define_function "true?", true?
   ;; << bool -- bool >>
   xx true, equal?
   xx exit
define_primitive_function "bitwise-and", bitwise_and
   ;; << a, b -- a and b >>
   pop_argument_stack rbx
   and [pointer$argument_stack - (1 * bead_size)], rbx
   next

define_primitive_function "bitwise-or", bitwise_or
   ;; << a, b -- a or b >>
   pop_argument_stack rbx
   or  [pointer$argument_stack - (1 * bead_size)], rbx
   next

define_primitive_function "bitwise-xor", bitwise_xor
   ;; << a, b -- a xor b >>
   pop_argument_stack rbx
   xor [pointer$argument_stack - (1 * bead_size)], rbx
   next

define_primitive_function "bitwise-invert", bitwise_invert
   ;; << a -- invert a >>
   not qword [pointer$argument_stack - (1 * bead_size)]
   next
define_primitive_function "zero", zero
   ;; << -- 0 >>
   xor rax, rax
   push_argument_stack rax
   next

define_primitive_function "one", one
   ;; << -- 1 >>
   xor rax, rax
   inc rax
   push_argument_stack rax
   next
define_function "zero?", zero?
   ;; << bool -- bool >>
   xx zero, equal?
   xx exit

define_function "one?", one?
   ;; << bool -- bool >>
   xx one, equal?
   xx exit
define_primitive_function "add1", add1
   ;; << n -- n+1 >>
   inc qword [pointer$argument_stack - (1 * bead_size)]
   next

define_primitive_function "add2", add2
   ;; << n -- n+2 >>
   add qword [pointer$argument_stack - (1 * bead_size)], 2
   next

define_primitive_function "add3", add3
   ;; << n -- n+3 >>
   add qword [pointer$argument_stack - (1 * bead_size)], 3
   next

define_primitive_function "add4", add4
   ;; << n -- n+4 >>
   add qword [pointer$argument_stack - (1 * bead_size)], 4
   next

define_primitive_function "add8", add8
   ;; << n -- n+8 >>
   add qword [pointer$argument_stack - (1 * bead_size)], 8
   next


define_primitive_function "sub1", sub1
   ;; << n -- n-1 >>
   dec qword [pointer$argument_stack - (1 * bead_size)]
   next

define_primitive_function "sub2", sub2
   ;; << n -- n-2 >>
   sub qword [pointer$argument_stack - (1 * bead_size)], 2
   next

define_primitive_function "sub3", sub3
   ;; << n -- n-3 >>
   sub qword [pointer$argument_stack - (1 * bead_size)], 3
   next

define_primitive_function "sub4", sub4
   ;; << n -- n-4 >>
   sub qword [pointer$argument_stack - (1 * bead_size)], 4
   next

define_primitive_function "sub8", sub8
   ;; << n -- n-8 >>
   sub qword [pointer$argument_stack - (1 * bead_size)], 8
   next


define_primitive_function "add", addition
   ;; << a b -- a+b >>
   pop_argument_stack rax
   add qword [pointer$argument_stack - (1 * bead_size)], rax
   next

define_primitive_function "sub", subtraction
   ;; << a b -- a-b >>
   pop_argument_stack rax
   sub qword [pointer$argument_stack - (1 * bead_size)], rax
   next

define_primitive_function "mul", multiple
   ;; << a b -- a*b >>
   pop_argument_stack  rbx ;; 2ed arg
   pop_argument_stack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; when there are two registers as arg
   ;; imul will save the result into the first register
   push_argument_stack rbx
   next

define_primitive_function "moddiv", moddiv
   ;; << a, b -- a mod b, quotient >>
   ;; << dividend, divisor -- remainder, quotient >>
   ;; the arg of idiv is divisor
   ;; the lower half of dividend is taken from rax
   ;; the upper half of dividend is taken from rdx
   xor  rdx, rdx   ;; high-part of dividend is not used
   pop_argument_stack  rbx ;; 2ed arg
   pop_argument_stack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   push_argument_stack rdx ;; remainder
   push_argument_stack rax ;; quotient
   next


define_function "divmod", divmod
   ;; << a, b -- quotient, a mod b >>
   xx moddiv, swap
   xx exit

define_function "div", division
   ;; << a, b -- quotient >>
   xx divmod, drop
   xx exit

define_function "mod", modulo
   ;; << a, b -- a mod b >>
   xx moddiv, drop
   xx exit

define_function "negate", negate
   ;; << n --  -n >>
   xx zero
   xx swap, subtraction
   xx exit


define_function "power", power
   ;; n must be nature number for now
   ;; << a, n -- a^n >>
   xx literal, 1, swap ;; leave product
   xx help__power
   xx exit

define_function "help,power", help__power
   ;; << a, product, n -- a^n >>
   xx dup, zero?, false?branch, 5
   xx   drop, swap, drop
   xx   exit
   xx sub1
   xx swap
   xx   xoverxx, multiple
   xx swap
   xx help__power
   xx exit
define_primitive_function "equal?", equal?
   ;; << a, b -- a, b, true of false >>
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "less-than?", less_than?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "greater-than?", greater_than?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   push_argument_stack  rax
   next

define_primitive_function "less-or-equal?", less_or_equal?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "greater-or-equal?", greater_or_equal?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   push_argument_stack rax
   next
define_function "negative?", negative?
   ;; << integer -- bool >>
   xx zero, less_than?
   xx exit

define_function "positive?", positive?
   ;; << integer -- bool >>
   xx negative?, false?
   xx exit
;; "save" and "fetch" default to a bead_size
;; the rule of "fetch2" and so on are:
;;   in memory:
;;     ||  1 : value-1  ||
;;     ||  1 : value-2  ||
;;     ||  1 : value-3  ||
;;     ...
;;   on stack:
;;     << value-1, value-2, value-3, ... >>
;; of course we have:
;;   fetch2 : memory=copy=>stack
;;   save2  : stack->memory

define_primitive_function "save", save
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov qword[rbx], rax
   next

define_primitive_function "save-byte", save_byte
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov byte[rbx], al
   next

define_primitive_function "save-two-bytes", save_two_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov word [rbx], ax
   next

define_primitive_function "save-four-bytes", save_four_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov dword [rbx], eax
   next

define_primitive_function "n-save", n_save
   ;; << value-n, ..., value-1, address, n -- >>
   pop_argument_stack rcx
   pop_argument_stack rdx
   mov rax, bead_size
   imul rax, rcx
   add rdx, rax
   ;; for address is based on 0
   ;; but n is based on 1
   sub rdx, bead_size
.loop:
   pop_argument_stack rax
   mov qword [rdx], rax
   sub rdx, bead_size
   loop .loop
   next

define_function "save2", save2
   ;; << value-2, value-1, address -- >>
   xx literal, 2
   xx n_save
   xx exit

define_primitive_function "n-save-byte", n_save_byte
   ;; << value-n, ..., value-1, address, n -- >>
   pop_argument_stack rcx
   pop_argument_stack rdx
   add rdx, rcx
   dec rdx
.loop:
   pop_argument_stack rax
   mov byte [rdx], al
   dec rdx
   loop .loop
   next

define_primitive_function "fetch", fetch
   ;; ( address -- value )
   pop_argument_stack  rbx
   mov rax, qword[rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-byte", fetch_byte
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov al, byte[rbx]
   push_argument_stack rax
   next
define_primitive_function "fetch-two-bytes", fetch_two_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov ax, word[rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-four-bytes", fetch_four_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov eax, dword[rbx]
   push_argument_stack rax
   next

;;   in memory:
;;     ||  1 : value-1  ||
;;     ...
;;     ||  1 : value-n  ||
define_primitive_function "n-fetch", n_fetch
   ;; << address, n -- value-1, ..., value-n >>
   pop_argument_stack  rcx
   pop_argument_stack  rdx
.loop:
   mov rax, qword[rdx]
   push_argument_stack rax
   add rdx, bead_size
   loop .loop
   next

define_primitive_function "n-fetch-byte", n_fetch_byte
   ;; << address, n -- byte-1, ..., byte-n >>
   pop_argument_stack  rcx
   pop_argument_stack  rdx
   xor rax, rax
.loop:
   mov al, byte [rdx]
   push_argument_stack rax
   inc rdx
   loop .loop
   next

define_function "fetch2", fetch2
   ;; << address -- value-1, value-2 >>
   xx literal, 2
   xx n_fetch
   xx exit

define_primitive_function "add-save", add_save
   ;; ( number to add, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   add qword[rbx], rax
   next

define_primitive_function "sub-save", sub_save
   ;; ( number to add, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   sub qword[rbx], rax
   next
max_input_length = 1024 * 1024

buffer$read_byte labeling
   preserve max_input_length
buffer$write_byte:
   db 0

define_primitive_function "write-byte", write_byte
   ;; << byte -- >>
   ;; just calls the Linux write system call
   pop_argument_stack rax
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [buffer$write_byte], al
   mov sys_3_rdx, 1                 ;; max length to be write
   mov sys_2_rsi, buffer$write_byte ;; address
   mov sys_1_rdi, 1                 ;; stdout
   mov sys_n_rax, syscall_write
   syscall
   next
flag$unreaded_ket_char:
   xx 0

char$unreaded_ket_char:
   xx 0

define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
   ;; << -- bool >>
   xx literal, flag$unreaded_ket_char, fetch
   xx exit

define_function "unread-ket-char", unread_ket_char
   ;; << char -- >>
   xx literal, char$unreaded_ket_char, save
   xx true, literal, flag$unreaded_ket_char, save
   xx exit


;; help__read_byte is the old do function without unread ket-char
define_function "read-byte", read_byte
   ;; << -- byte >>
   xx have_unreaded_ket_char?, false?branch, 9
   xx   literal, char$unreaded_ket_char, fetch_byte
   xx   zero, literal, flag$unreaded_ket_char, save
   xx   exit
   xx help__read_byte
   xx exit



cursor$read_byte:
   xx 0

border$read_byte:
   xx 0

define_primitive_function "help,read-byte", help__read_byte
   ;; << -- byte >>
   call help__help__read_byte
   push_argument_stack rax
   next


help__help__read_byte:
   mov rbx, [cursor$read_byte]
   cmp rbx, [border$read_byte]
   ;; [cursor$read_byte] <  [border$read_byte]
   jl .we_still_have_buffered_byte
   ;; [cursor$read_byte] >= [border$read_byte]
   jmp .do_a_new_buffer


.do_a_new_buffer:
   mov rbx, buffer$read_byte
   mov [cursor$read_byte], rbx
   mov [border$read_byte], rbx

   mov sys_3_rdx, max_input_length ;; max length to be read
   mov sys_2_rsi, buffer$read_byte ;; buffer address
   xor sys_1_rdi, sys_1_rdi        ;; stdin
   mov sys_n_rax, syscall_read
   syscall
   ;; the return value of syscall read
   ;; is a count of the number of bytes transferred
   test rax, rax
   jz .error ;; rax = 0
   js .error ;; rax < 0

   ;; update [border$read_byte]
   add [border$read_byte], rax
   jmp help__help__read_byte


.we_still_have_buffered_byte:
   ;; for the following will just uses the al part of rax
   ;; it is necessary to clear rax
   xor rax, rax
   mov al, byte [rbx]
   inc rbx
   mov [cursor$read_byte], rbx
   ret


.error:
   ;; exit with exit code = 0
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
max_word_length = 1024

buffer$read_word labeling
   preserve max_word_length

buffer$read_word_for_REPL labeling
   preserve max_word_length
define_function "read-word-begin-char", read_word_begin_char
   ;; << -- non-blank-char >>
   xx read_byte
   xx dup, literal, 32 ;; ascii.space
   xx greater_than?, false?branch, 2
   xx   exit
   xx drop
   xx read_word_begin_char
   xx exit
define_function "read-word->buffer", read_word_to_buffer
   ;; << buffer -- word[address, length] >>
   xx read_word_begin_char
   ;; no metter what the begin char is
   ;; save it into buffer
   xx dup2, swap, save_byte
   xx swap, add1, swap
   xx one, swap ;; leave length counter
   ;; << cursor[address in buffer], counter, begin char >>
   xx dup, bar_ket_char?, false?branch, 4
   xx   drop
   xx   help__read_word_to_buffer__bar_ket
   xx   exit
   ;; maybe add other type of chars
   xx drop
   xx help__read_word_to_buffer__regular
   xx exit

define_function "help,read-word->buffer,bar-ket", help__read_word_to_buffer__bar_ket
   ;; << cursor[address in buffer], counter -- word[address, length] >>
   xx tuck, subtraction, swap
   xx exit

define_function "help,read-word->buffer,regular", help__read_word_to_buffer__regular
   ;; << cursor[address in buffer], counter -- word[address, length] >>
   xx read_byte
   xx dup, bar_ket_char?, false?branch, 6
   xx   unread_ket_char
   xx   tuck, subtraction, swap
   xx   exit
   xx dup, space_char?, false?branch, 6
   xx   drop
   xx   tuck, subtraction, swap
   xx   exit
   xx xoverxx, save_byte
   xx add1
   xx swap, add1, swap
   xx help__read_word_to_buffer__regular
   xx exit
define_function "read-word", read_word
   ;; << -- word[address of buffer$read_word, length] >>
   xx literal, buffer$read_word, read_word_to_buffer
   xx exit
define_function "read-word-for-REPL", read_word_for_REPL
   ;; << -- word[address of buffer$read_word_for_REPL, length] >>
   xx literal, buffer$read_word_for_REPL, read_word_to_buffer
   xx exit
define_function "write-string", write_string
   ;; << string[address, length] -- >>
   xx dup, zero?, false?branch, 3
   xx   drop2
   xx   exit
   xx sub1, swap
   xx dup, fetch_byte, write_byte
   xx add1, swap
   xx write_string
   xx exit
define_function ".s", pretty_write_string
   ;; << integer -- >>
   xx write_string
   xx literal, 10, write_byte
   xx exit
;; 2 ^ 64 = 18446744073709551616
;; which is of length 20
;; so
;; I use 32 to align to 16

buffer$write_nature_number labeling
   preserve 32

counter$write_nature_number:
   xx 0


define_function "write-nature-number", write_nature_number
   ;; << nature-number -- >>
   xx zero
   xx literal, counter$write_nature_number, save

   xx help__write_nature_number

   xx literal, buffer$write_nature_number
   xx literal, counter$write_nature_number, fetch
   xx string_reverse!
   xx write_string
   xx exit


define_function "help,write-nature-number", help__write_nature_number
   ;; << rest-number -- >>
   xx literal, 10, divmod

   xx decimal_digital_to_char
   xx literal, buffer$write_nature_number
   xx literal, counter$write_nature_number, fetch
   xx addition
   xx save_byte

   xx one
   xx literal, counter$write_nature_number
   xx add_save

   xx dup, zero?, false?branch, 3
   xx   drop
   xx   exit
   xx help__write_nature_number
   xx exit
define_function "write-integer", write_integer
   ;; << integer -- >>
   xx dup, positive?, false?branch, 3
   xx   write_nature_number
   xx   exit
   xx literal, '-', write_byte
   xx negate, write_nature_number
   xx exit
define_function ".", pretty_write_integer
   ;; << integer -- >>
   xx write_integer
   xx literal, 32, write_byte
   xx exit
define_function "space-char?", space_char?
   ;; << char -- bool >>
   xx literal, 32, less_or_equal?
   xx exit
define_function "bar-ket-char?", bar_ket_char?
   ;; << char -- bool >>
   xx dup, literal, '(', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx dup, literal, ')', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx dup, literal, '[', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx dup, literal, ']', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx dup, literal, '{', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx dup, literal, '}', equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx drop, false
   xx exit
define_function "digital-char?", decimal_digital_char?
   ;; << char -- bool >>
   xx dup, literal, '0', less_than?, false?branch, 4
   xx   drop, false
   xx   exit
   xx dup, literal, '9', less_or_equal?, false?branch, 4
   xx   drop, true
   xx   exit
   xx drop, false
   xx exit
define_function "char->decimal-digital", char_to_decimal_digital
   ;; << char -- decimal-digital >>
   xx literal, '0', subtraction
   xx exit

define_function "decimal-digital->char", decimal_digital_to_char
   ;; << decimal-digital -- char >>
   xx literal, '0', addition
   xx exit
;; return false when length == 0
define_primitive_function "compare-buffer", compare_buffer
   ;; << address, address, length -- bool >>
   pop_argument_stack rcx
   pop_argument_stack rdi
   pop_argument_stack rsi
   repe cmpsb
   sete al
   movzx rax, al
   push_argument_stack rax
   next
define_function "string-equal?", string_equal?
   ;; << string[address, length], string[address, length] -- bool >>
   xx xoverxx, equal?, false?branch, 4
   xx   swap, compare_buffer
   xx   exit
   xx drop, drop2
   xx false
   xx exit
define_function "string-head,char", string_head__char
   ;; << string[address, length] -- char >>
   xx drop, fetch_byte
   xx exit

define_function "string-tail,char", string_tail__char
   ;; << string[address, length] -- [address + 1, length + 1] >>
   xx sub1, swap
   xx add1, swap
   xx exit
define_primitive_function "string->buffer!", string_to_buffer!
   ;; ( string[address, length], buffer[address] -- )
   pop_argument_stack rdi ;; destination
   pop_argument_stack rcx ;; counter
   pop_argument_stack rsi ;; source
   rep movsb
   next
buffer$string_reverse! labeling
   preserve 1024


define_primitive_function "string-reverse!", string_reverse!
   ;; << string[address, length] -- string[address, length] >>
   mov rdi, buffer$string_reverse!
   mov rcx, [pointer$argument_stack - (1 * bead_size)]
   mov rsi, [pointer$argument_stack - (2 * bead_size)]
   rep movsb

   mov rcx, [pointer$argument_stack - (1 * bead_size)]
   dec rdi ;; cursor back into string in buffer$string_reverse!
   mov rsi, [pointer$argument_stack - (2 * bead_size)]
.loop:
   mov al, byte [rdi]
   mov byte [rsi], al
   dec rdi
   inc rsi
   loop .loop

   next
define_function "digital-string?", digital_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, true
   xx   exit
   xx over, fetch_byte, decimal_digital_char?, false?branch, 4
   xx   string_tail__char
   xx   digital_string?
   xx   exit
   xx drop2, false
   xx exit
define_function "char-string?", char_string?
   ;; << string[address, length], char -- bool >>
   xx xxswapx
   xx dup, one?, false?, false?branch, 5
   xx   drop2, drop
   xx   false
   xx   exit
   xx string_head__char, equal?, false?branch, 3
   xx   true
   xx   exit
   xx false
   xx exit
define_function "zero-string?", zero_string?
   ;; << string[address, length] -- bool >>
   xx dup2, literal, '0', char_string?, false?branch, 4
   xx   drop2, true
   xx   exit
   xx dup2
   xx string_head__char, literal, '-', equal?, false?, false?branch, 4
   xx   drop2, false
   xx   exit
   xx string_tail__char, literal, '0', char_string?
   xx exit
define_function "integer-string?", integer_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, false
   xx   exit
   xx dup2, literal, '-', char_string?, false?branch, 4
   xx   drop2, false
   xx   exit
   xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
   xx   string_tail__char, digital_string?
   xx   exit
   xx digital_string?
   xx exit
define_function "string->integer", string_to_integer
   ;; << string[address, length] -- integer >>
   xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
   xx   digital_string_to_integer
   xx   exit
   xx string_tail__char
   xx digital_string_to_integer, negate
   xx exit


sum$digital_string_to_integer:
   xx 0

counter$digital_string_to_integer:
   xx 0

define_function "digital-string->integer", digital_string_to_integer
   ;; << string[address, length] -- integer >>
   xx zero, literal, sum$digital_string_to_integer, save
   xx zero, literal, counter$digital_string_to_integer, save

   xx dup2, string_reverse!
   xx   help__digital_string_to_integer
   xx string_reverse!, drop2

   xx literal, sum$digital_string_to_integer, fetch
   xx exit

define_function "help,digital-string->integer", help__digital_string_to_integer
   ;; << reversed-string[address, length] -- >>
   xx dup, zero?, false?branch, 3
   xx   drop2
   xx   exit

   xx dup2, string_head__char, char_to_decimal_digital
   xx   literal, 10
   xx   literal, counter$digital_string_to_integer, fetch
   xx     one
   xx     literal, counter$digital_string_to_integer
   xx     add_save
   xx   power
   xx multiple

   xx literal, sum$digital_string_to_integer
   xx add_save

   xx string_tail__char
   xx help__digital_string_to_integer
   xx exit
define_variable "*first-jo-in-dictionary*", V__first_jo_in_dictionary
   xx last_jo_in_assembly

define_function "find", find
   ;; << word[address, length] -- jo, found or not >>
   xx V__first_jo_in_dictionary
   xx help__find
   xx exit

define_function "help,find", help__find
   ;; << word[address, length], jo -- jo, found or not >>
   xx dup, null_jo?, false?branch, 6
   xx   drop, drop2
   xx   false, false
   xx   exit
   xx xxtuckx
   xx jo_to_name, xxoverxx
   xx string_equal?, false?branch, 4
   xx   drop2, true
   xx   exit
   xx xswapxx, jo_to_pre_jo
   xx help__find
   xx exit
define_function "execute-word", execute_word
   ;; << word[address, length] -- unknown >>
   xx dup2, integer_string?, false?branch, 3
   xx   string_to_integer
   xx   exit
   ;; maybe more

   xx dup2 ;; for to report undefined word

   xx find, false?branch, 5
   xx   xxswapx, drop2
   xx   execute_jo
   xx   exit
   xx drop  ;; jo

   xx write_undefined_word_report
   xx write_string
   xx literal, 10, write_byte
   xx exit

define_function "write-undefined-word-report", write_undefined_word_report
   ;; << -- >>
   xx literal, string$undefined_word_report
   xx literal, length$undefined_word_report
   xx write_string
   xx exit

string$undefined_word_report:
   db "   UNDEFINED-WORD : "
.end:
length$undefined_word_report = (.end - string$undefined_word_report)
define_function "space-string?", space_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, true
   xx   exit
   xx over, fetch_byte, space_char?, false?branch, 4
   xx   string_tail__char
   xx   digital_string?
   xx   exit
   xx drop2, false
   xx exit
define_function "left-trim,space-char", left_trim__space_char
   ;; << string[address, length] -- string[address, length] >>
   xx dup, zero?, false?branch, 2
   xx   exit
   xx dup2, string_head__char, space_char?, false?, false?branch, 2
   xx   exit
   xx string_tail__char
   xx left_trim__space_char
   xx exit

define_function "left-trim,non-space-char", left_trim__non_space_char
   ;; << string[address, length] -- string[address, length] >>
   xx dup, zero?, false?branch, 2
   xx   exit
   xx dup2, string_head__char, space_char?, false?branch, 2
   xx   exit
   xx string_tail__char
   xx left_trim__non_space_char
   xx exit
define_function "string-head,word", string_head__word
   ;; << string[address, length] -- word[address, length] >>
   xx left_trim__space_char
   xx dup2, left_trim__non_space_char
   xx swap, drop
   xx subtraction
   xx exit

define_function "string-tail,word", string_tail__word
   ;; << string[address, length] -- string[address, length] >>
   xx left_trim__space_char
   xx left_trim__non_space_char
   xx exit
string$exit_word:
   db "exit"
.end:
length$exit_word = (.end - string$exit_word)

define_function "exit-word?", exit_word?
   ;; << word[address, length] -- bool >>
   xx literal, string$exit_word
   xx literal, length$exit_word
   xx string_equal?
   xx exit
define_function "basic-REPL", basic_REPL
   ;; << unknown -- unknown >>
   xx read_word_for_REPL
   xx execute_word
   xx basic_REPL
   xx exit
define_function "colon-string?", colon_string?
   ;; << string[address, length] -- bool >>
   xx literal, ':', char_string?
   xx exit

define_function "semicolon-string?", semicolon_string?
   ;; << string[address, length] -- bool >>
   xx literal, ';', char_string?
   xx exit
string$comment_begin:
   db "<<"

define_function "comment-begin-string?", comment_begin_string?
   ;; (* string[address, length] -- bool *)
   xx literal, string$comment_begin
   xx literal, 2
   xx string_equal?
   xx exit


string$comment_end:
   db ">>"

define_function "comment-end-string?", comment_end_string?
   ;; (* -- *)
   xx literal, string$comment_end
   xx literal, 2
   xx string_equal?
   xx exit
buffer$colon labeling
   preserve 1024 * 1024

cursor$colon:
   xx 0

define_function ":", colon
   ;; << -- string[address of buffer$colon, length] >>
   xx literal, buffer$colon
   xx literal, cursor$colon, save

   xx help__loop__colon

   xx literal, buffer$colon
   xx literal, cursor$colon, fetch
   xx literal, buffer$colon
   xx subtraction
   xx exit


define_function "help,loop,colon", help__loop__colon
   ;; << -- >>
   xx read_word
   xx dup2, semicolon_string?, false?branch, 3
   xx   drop2
   xx   exit
   xx dup2, comment_begin_string?, false?branch, 5
   xx   drop2
   xx   ignore_comment
   xx   help__loop__colon
   xx   exit
   xx help__add__colon
   xx help__loop__colon
   xx exit


;; when add a word into buffer
;; tail it with a space
define_function "help,add,colon", help__add__colon
   ;; << word[address, length] -- >>
   ;; <* word[address, length] -- *>
   ;; << word[address, length] -- >>
   xx tuck
   xx   literal, cursor$colon, fetch
   xx   string_to_buffer!
   xx literal, cursor$colon, add_save
   xx one
   xx   literal, 32
   xx   literal, cursor$colon, fetch
   xx   save_byte
   xx literal, cursor$colon, add_save
   xx exit
define_function "<<", ignore_comment
   ;; << -- >>
   xx read_word
   xx dup2, comment_begin_string?, false?branch, 5
   xx   drop2
   xx     ignore_comment ;; for the new nested-comment
   xx   ignore_comment ;; for the rest-comment
   xx   exit
   xx dup2, comment_end_string?, false?branch, 3
   xx   drop2
   xx   exit
   xx drop2
   xx ignore_comment
   xx exit
address$jo_heap labeling
   preserve 3 * 1024 * 1024 * bead_size

define_variable "*current-free-address,jo-heap*", V__current_free_address__jo_heap
   xx address$jo_heap
define_function "make-jojo", make_jojo
   ;; << string[address, length] -- >>
   xx dup2, space_string?, false?branch, 3
   xx   drop2
   xx   exit
   xx dup2
   xx string_tail__word
   xx xxswapxx
   xx string_head__word
   ;; << tail[address, length], head[address, length] >>
   xx make_jojo__dispatch_word
   xx make_jojo
   xx exit

define_function "make-jojo,dispatch-word", make_jojo__dispatch_word
   ;; << string[address, length], word[address, length] --
   ;;    string[address, length] >>
   xx dup2, exit_word?, false?branch, 5
   xx   drop2
   xx   zero
   xx     save_into__jo_heap
   xx   exit
   xx dup2, zero_string?, false?branch, 6
   xx   drop2
   xx   literal, zero
   xx     save_into__jo_heap
   xx   exit
   xx dup2, integer_string?, false?branch, 7
   xx   literal, literal
   xx     save_into__jo_heap
   xx   string_to_integer
   xx     save_into__jo_heap
   xx   exit
   xx dup2
   xx find, false?, false?branch, 8
   xx   drop ;; jo
   xx   write_undefined_word_report__for_funtion_body
   xx   write_string
   xx   literal, 10, write_byte
   ;;   ><><><
   ;;   here we should not compile the function into memory at all
   ;;   note that
   ;;     proper exception handling
   ;;     can be implemented by doing side-effect on return-stack
   xx   exit
   xx xxswapx, drop2 ;; word
   xx make_jojo__dispatch_jo
   xx exit

define_function "make-jojo,dispatch-jo", make_jojo__dispatch_jo
   ;; << string[address, length], jo --
   ;;    string[address, length] >>
   xx dup, function_jo?, false?branch, 3
   xx   save_into__jo_heap
   xx   exit
   xx dup, primitive_function_jo?, false?branch, 3
   xx   save_into__jo_heap
   xx   exit
   xx dup, variable_jo?, false?branch, 3
   xx   save_into__jo_heap
   xx   exit
   xx dup, macro_jo?, false?branch, 3
   xx   execute_jo
   xx   exit
   xx drop
   xx exit

define_function "write-undefined-word-report,for-funtion-body", write_undefined_word_report__for_funtion_body
   ;; << -- >>
   xx literal, string$undefined_word_report__for_funtion_body
   xx literal, length$undefined_word_report__for_funtion_body
   xx write_string
   xx exit

string$undefined_word_report__for_funtion_body:
   db "   make-jojo meets UNDEFINED-WORD : "
.end:
length$undefined_word_report__for_funtion_body = (.end - string$undefined_word_report__for_funtion_body)
define_macro "address", M__address
   ;; << string[address, length] -- string[address, length] >>
   xx literal, address
   xx save_into__jo_heap

   xx dup2
   xx string_head__word
   xx find, false?branch, 4
   xx   save_into__jo_heap
   xx   string_tail__word
   xx   exit
   xx drop

   xx dup2
   xx write_undefined_word_report__for_funtion_body
   xx string_head__word, write_string
   xx literal, 10, write_byte
   ;; ><><><
   ;; here we should not compile the function into memory at all
   xx exit
define_function "save-into,primitive-string-heap", save_into__primitive_string_heap
   ;; << string[address, length] -- address >>
   xx dup, V__current_free_address__primitive_string
   xx save_two_bytes

   xx literal, 2
   xx address, V__current_free_address__primitive_string
   xx add_save

   xx tuck
   xx V__current_free_address__primitive_string
   xx string_to_buffer!

   xx address, V__current_free_address__primitive_string
   xx add_save

   xx exit
define_function "save-into,jo-heap", save_into__jo_heap
   ;; << number -- address >>
   xx V__current_free_address__jo_heap
   xx save

   xx literal, bead_size
   xx address, V__current_free_address__jo_heap
   xx add_save

   xx exit
define_function "define-function", CICADA__define_function
   ;; << string[address, length] -- >>
   xx dup2

   xx V__current_free_address__primitive_string
   xx   save_into__jo_heap
   xx string_head__word
   xx   save_into__primitive_string_heap

   xx V__first_jo_in_dictionary
   xx jo_to_link
   xx   save_into__jo_heap

   xx V__current_free_address__jo_heap
   xx address, V__first_jo_in_dictionary
   xx save

   xx literal, explain$function
   xx   save_into__jo_heap

   xx dup2, string_tail__word
   xx   make_jojo

   ;; when debugging
   ;; instead of drop2
   ;; one may wish to do some thing to the string
   xx drop2
   xx exit
define_function "define-macro", CICADA__define_macro
   ;; << string[address, length] -- >>
   xx dup2

   xx V__current_free_address__primitive_string
   xx   save_into__jo_heap
   xx string_head__word
   xx   save_into__primitive_string_heap

   xx V__first_jo_in_dictionary
   xx jo_to_link
   xx   save_into__jo_heap

   xx V__current_free_address__jo_heap
   xx address, V__first_jo_in_dictionary
   xx save

   xx literal, explain$macro
   xx   save_into__jo_heap

   xx dup2, string_tail__word
   xx   make_jojo

   ;; when debugging
   ;; instead of drop2
   ;; one may wish to do some thing to the string
   xx drop2
   xx exit
define_function "define-variable", CICADA__define_variable
   ;; << variable, string[address, length] -- >>
   xx dup2

   xx V__current_free_address__primitive_string
   xx   save_into__jo_heap
   xx string_head__word
   xx   save_into__primitive_string_heap

   xx V__first_jo_in_dictionary
   xx jo_to_link
   xx   save_into__jo_heap

   xx V__current_free_address__jo_heap
   xx address, V__first_jo_in_dictionary
   xx save

   xx literal, explain$variable
   xx   save_into__jo_heap

   ;; when debugging
   ;; instead of drop2
   ;; one may wish to do some thing to the string
   xx drop2
   xx   save_into__jo_heap
   xx exit
define_variable "", last_jo_in_assembly
   ;; << -- >>
   xx 0
define_variable "*current-free-address,primitive-string-heap*", V__current_free_address__primitive_string
   xx current_free_address$primitive_string_heap
size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

segment readable writeable
address$un_initialized_memory:
   rb size$un_initialized_memory
