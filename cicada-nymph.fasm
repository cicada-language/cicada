;;;; before you compile the code
;;;; do not forget to choose your platform
;;;; in the following code

include "platform-configuration.inc"

;; in fasm, "dup" is a reserved word
dup equ duplicate

;; in fasm, "end" is a reserved word
finish equ end
end equ exit

match =64bit, machine {

jo_size = 8 ;; (byte)
xx equ dq

}

match =32bit, machine {

jo_size = 4 ;; (byte)
xx equ dd

rax equ eax
rbx equ ebx
rcx equ ecx
rdx equ edx

rsp equ esp
rbp equ ebp
rsi equ esi
rdi equ edi

syscall equ int 80h

}

match =linux =64bit, platform machine {

define linux64_sys_6_r8  r8
define linux64_sys_5_r9  r9
define linux64_sys_4_r10 r10
define linux64_sys_3_rdx rdx
define linux64_sys_2_rsi rsi
define linux64_sys_1_rdi rdi
define linux64_sys_n_rax rax

define linux64_syscall_read   0
define linux64_syscall_write  1
define linux64_syscall_open   2
define linux64_syscall_close  3
define linux64_syscall_exit   60
;; about open & read & write

}

match =linux =64bit, platform machine {

format ELF64 executable 3

}

match =linux =64bit, platform machine {

entry begin_to_interpret_threaded_code
segment readable executable writeable

}

match =linux =32bit, platform machine {

define linux32_sys_6_ebp ebp
define linux32_sys_5_edi edi
define linux32_sys_4_esi esi
define linux32_sys_3_edx edx
define linux32_sys_2_ecx ecx
define linux32_sys_1_ebx ebx
define linux32_sys_n_eax eax

define linux32_syscall_exit    1
define linux32_syscall_read    3
define linux32_syscall_write   4
define linux32_syscall_open    5
define linux32_syscall_close   6

}

match =linux =32bit, platform machine {

format ELF executable 3

}

match =linux =32bit, platform machine {

entry begin_to_interpret_threaded_code
segment readable executable writeable

}

current_free_address$un_initialized_memory = address$un_initialized_memory

labeling  equ = current_free_address$un_initialized_memory
preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +

size$argument_stack = 1024 * 1024 * jo_size

   preserve 64 * jo_size
address$argument_stack labeling
   preserve size$argument_stack

match =64bit, machine {

;; if you want to extend cicada in assembly
;; the following registers must NOT be used

define pointer$argument_stack r15

}

match =64bit, machine {

macro push_argument_stack register \{
   mov [pointer$argument_stack], register
   add pointer$argument_stack, jo_size
\}

macro pop_argument_stack register \{
   sub pointer$argument_stack, jo_size
   mov register, [pointer$argument_stack]
\}

}

match =32bit, machine {

pointer$argument_stack:
   xx address$argument_stack

}

match =32bit, machine {

macro push_argument_stack register \{
   if register in <eax>
   push ebx
   mov ebx, [pointer$argument_stack]
   mov [ebx], register
   add ebx, jo_size
   mov [pointer$argument_stack], ebx
   pop ebx
   else
   push eax
   mov eax, [pointer$argument_stack]
   mov [eax], register
   add eax, jo_size
   mov [pointer$argument_stack], eax
   pop eax
   finish if
\}

macro pop_argument_stack register \{
   if register in <eax>
   push ebx
   mov ebx, [pointer$argument_stack]
   sub ebx, jo_size
   mov register, [ebx]
   mov [pointer$argument_stack], ebx
   pop ebx
   else
   push eax
   mov eax, [pointer$argument_stack]
   sub eax, jo_size
   mov register, [eax]
   mov [pointer$argument_stack], eax
   pop eax
   finish if
\}

}

size$return_stack = 1024 * 1024 * jo_size

   preserve 64 * jo_size
address$return_stack labeling
   preserve size$return_stack

match =64bit, machine {

;; if you want to extend cicada in assembly
;; the following registers must NOT be used

define pointer$return_stack r14

}

match =64bit, machine {

macro push_return_stack register \{
   mov [pointer$return_stack], register
   add pointer$return_stack, jo_size
\}

macro pop_return_stack register \{
   sub pointer$return_stack, jo_size
   mov register, [pointer$return_stack]
\}

}

match =32bit, machine {

pointer$return_stack:
   xx address$return_stack

}

match =32bit, machine {

macro push_return_stack register \{
   if register in <eax>
   push ebx
   mov ebx, [pointer$return_stack]
   mov [ebx], register
   add ebx, jo_size
   mov [pointer$return_stack], ebx
   pop ebx
   else
   push eax
   mov eax, [pointer$return_stack]
   mov [eax], register
   add eax, jo_size
   mov [pointer$return_stack], eax
   pop eax
   finish if
\}

macro pop_return_stack register \{
   if register in <eax>
   mov ebx, [pointer$return_stack]
   sub ebx, jo_size
   mov register, [ebx]
   mov [pointer$return_stack], ebx
   else
   mov eax, [pointer$return_stack]
   sub eax, jo_size
   mov register, [eax]
   mov [pointer$return_stack], eax
   finish if
\}

}

match =64bit, machine {

macro next \{
   pop_return_stack rbx
     mov rax, [rbx]
   add rbx, jo_size
   push_return_stack rbx
     jmp qword [rax]
\}

}


match =32bit, machine {

macro next \{
   pop_return_stack rbx
     mov rax, [rbx]
   add rbx, jo_size
   push_return_stack rbx
     jmp dword [rax]
\}

}

;; initial link to point to 0 (as null)
link = 0

address$string_area:
   times 64 * 1024 db 0

address$core_file:
   file "core/core.cn"
end$core_file:

end$string_area:

current_free_address$string_area = address$string_area

macro make_name_string string {

virtual at 0
.start$string:
   db string
.end$string:
   dw (.end$string - .start$string)
   load .length word from (.end$string)
finish virtual
store word .length at (current_free_address$string_area)

current_free_address$string_area = current_free_address$string_area + 2

repeat .length
   virtual at 0
      db string
      load .char byte from (% - 1)
   finish virtual
   store byte .char at (current_free_address$string_area)
   current_free_address$string_area = current_free_address$string_area + 1
finish repeat

}

macro define_function string, jo {

define_function__#jo:

name__#jo:
   xx current_free_address$string_area

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$function

   ;; here follows a jojo as function-body

}

explain$function:
   mov rbx, [current_free_address$local_byte]
   push_return_stack rbx
   mov rbx, [current_free_address$local_jo]
   push_return_stack rbx
   add rax, jo_size
   push_return_stack rax
   next

macro define_primitive_function string, jo {

define_primitive_function__#jo:

name__#jo:
   xx current_free_address$string_area

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx assembly_code__#jo

assembly_code__#jo:

   ;; here follows assembly code
   ;; as primitive function body

}

macro define_variable string, jo {

define_variable__#jo:

length__#jo:
   xx 1

name__#jo:
   xx current_free_address$string_area

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$variable

   ;; here follows a value of jo_size
   ;; only one value is allowed

}

match =64bit, machine {

explain$variable:
   mov rcx, [rax - (jo_size * 3)]
   add rax, jo_size
.loop:
   mov rdx, qword [rax]
   push_argument_stack rdx
   add rax, jo_size
   loop .loop
   next

}

match =32bit, machine {

explain$variable:
   mov rcx, [rax - (jo_size * 3)]
   add rax, jo_size
.loop:
   mov rdx, dword [rax]
   push_argument_stack rdx
   add rax, jo_size
   loop .loop
   next

}

macro define_exception string, jo {

define_exception__#jo:

   xx 0

name__#jo:
   xx current_free_address$string_area

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

jo:
   xx explain$exception

   ;; here follows a jojo as function-body

}

define_variable "*lost-exception-REPL*", V__lost_exception_REPL
   xx basic_REPL

string$lost_exception_REPL:
   db "* an exception has lost itself", 10
   db "  the function-jo stored in *lost-exception-REPL*", 10
   db "  is reseted to", 10
   db "  as a top-level-REPL", 10
.end:
length$lost_exception_REPL = (.end - string$lost_exception_REPL)

match =64bit, machine {

define_primitive_function "instruction,exception-reset-stack", exception_reset_stack
   ;; << -- >>
   pop_return_stack rbx
     mov rax, [rbx]
     sub rax, (jo_size * 3)
     mov pointer$argument_stack, [rax]
   add rbx, jo_size
   push_return_stack rbx
   next

}

match =32bit, machine {

define_primitive_function "instruction,exception-reset-stack", exception_reset_stack
   ;; << -- >>
   pop_return_stack rbx
     mov rax, [rbx]
     sub rax, (jo_size * 3)
     mov rax, [rax]
     mov [pointer$argument_stack], rax
   add rbx, jo_size
   push_return_stack rbx
   next

}

match =64bit, machine {

explain$exception:
   mov rsi, rax

.next_jojo:
   pop_return_stack rbx
   mov rax, qword [rbx]
   cmp rax, exception_head
   je .next_jo
   cmp pointer$return_stack, address$return_stack
   je .not_found
   jmp .next_jojo


.next_jo:
   ;; expecting
   ;;   rbx jojo
   ;;   rsi jo (to cmp)
   add rbx, jo_size
   mov rax, qword [rbx]
   cmp rax, rsi
   je .found
   test rax, rax
   jz .next_jojo
   jmp .next_jo


.found:
   ;; expecting
   ;;   pointer$return_stack
   ;;   rsi jo
   pop_return_stack rax
   ;; mov pointer$argument_stack, rax
   mov rbx, rsi
   sub rbx, (jo_size * 3)
   mov [rbx], rax

   mov rbx, [current_free_address$local_jo]
   push_return_stack rbx

   mov rbx, [current_free_address$local_byte]
   push_return_stack rbx

   add rsi, jo_size
   push_return_stack rsi
   next

.not_found:
   mov rax, string$lost_exception_REPL
   push_argument_stack rax
   mov rax, length$lost_exception_REPL
   push_argument_stack rax
   call __write_string

   mov rax, [V__lost_exception_REPL + jo_size]
   push_argument_stack rax
   call (reset_top_level_REPL + jo_size)

}

match =32bit, machine {

explain$exception:
   mov rsi, rax

.next_jojo:
   pop_return_stack rbx
   mov rax, dword [rbx]
   cmp rax, exception_head
   je .next_jo
   mov rdx, [pointer$return_stack]
   cmp rdx, address$return_stack
   je .not_found
   jmp .next_jojo


.next_jo:
   ;; expecting
   ;;   rbx jojo
   ;;   rsi jo (to cmp)
   add rbx, jo_size
   mov rax, dword [rbx]
   cmp rax, rsi
   je .found
   test rax, rax
   jz .next_jojo
   jmp .next_jo


.found:
   ;; expecting
   ;;   pointer$return_stack
   ;;   rsi jo
   pop_return_stack rax
   ;; mov [pointer$argument_stack], rax
   mov rbx, rsi
   sub rbx, (jo_size * 3)
   mov [rbx], rax

   mov rbx, [current_free_address$local_jo]
   push_return_stack rbx

   mov rbx, [current_free_address$local_byte]
   push_return_stack rbx

   add rsi, jo_size
   push_return_stack rsi
   next

.not_found:
   mov rax, string$lost_exception_REPL
   push_argument_stack rax
   mov rax, length$lost_exception_REPL
   push_argument_stack rax
   call __write_string

   mov rax, [V__lost_exception_REPL + jo_size]
   push_argument_stack rax
   call (reset_top_level_REPL + jo_size)

   }

match =64bit, machine {

define_primitive_function "execute-jo", execute_jo
   ;; << jo -- unknown >>
   pop_argument_stack rax
   jmp qword [rax]

}


match =32bit, machine {

define_primitive_function "execute-jo", execute_jo
   ;; << jo -- unknown >>
   pop_argument_stack eax
   jmp dword [eax]

}

define_variable "*jo-size*", V__jo_size
   xx jo_size

define_function "jo->name", jo_to_name
   ;; << jo -- string[address, length] >>
   xx literal, jo_size, subtraction
   xx literal, jo_size, subtraction
   xx fetch
   xx address_to_string
   xx end

define_function "jo->link", jo_to_link
   ;; << jo -- link >>
   xx literal, jo_size
   xx subtraction
   xx end

define_function "jo->pre-jo", jo_to_pre_jo
   ;; << jo -- pre-jo >>
   xx jo_to_link
   xx fetch
   xx dup, zero?, false?branch, 2
   xx   end
   xx literal, jo_size
   xx addition
   xx end

define_function "jo->type", jo_to_type
   ;; << jo -- type >>
   xx dup

   xx dup, fetch
   xx swap, subtraction, literal, jo_size, equal?, false?branch, 4
   xx   drop, zero
   xx   end

   xx fetch
   xx end

define_function "primitive-function-jo?", primitive_function_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx zero?
   xx end

define_function "function-jo?", function_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$function
   xx equal?
   xx end

define_function "exception-jo?", exception_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$exception
   xx equal?
   xx end

define_function "variable-jo?", variable_jo?
   ;; << jo -- bool >>
   xx jo_to_type
   xx literal, explain$variable
   xx equal?
   xx end

define_variable "*string-area*", V__string_area
   xx address$string_area

define_variable "*size,string-area*", V__size__string_area
   xx (end$string_area - address$string_area)

;; *current-free-address,string-area*
;; is at epilog

define_function "address->string", address_to_string
   ;; << address -- string[address, length] >>
   xx dup
   xx literal, 2, addition  ;; address
   xx swap, fetch_two_bytes ;; length
   xx end

define_function "string-area,stay", string_area__stay
   ;; << string[address, length] -- >>
   xx dup, V__current_free_address__string_area
   xx save_two_bytes

   xx literal, 2
   xx address, V__current_free_address__string_area
   xx add_save

   xx tuck
   xx V__current_free_address__string_area
   xx string_to_buffer!

   xx address, V__current_free_address__string_area
   xx add_save
   xx end

define_primitive_function "end", end
   pop_return_stack rbx
   pop_return_stack rax
   mov [current_free_address$local_jo], rax
   pop_return_stack rax
   mov [current_free_address$local_byte], rax
   next

match =64bit, machine {

define_primitive_function "tail-call", tail_call
   pop_return_stack rbx
   pop_return_stack rax
   mov [current_free_address$local_jo], rax
   pop_return_stack rax
   mov [current_free_address$local_byte], rax
   mov rax, [rbx]
   jmp qword [rax]
}


match =32bit, machine {

define_primitive_function "tail-call", tail_call
   pop_return_stack rbx
   pop_return_stack rcx
   mov [current_free_address$local_jo], rcx
   pop_return_stack rcx
   mov [current_free_address$local_byte], rcx
   mov rax, [rbx]
   jmp dword [rax]

;;;; old note
;; ><><>< can not be the following
;; maybe still something wrong with pop_return_stack
;; but I care less about this now
;; define_primitive_function "tail-call", tail_call
;;    pop_return_stack ebx
;;    pop_return_stack eax
;;    mov [current_free_address$local_jo], eax
;;    mov eax, [ebx]
;;    jmp dword [eax]

}

match =linux =64bit, platform machine {

__exit_with_tos:
   ;; << exit-code -- >>
   pop_argument_stack linux64_sys_1_rdi
   mov linux64_sys_n_rax, linux64_syscall_exit
   syscall

}

match =linux =32bit, platform machine {

__exit_with_tos:
   ;; << exit-code -- >>
   pop_argument_stack linux32_sys_1_ebx
   mov linux32_sys_n_eax, linux32_syscall_exit
   syscall

}

match =linux =64bit, platform machine {

__exit_with_zero:
   ;; << -- >>
   xor linux64_sys_1_rdi, linux64_sys_1_rdi
   mov linux64_sys_n_rax, linux64_syscall_exit
   syscall

}

match =linux =32bit, platform machine {

__exit_with_zero:
   ;; << -- >>
   xor linux32_sys_1_ebx, linux32_sys_1_ebx
   mov linux32_sys_n_eax, linux32_syscall_exit
   syscall

}

match =linux =64bit, platform machine {

__exit_with_six:
   ;; << -- >>
   mov linux64_sys_1_rdi, 6
   mov linux64_sys_n_rax, linux64_syscall_exit
   syscall

}

match =linux =32bit, platform machine {

__exit_with_six:
   ;; << -- >>
   mov linux32_sys_1_ebx, 6
   mov linux32_sys_n_eax, linux32_syscall_exit
   syscall

}

match =linux =64bit, platform machine {

__write_string:
   ;; << address, length -- >>
   pop_argument_stack linux64_sys_3_rdx     ;; max length to be write
   pop_argument_stack linux64_sys_2_rsi     ;; address
   mov linux64_sys_1_rdi, 1                 ;; stdout
   mov linux64_sys_n_rax, linux64_syscall_write
   syscall
   ret

}

match =linux =32bit, platform machine {

__write_string:
   ;; << address, length -- >>
   pop_argument_stack linux32_sys_3_edx     ;; max length to be write
   pop_argument_stack linux32_sys_2_ecx     ;; address
   mov linux32_sys_1_ebx, 1                 ;; stdout
   mov linux32_sys_n_eax, linux32_syscall_write
   syscall
   ret

}

match =linux =64bit, platform machine {

__reset_argument_stack:
   ;; << -- >>
   mov pointer$argument_stack,  address$argument_stack
   ret

}

match =linux =32bit, platform machine {

__reset_argument_stack:
   ;; << -- >>
   mov rax, address$argument_stack
   mov [pointer$argument_stack], rax
   ret

}

match =linux =64bit, platform machine {

__reset_return_stack:
   ;; << -- >>
   mov pointer$return_stack,    address$return_stack
   ret

}

match =linux =32bit, platform machine {

__reset_return_stack:
   ;; << -- >>
   mov rax, address$return_stack
   mov [pointer$return_stack], rax
   ret

}

__reset_local_jo:
   ;; << -- >>
   mov rax, address$local_jo
   mov [current_free_address$local_jo], rax
   ret

__reset_local_byte:
   ;; << -- >>
   mov rax, address$local_byte
   mov [current_free_address$local_byte], rax
   ret

match =linux, platform {

begin_to_interpret_threaded_code:

   cld ;; set DF = 0, then rsi and rdi are incremented

   call __reset_argument_stack
   call __reset_return_stack

   pop_return_stack rax
   mov rax, jojo_for__report_return_stack_is_empty_and_exit
   push_return_stack rax

   mov rax, address$local_byte
   push_return_stack rax

   mov rax, address$local_jo
   push_return_stack rax

   mov rax, first_jojo
   push_return_stack rax
   next

first_jojo:
   ;; xx little_test
   xx initialization
   xx load_core_file
   xx tail_call, basic_REPL

}

define_function "initialization", initialization
   ;; << -- >>
   xx init__rule_set__make_jojo
   xx end

string$report_return_stack_is_empty_and_exit:
   db "* the return-stack is empty now", 10
   db "  good bye ^-^/", 10
.end:
length$report_return_stack_is_empty_and_exit = (.end - string$report_return_stack_is_empty_and_exit)

define_primitive_function "report-return-stack-is-empty-and-exit", report_return_stack_is_empty_and_exit
   ;; << -- >>
   mov rax, string$report_return_stack_is_empty_and_exit
   mov rcx, length$report_return_stack_is_empty_and_exit
   push_argument_stack rax
   push_argument_stack rcx
   call __write_string
   call __exit_with_zero

jojo_for__report_return_stack_is_empty_and_exit:
   xx report_return_stack_is_empty_and_exit

match =64bit, machine {

define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
   ;; << top_level_REPL [jo] -- >>
   call __reset_return_stack
   call __reset_local_jo
   call __reset_local_byte
   pop_argument_stack rax
   jmp qword [rax]

}

match =32bit, machine {

define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
   ;; << top_level_REPL [jo] -- >>
   call __reset_return_stack
   call __reset_local_jo
   call __reset_local_byte
   pop_argument_stack rax
   jmp dword [rax]

}

define_primitive_function "bye", exit_with_TOS
   call __exit_with_tos

define_variable "", V__little_test_number
   xx 3

define_function "little_test", little_test

   ;;;; variable
   ;; xx V__little_test_number
   ;; xx exit_with_TOS
   ;;;; exit ocde : 3

   ;;;; literal
   ;; xx literal, 4
   ;; xx exit_with_TOS
   ;;;; exit ocde : 4

   ;;;; address
   ;; xx address, V__little_test_number, fetch, add2
   ;; xx address, V__little_test_number, save
   ;; xx V__little_test_number
   ;; xx exit_with_TOS
   ;;;; exit ocde : 5

   ;;;; end
   ;; xx literal, 2, negate
   ;; xx literal, 8
   ;; xx addition
   ;; xx exit_with_TOS
   ;;;; 6

   ;;;; tail_call
   ;; xx literal, 2
   ;; xx literal, 4
   ;; xx power
   ;; xx exit_with_TOS
   ;;;; exit ocde : 16

   ;;;; write_byte
   ;; xx literal, 64, write_byte
   ;; xx literal, 10, write_byte
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; @

   ;;;; read_byte
   ;; xx read_byte, write_byte
   ;; xx exit_with_TOS
   ;;;;

   ;;;; branch
   ;; xx read_byte, write_byte
   ;; xx branch, -3
   ;;;; read a string that ended by <return>
   ;;;; write the readed string
   ;;;; or we can say
   ;;;; read line and write line
   ;;;; or we can say
   ;;;; echo line

   ;;;; false?branch
   ;; xx false, false?branch, 9
   ;; xx   literal, 64, write_byte
   ;; xx   literal, 10, write_byte
   ;; xx   zero
   ;; xx   exit_with_TOS
   ;; xx true, false?branch, 9
   ;; xx   literal, 65, write_byte
   ;; xx   literal, 10, write_byte
   ;; xx   zero
   ;; xx   exit_with_TOS
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; A

   ;;;; read_word & write_string
   ;; xx read_word, write_string
   ;; xx literal, 10, write_byte
   ;; xx read_word_for_REPL, write_string
   ;; xx literal, 10, write_byte
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; read line
   ;;;; write first two words of the line

   ;;;; string->integer
   ;; xx read_word, string_to_integer
   ;; xx exit_with_TOS
   ;;;; type 123
   ;;;; exit code 123

   ;;;; use jo_to_name to test the macro make_name_string
   ;; xx literal, jo_to_name, jo_to_name, write_string
   ;; xx literal, 10, write_byte
   ;; xx literal, addition, jo_to_name, write_string
   ;; xx literal, 10, write_byte
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; print "jo->name"
   ;;;; print "add"

   ;;;; xxoverxx
   ;; xx literal, 1
   ;; xx literal, 2
   ;; xx literal, 3
   ;; xx literal, 4
   ;; xx xxoverxx
   ;; xx pretty_write_integer
   ;; xx pretty_write_integer
   ;; xx pretty_write_integer
   ;; xx pretty_write_integer
   ;; xx pretty_write_integer
   ;; xx pretty_write_integer
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; 2 1 4 3 2 1

   ;;;; jo_link__find_jo
   ;; xx read_word, string_to_integer ;; number
   ;; xx read_word, string_to_integer ;; number
   ;; xx read_word, V__jo_link__core, jo_link__find_jo ;; add
   ;; xx drop ;; true
   ;; xx execute_jo
   ;; xx write_integer
   ;; xx zero
   ;; xx exit_with_TOS
   ;;;; 1 2 add
   ;;;; print "3"

   ;;;; basic-REPL (without the ability to define function)
   ;;;; after this test
   ;;;; we will use basic-REPL to do further tests
   ;; xx basic_REPL
   ;;;; 1 2 add .

define_primitive_function "instruction,literal", literal
   ;; << -- fixnum >>
   pop_return_stack rbx
     mov rax, [rbx]
     push_argument_stack rax
   add rbx, jo_size
   push_return_stack rbx
   next

define_primitive_function "instruction,address", address
   ;; << -- address >>
   pop_return_stack rbx
     mov rax, [rbx]
     add rax, jo_size
     push_argument_stack rax
   add rbx, jo_size
   push_return_stack rbx
   next

define_primitive_function "instruction,branch", branch
   pop_return_stack rbx
   mov rax, [rbx]
   imul rax, jo_size
   add rbx, rax
   push_return_stack rbx
   next

define_primitive_function "instruction,false?branch", false?branch
   ;; << true of false -- >>
   pop_argument_stack rax
   test rax, rax
   jnz help__false?branch__not_to_branch

   pop_return_stack rbx
   mov rax, [rbx]
   imul rax, jo_size
   add rbx, rax
   push_return_stack rbx
   next

help__false?branch__not_to_branch:
   pop_return_stack rbx
   add rbx, jo_size
   push_return_stack rbx
   next

match =64bit, machine {

define_primitive_function "instruction,prepare-for", prepare_for
   ;; << -- >>
   pop_return_stack rbx

   pop_return_stack rcx
   pop_return_stack rdx

   push_return_stack pointer$argument_stack
   push_return_stack rbx

   push_return_stack rdx
   push_return_stack rcx

.next:
   add rbx, jo_size
   mov rax, qword [rbx]
   cmp rax, end
   je .then
   jmp .next
.then:
   add rbx, jo_size
   push_return_stack rbx
   next

}

match =32bit, machine {

define_primitive_function "instruction,prepare-for", prepare_for
   ;; << -- >>
   pop_return_stack ebx

   pop_return_stack ecx
   pop_return_stack edx

   mov eax, [pointer$argument_stack]
   push_return_stack eax
   push_return_stack ebx

   push_return_stack edx
   push_return_stack ecx

.next:
   add ebx, jo_size
   mov eax, dword [ebx]
   cmp eax, end
   je .then
   jmp .next
.then:
   add ebx, jo_size
   push_return_stack ebx
   next

}

define_primitive_function "instruction,exception-head", exception_head
   ;; << -- >>
   pop_return_stack rax
   pop_return_stack rax
   next

define_primitive_function "drop", drop
   ;; << a -- >>
   pop_argument_stack rax
   next

define_primitive_function "drop2", drop2
   ;; << a b -- >>
   pop_argument_stack rax
   pop_argument_stack rax
   next

match =64bit, machine {

define_primitive_function "dup", dup
   ;; << a -- a, a >>
   mov  rax, [pointer$argument_stack - (1 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "dup2", dup2
   ;; << a b -- a b a b >>
   mov  rbx, [pointer$argument_stack - (1 * jo_size)]
   mov  rax, [pointer$argument_stack - (2 * jo_size)]
   push_argument_stack rax
   push_argument_stack rbx
   next

}

match =32bit, machine {

define_primitive_function "dup", dup
   ;; << a -- a a >>
   pop_argument_stack rax
   push_argument_stack rax
   push_argument_stack rax
   next

define_primitive_function "dup2", dup2
   ;; << a b -- a b a b >>
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rax
   push_argument_stack rbx
   next

}

match =64bit, machine {

define_primitive_function "over", over
   ;; << a b -- a b | a >>
   mov  rax, [pointer$argument_stack - (2 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xx", xoverxx
   ;; << a | b c -- a | b c | a >>
   mov  rax, [pointer$argument_stack - (3 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|x", xxoverx
   ;; << a b | c -- a b | c | a b >>
   mov  rax, [pointer$argument_stack - (3 * jo_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (3 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xx", xxoverxx
   ;; << a b | c d -- a b | c d | a b >>
   mov  rax, [pointer$argument_stack - (4 * jo_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (4 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xxx", xoverxxx
   ;; << a | b c d -- a | b c d | a >>
   mov  rax, [pointer$argument_stack - (4 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xxxx", xoverxxxx
   ;; << a | b c d -- a | b c d | a >>
   mov  rax, [pointer$argument_stack - (5 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xxxx", xxoverxxxx
   ;; << a b | c d e f -- a b | c d e f | a b >>
   mov  rax, [pointer$argument_stack - (6 * jo_size)]
   push_argument_stack rax
   mov  rax, [pointer$argument_stack - (6 * jo_size)]
   push_argument_stack rax
   next

}

match =32bit, machine {

define_primitive_function "over", over
   ;; << a b -- a b | a >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (2 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xx", xoverxx
   ;; << a | b c -- a | b c | a >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (3 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|x", xxoverx
   ;; << a b | c -- a b | c | a b >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (3 * jo_size)]
   push_argument_stack rax
   mov rax, [rbx - (2 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xx", xxoverxx
   ;; << a b | c d -- a b | c d | a b >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (4 * jo_size)]
   push_argument_stack rax
   mov rax, [rbx - (3 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xxx", xoverxxx
   ;; << a | b c d -- a | b c d | a >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (4 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "x|over|xxxx", xoverxxxx
   ;; << a | b c d -- a | b c d | a >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (5 * jo_size)]
   push_argument_stack rax
   next

define_primitive_function "xx|over|xxxx", xxoverxxxx
   ;; << a b | c d e f -- a b | c d e f | a b >>
   mov rbx, [pointer$argument_stack]
   mov rax, [rbx - (6 * jo_size)]
   push_argument_stack rax
   mov rax, [rbx - (5 * jo_size)]
   push_argument_stack rax
   next

}

define_primitive_function "tuck", tuck
   ;; << a b -- b | a b >>
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "x|tuck|xx", xtuckxx
   ;; << a | b c -- b c | a | b c >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|tuck|x", xxtuckx
   ;; << a b | c -- c | a b | c >>
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|tuck|xx", xxtuckxx
   ;; << a b | c d -- c d | a b | c d >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next

define_primitive_function "xxx|tuck|x", xxxtuckx
   ;; << a b c | d -- d | a b c | d >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next

define_primitive_function "swap", swap
   ;; << a b -- b a >>
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rbx
   push_argument_stack rax
   next

define_primitive_function "x|swap|xx", xswapxx
   ;; << a | b c -- b c | a >>
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rax
   next

define_primitive_function "xx|swap|x", xxswapx
   ;; << a b | c -- c | a b >>
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rcx
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "x|swap|xxx", xswapxxx
   ;; << a | b c d -- b c d | a >>
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   next

define_primitive_function "xxx|swap|x", xxxswapx
   ;; << a b c | d -- d | a b c >>
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   next

define_primitive_function "xx|swap|xx", xxswapxx
   ;; << a b | c d -- c d | a b >>
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rax
   push_argument_stack rbx
   next


define_primitive_function "x|swap|xxxx", xswapxxxx
   ;; << a | b c d e -- b c d e | a >>
   pop_argument_stack  rsi ;; e
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rsi ;; e
   push_argument_stack rax
   next

define_primitive_function "xxxx|swap|x", xxxxswapx
   ;; << a b c d | e --  e | a b c d >>
   pop_argument_stack  rsi ;; e
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rsi ;; e
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next


define_primitive_function "xx|swap|xxxx", xxswapxxxx
   ;; << a b | c d e f -- c d e f | a b >>
   pop_argument_stack  rsi ;; f
   pop_argument_stack  rdi ;; e
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rcx
   push_argument_stack rdx
   push_argument_stack rdi ;; e
   push_argument_stack rsi ;; f
   push_argument_stack rax
   push_argument_stack rbx
   next

define_primitive_function "xxxx|swap|xx", xxxxswapxx
   ;; << a b c d | e f --  e f | a b c d >>
   pop_argument_stack  rsi ;; f
   pop_argument_stack  rdi ;; e
   pop_argument_stack  rdx
   pop_argument_stack  rcx
   pop_argument_stack  rbx
   pop_argument_stack  rax
   push_argument_stack rdi ;; e
   push_argument_stack rsi ;; f
   push_argument_stack rax
   push_argument_stack rbx
   push_argument_stack rcx
   push_argument_stack rdx
   next

define_variable "*the-stack*", V__the_stack
   xx address$argument_stack

match =64bit, machine {

define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
   xx address$argument_stack

define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
   ;; << -- >>
   mov [V__the_stack_pointer_snapshot + jo_size], pointer$argument_stack
   next

}

match =32bit, machine {

define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
   xx address$argument_stack

define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
   ;; << -- >>
   mov eax, [pointer$argument_stack]
   mov [V__the_stack_pointer_snapshot + jo_size], eax
   next

}

define_primitive_function "false", false
   ;; << -- false >>
   xor rax, rax
   push_argument_stack rax
   next

define_primitive_function "true", true
   ;; << -- true >>
   xor rax, rax
   inc rax
   push_argument_stack rax
   next

define_function "false?", false?
   ;; << bool -- bool >>
   xx false, equal?
   xx end

define_function "true?", true?
   ;; << bool -- bool >>
   xx true, equal?
   xx end

define_function "not", CICADA__not
   ;; << bool -- bool >>
   xx false, equal?
   xx end

define_function "and", CICADA__and
   ;; << bool, bool -- bool >>
   xx false?, false?branch, (.true-$)/jo_size
   xx   drop
   xx   false
   xx   end
.true:
   xx false?branch, 3
   xx   true
   xx   end
   xx false
   xx end

define_function "or", CICADA__or
   ;; << bool, bool -- bool >>
   xx false?branch, (.false-$)/jo_size
   xx   drop
   xx   true
   xx   end
.false:
   xx false?branch, 3
   xx   true
   xx   end
   xx false
   xx end

define_function "xor", CICADA__xor
   ;; << bool, bool -- bool >>
   xx false?branch, (.false-$)/jo_size
   xx   CICADA__not
   xx   end
.false:
   xx end

define_primitive_function "zero", zero
   ;; << -- 0 >>
   xor rax, rax
   push_argument_stack rax
   next

define_primitive_function "one", one
   ;; << -- 1 >>
   xor rax, rax
   inc rax
   push_argument_stack rax
   next

define_function "zero?", zero?
   ;; << bool -- bool >>
   xx zero, equal?
   xx end

define_function "one?", one?
   ;; << bool -- bool >>
   xx one, equal?
   xx end

match =64bit, machine {

define_primitive_function "add1", add1
   ;; << n -- n+1 >>
   inc qword [pointer$argument_stack - (1 * jo_size)]
   next

define_primitive_function "add2", add2
   ;; << n -- n+2 >>
   add qword [pointer$argument_stack - (1 * jo_size)], 2
   next

define_primitive_function "add3", add3
   ;; << n -- n+3 >>
   add qword [pointer$argument_stack - (1 * jo_size)], 3
   next

define_primitive_function "add4", add4
   ;; << n -- n+4 >>
   add qword [pointer$argument_stack - (1 * jo_size)], 4
   next

define_primitive_function "add8", add8
   ;; << n -- n+8 >>
   add qword [pointer$argument_stack - (1 * jo_size)], 8
   next


define_primitive_function "sub1", sub1
   ;; << n -- n-1 >>
   dec qword [pointer$argument_stack - (1 * jo_size)]
   next

define_primitive_function "sub2", sub2
   ;; << n -- n-2 >>
   sub qword [pointer$argument_stack - (1 * jo_size)], 2
   next

define_primitive_function "sub3", sub3
   ;; << n -- n-3 >>
   sub qword [pointer$argument_stack - (1 * jo_size)], 3
   next

define_primitive_function "sub4", sub4
   ;; << n -- n-4 >>
   sub qword [pointer$argument_stack - (1 * jo_size)], 4
   next

define_primitive_function "sub8", sub8
   ;; << n -- n-8 >>
   sub qword [pointer$argument_stack - (1 * jo_size)], 8
   next


define_primitive_function "add", addition
   ;; << a b -- a+b >>
   pop_argument_stack rax
   add qword [pointer$argument_stack - (1 * jo_size)], rax
   next

define_primitive_function "sub", subtraction
   ;; << a b -- a-b >>
   pop_argument_stack rax
   sub qword [pointer$argument_stack - (1 * jo_size)], rax
   next

}

match =32bit, machine {

define_primitive_function "add1", add1
   ;; << n -- n+1 >>
   pop_argument_stack rax
   inc rax
   push_argument_stack rax
   next

define_primitive_function "add2", add2
   ;; << n -- n+2 >>
   pop_argument_stack rax
   inc rax
   inc rax
   push_argument_stack rax
   next

define_primitive_function "add3", add3
   ;; << n -- n+3 >>
   pop_argument_stack rax
   inc rax
   inc rax
   inc rax
   push_argument_stack rax
   next

define_primitive_function "add4", add4
   ;; << n -- n+4 >>
   pop_argument_stack rax
   inc rax
   inc rax
   inc rax
   inc rax
   push_argument_stack rax
   next

define_primitive_function "add8", add8
   ;; << n -- n+8 >>
   pop_argument_stack rax
   add rax, 8
   push_argument_stack rax
   next


define_primitive_function "sub1", sub1
   ;; << n -- n-1 >>
   pop_argument_stack rax
   dec rax
   push_argument_stack rax
   next

define_primitive_function "sub2", sub2
   ;; << n -- n-2 >>
   pop_argument_stack rax
   dec rax
   dec rax
   push_argument_stack rax
   next

define_primitive_function "sub3", sub3
   ;; << n -- n-3 >>
   pop_argument_stack rax
   dec rax
   dec rax
   dec rax
   push_argument_stack rax
   next

define_primitive_function "sub4", sub4
   ;; << n -- n-4 >>
   pop_argument_stack rax
   dec rax
   dec rax
   dec rax
   dec rax
   push_argument_stack rax
   next

define_primitive_function "sub8", sub8
   ;; << n -- n-8 >>
   pop_argument_stack rax
   sub rax, 8
   push_argument_stack rax
   next


define_primitive_function "add", addition
   ;; << a b -- a+b >>
   pop_argument_stack rbx
   pop_argument_stack rax
   add rax, rbx
   push_argument_stack rax
   next

define_primitive_function "sub", subtraction
   ;; << a b -- a-b >>
   pop_argument_stack rbx
   pop_argument_stack rax
   sub rax, rbx
   push_argument_stack rax
   next

}

define_primitive_function "mul", multiple
   ;; << a b -- a*b >>
   pop_argument_stack  rbx ;; 2ed arg
   pop_argument_stack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; when there are two registers as arg
   ;; imul will save the result into the first register
   push_argument_stack rbx
   next

define_function "negate", negate
   ;; << n --  -n >>
   xx zero
   xx swap, subtraction
   xx end

define_function "power", power
   ;; n must be nature number for now
   ;; << a, n -- a^n >>
   ;; 1. when a = 0, n =/= 0
   ;;    the power__loop returns 0
   ;; 2. when a = 0, n = 0
   ;;    the power__loop returns 1
   ;;    but I need it to return 0
   xx over, zero?, false?branch, 3
   xx   drop
   xx   end
   xx literal, 1, swap ;; leave product
   xx power__loop
   xx end

define_function "power,loop", power__loop
   ;; << a, product, n -- a^n >>
   xx dup, zero?, false?branch, 5
   xx   drop, swap, drop
   xx   end
   xx sub1
   xx swap
   xx   xoverxx, multiple
   xx swap
   xx tail_call, power__loop

define_primitive_function "moddiv", moddiv
   ;; << a, b -- a mod b, quotient >>
   ;; << dividend, divisor -- remainder, quotient >>
   ;; the arg of idiv is divisor
   ;; the lower half of dividend is taken from rax
   ;; the upper half of dividend is taken from rdx
   xor  rdx, rdx   ;; high-part of dividend is not used
   pop_argument_stack  rbx ;; 2ed arg
   pop_argument_stack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   push_argument_stack rdx ;; remainder
   push_argument_stack rax ;; quotient
   next


define_function "divmod", divmod
   ;; << a, b -- quotient, a mod b >>
   xx moddiv, swap
   xx end

define_function "div", division
   ;; << a, b -- quotient >>
   xx divmod, drop
   xx end

define_function "mod", modulo
   ;; << a, b -- a mod b >>
   xx moddiv, drop
   xx end

define_primitive_function "equal?", equal?
   ;; << a, b -- bool >>
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "less-than?", less_than?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "greater-than?", greater_than?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   push_argument_stack  rax
   next

define_primitive_function "less-or-equal?", less_or_equal?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "greater-or-equal?", greater_or_equal?
   pop_argument_stack rbx
   pop_argument_stack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   push_argument_stack rax
   next

define_function "equal2?", equal2?
   ;; << a1, b1, a2, b2 -- bool >>
   xx xswapxx
   xx equal?, false?, false?branch, 4
   xx   drop2, false
   xx   end
   xx equal?
   xx end

define_function "negative?", negative?
   ;; << integer -- bool >>
   xx zero, less_than?
   xx end

define_function "positive?", positive?
   ;; << integer -- bool >>
   xx zero, greater_than?
   xx end

match =64bit, machine {

define_primitive_function "fetch", fetch
   ;; ( address -- value )
   pop_argument_stack  rbx
   mov rax, [rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-byte", fetch_byte
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov al, byte[rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-two-bytes", fetch_two_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov ax, word [rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-four-bytes", fetch_four_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov eax, dword [rbx]
   push_argument_stack rax
   next

define_primitive_function "n-fetch", n_fetch
   ;; << address, n -- value-1, ..., value-n >>
   pop_argument_stack  rcx
   pop_argument_stack  rdx
.loop:
   mov rax, qword [rdx]
   push_argument_stack rax
   add rdx, jo_size
   loop .loop
   next

}

match =64bit, machine {

define_primitive_function "save", save
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov [rbx], rax
   next

define_primitive_function "save-byte", save_byte
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov byte[rbx], al
   next

define_primitive_function "save-two-bytes", save_two_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov word [rbx], ax
   next

define_primitive_function "save-four-bytes", save_four_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov dword [rbx], eax
   next

define_primitive_function "n-save", n_save
   ;; << value-n, ..., value-1, address, n -- >>
   pop_argument_stack rcx
   pop_argument_stack rdx
   mov rax, jo_size
   imul rax, rcx
   add rdx, rax
   ;; for address is based on 0
   ;; but n is based on 1
   sub rdx, jo_size
.loop:
   pop_argument_stack rax
   mov qword [rdx], rax
   sub rdx, jo_size
   loop .loop
   next

define_primitive_function "add-save", add_save
   ;; ( number to add, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   add qword [rbx], rax
   next

define_primitive_function "sub-save", sub_save
   ;; ( number to sub, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   sub qword [rbx], rax
   next

}

match =32bit, machine {

define_primitive_function "fetch", fetch
   ;; ( address -- value )
   pop_argument_stack  rbx
   mov rax, [rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-byte", fetch_byte
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov al, byte[rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-two-bytes", fetch_two_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov ax, word [rbx]
   push_argument_stack rax
   next

define_primitive_function "fetch-four-bytes", fetch_four_bytes
   ;; ( address -- value )
   pop_argument_stack rbx
   xor rax, rax
   mov eax, dword [rbx]
   push_argument_stack rax
   next

define_primitive_function "n-fetch", n_fetch
   ;; << address, n -- value-1, ..., value-n >>
   pop_argument_stack  rcx
   pop_argument_stack  rdx
.loop:
   mov rax, dword [rdx]
   push_argument_stack rax
   add rdx, jo_size
   loop .loop
   next

}

match =32bit, machine {

define_primitive_function "save", save
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov [rbx], rax
   next

define_primitive_function "save-byte", save_byte
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov byte[rbx], al
   next

define_primitive_function "save-two-bytes", save_two_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov word [rbx], ax
   next

define_primitive_function "save-four-bytes", save_four_bytes
   ;; ( value, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   mov dword [rbx], eax
   next

define_primitive_function "n-save", n_save
   ;; << value-n, ..., value-1, address, n -- >>
   pop_argument_stack rcx
   pop_argument_stack rdx
   mov rax, jo_size
   imul rax, rcx
   add rdx, rax
   ;; for address is based on 0
   ;; but n is based on 1
   sub rdx, jo_size
.loop:
   pop_argument_stack rax
   mov dword [rdx], rax
   sub rdx, jo_size
   loop .loop
   next

define_primitive_function "add-save", add_save
   ;; ( number to add, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   add dword [rbx], rax
   next

define_primitive_function "sub-save", sub_save
   ;; ( number to sub, address -- )
   pop_argument_stack rbx
   pop_argument_stack rax
   sub dword [rbx], rax
   next

}

define_primitive_function "clear-memory", clear_memory
   ;; << size, address -- >>
   pop_argument_stack rdx
   pop_argument_stack rcx
   xor rax, rax
.loop:
   mov byte [rdx], al
   inc rdx
   dec rcx
   loop .loop
   next

match =64bit, machine {

define_primitive_function "bit-and", bit_and
   ;; << a, b -- a and b >>
   pop_argument_stack rbx
   and [pointer$argument_stack - (1 * jo_size)], rbx
   next

define_primitive_function "bit-or", bit_or
   ;; << a, b -- a or b >>
   pop_argument_stack rbx
   or  [pointer$argument_stack - (1 * jo_size)], rbx
   next

define_primitive_function "bit-xor", bit_xor
   ;; << a, b -- a xor b >>
   pop_argument_stack rbx
   xor [pointer$argument_stack - (1 * jo_size)], rbx
   next

define_primitive_function "bit-invert", bit_invert
   ;; << a -- invert a >>
   not qword [pointer$argument_stack - (1 * jo_size)]
   next

}

match =32bit, machine {

define_primitive_function "bit-and", bit_and
   ;; << a, b -- a and b >>
   pop_argument_stack rbx
   mov rax, [pointer$argument_stack]
   and [rax - (1 * jo_size)], rbx
   next

define_primitive_function "bit-or", bit_or
   ;; << a, b -- a or b >>
   pop_argument_stack rbx
   mov rax, [pointer$argument_stack]
   or  [rax - (1 * jo_size)], rbx
   next

define_primitive_function "bit-xor", bit_xor
   ;; << a, b -- a xor b >>
   pop_argument_stack rbx
   mov rax, [pointer$argument_stack]
   xor [rax - (1 * jo_size)], rbx
   next

define_primitive_function "bit-invert", bit_invert
   ;; << a -- invert a >>
   mov rax, [pointer$argument_stack]
   not dword [rax - (1 * jo_size)]
   next

}

define_primitive_function "bit-left", bit_left
   ;; ( fixnum, step -- fixnum * 2^step )
   pop_argument_stack rcx
   pop_argument_stack rax
   shl rax, cl
   push_argument_stack rax
   next

define_primitive_function "bit-right", bit_right
   ;; ( fixnum, step -- fixnum / 2^step )
   pop_argument_stack rcx
   pop_argument_stack rax
   shr rax, cl
   push_argument_stack rax
   next

define_primitive_function "bit-right,sign", bit_right__sign
   ;; ( fixnum, step -- new fixnum )
   pop_argument_stack rcx
   pop_argument_stack rax
   sar rax, cl
   push_argument_stack rax
   next

;; BT copies a bit from a given register to the carry flag
define_primitive_function "get-bit", get_bit
   ;; ( fixnum, offset -- bit )
   pop_argument_stack rbx
   pop_argument_stack rax
   bt rax, rbx
   setc al
   movzx rax, al
   push_argument_stack rax
   next

define_primitive_function "set-bit", set_bit
   ;; ( fixnum, offset -- fixnum )
   pop_argument_stack rbx
   pop_argument_stack rax
   bts rax, rbx
   push_argument_stack rax
   next

define_primitive_function "clear-bit", clear_bit
   ;; ( fixnum, offset -- fixnum )
   pop_argument_stack rbx
   pop_argument_stack rax
   btr rax, rbx
   push_argument_stack rax
   next

define_primitive_function "invert-bit", invert_bit
   ;; ( fixnum, offset -- fixnum )
   pop_argument_stack rbx
   pop_argument_stack rax
   btc rax, rbx
   push_argument_stack rax
   next

define_primitive_function "find-lowest-set-bit", find_lowest_set_bit
   ;; ( fixnum -- offset )
   pop_argument_stack rax
   bsf rax, rax
   jz @f
   push_argument_stack rax
   next
@@:
   mov rax, -1
   push_argument_stack rax
   next

define_primitive_function "find-highest-set-bit", find_highest_set_bit
   ;; ( fixnum -- offset )
   pop_argument_stack rax
   bsr rax, rax
   jz @f
   push_argument_stack rax
   next
@@:
   mov rax, -1
   push_argument_stack rax
   next

match =linux =64bit, platform machine {

buffer$write_byte:
   db 0

define_primitive_function "write-byte", write_byte
   ;; << byte -- >>
   pop_argument_stack rax
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [buffer$write_byte], al
   mov linux64_sys_3_rdx, 1                 ;; max length to be write
   mov linux64_sys_2_rsi, buffer$write_byte ;; address
   mov linux64_sys_1_rdi, 1                 ;; stdout
   mov linux64_sys_n_rax, linux64_syscall_write
   syscall
   next

}

match =linux =32bit, platform machine {

buffer$write_byte:
   db 0

define_primitive_function "write-byte", write_byte
   ;; << byte -- >>
   ;; just calls the Linux write system call
   pop_argument_stack rax
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [buffer$write_byte], al
   mov linux32_sys_3_edx, 1                 ;; max length to be write
   mov linux32_sys_2_ecx, buffer$write_byte ;; address
   mov linux32_sys_1_ebx, 1                 ;; stdout
   mov linux32_sys_n_eax, linux32_syscall_write
   syscall
   next

}

size$reading_stack = 1024 * jo_size

   preserve 64 * jo_size
address$reading_stack labeling
   preserve size$reading_stack

pointer$reading_stack:
   xx address$reading_stack

match =64bit, machine {

define_primitive_function "push-reading-stack", push_reading_stack
   ;; << string[address, length] -- >>
   pop_argument_stack rax
   mov rbx, [pointer$reading_stack]
   mov [rbx], rax
   add qword [pointer$reading_stack], jo_size
   pop_argument_stack rax
   mov rbx, [pointer$reading_stack]
   mov [rbx], rax
   add qword [pointer$reading_stack], jo_size
   next

define_primitive_function "pop-reading-stack", pop_reading_stack
   ;; << -- string[address, length] >>
   sub qword [pointer$reading_stack], jo_size
   mov rbx, [pointer$reading_stack]
   mov rax, [rbx]
   push_argument_stack rax
   sub qword [pointer$reading_stack], jo_size
   mov rbx, [pointer$reading_stack]
   mov rax, [rbx]
   push_argument_stack rax
   next

define_primitive_function "drop-reading-stack", drop_reading_stack
   ;; << -- >>
   sub qword [pointer$reading_stack], (jo_size * 2)
   next

}

match =32bit, machine {

define_primitive_function "push-reading-stack", push_reading_stack
   ;; << string[address, length] -- >>
   pop_argument_stack rax
   mov rsi, [pointer$reading_stack]
   mov [rsi], rax
   add dword [pointer$reading_stack], jo_size
   pop_argument_stack rax
   mov rsi, [pointer$reading_stack]
   mov [rsi], rax
   add dword [pointer$reading_stack], jo_size
   next

define_primitive_function "pop-reading-stack", pop_reading_stack
   ;; << -- string[address, length] >>
   sub dword [pointer$reading_stack], jo_size
   mov rsi, [pointer$reading_stack]
   mov rax, [rsi]
   push_argument_stack rax
   sub dword [pointer$reading_stack], jo_size
   mov rsi, [pointer$reading_stack]
   mov rax, [rsi]
   push_argument_stack rax
   next

define_primitive_function "drop-reading-stack", drop_reading_stack
   ;; << -- >>
   sub dword [pointer$reading_stack], (jo_size * 2)
   next

}

define_primitive_function "tos-reading-stack", tos_reading_stack
   ;; << -- string[address, length] >>
   mov rbx, [pointer$reading_stack]
   sub rbx, jo_size
   mov rax, [rbx]
   push_argument_stack rax
   mov rbx, [pointer$reading_stack]
   sub rbx, jo_size
   sub rbx, jo_size
   mov rax, [rbx]
   push_argument_stack rax
   next

define_function "reading-stack-empty?", reading_stack_empty?
   ;; << -- bool >>
   xx literal, pointer$reading_stack, fetch
   xx literal, address$reading_stack
   xx equal?
   xx end

match =linux =64bit, platform machine {

define_primitive_function "read-line-from-stdin", read_line_from_stdin
   ;; << buffer address, max length -- counter >>
   pop_argument_stack linux64_sys_3_rdx
   pop_argument_stack linux64_sys_2_rsi
   xor linux64_sys_1_rdi, linux64_sys_1_rdi ;; stdin
   mov linux64_sys_n_rax, linux64_syscall_read
   syscall
   ;; the return value
   ;; is a count of the number of bytes transferred
   push_argument_stack rax
   next

}

match =linux =32bit, platform machine {

define_primitive_function "read-line-from-stdin", read_line_from_stdin
   ;; << buffer address, max length -- counter >>
   pop_argument_stack linux32_sys_3_edx
   pop_argument_stack linux32_sys_2_ecx
   xor linux32_sys_1_ebx, linux32_sys_1_ebx ;; stdin
   mov linux32_sys_n_eax, linux32_syscall_read
   syscall
   ;; the return value
   ;; is a count of the number of bytes transferred
   push_argument_stack rax
   next

}

max_input_length = 64 * 1024

buffer$reading labeling
   preserve max_input_length

replace$reading labeling
   preserve 1024

define_function "read-byte", read_byte
   ;; << -- byte >>
   xx pop_reading_stack
   xx dup2, empty_string?, CICADA__not, false?branch, (.bad_tos-$)/jo_size
   xx   sub1, swap
   xx   tuck
   xx   add1, swap
   xx   push_reading_stack
   xx   fetch_byte
   xx   end
.bad_tos:
   xx reading_stack_empty?, false?branch, (.not_empty-$)/jo_size
   xx   drop2
   xx   literal, buffer$reading
   xx   literal, max_input_length
   xx   read_line_from_stdin
   xx   dup, positive?, false?branch, (.read_error-$)/jo_size
   xx     literal, buffer$reading
   xx     swap
   xx     push_reading_stack
   xx     tail_call, read_byte
.read_error:
   ;;   ignore <end-of-file>
   ;;   ignore reading error
   xx   drop
   xx   literal, buffer$reading
   xx   literal, 0
   xx   push_reading_stack
   xx   tail_call, read_byte
.not_empty:
   xx   literal, error$read_byte
   xx   literal, length$read_byte
   xx   write_string
   xx   literal, replace$reading
   xx   literal, 1024
   xx   read_line_from_stdin
   xx   literal, replace$reading
   xx   swap
   xx   push_reading_stack
   xx   tail_call, read_byte

error$read_byte:
   db "* (read-byte) meets empty-string in reading-stack", 10
   db "  and this empty-stack is not at the bottom of the reading-stack", 10
   db "  you can type a line to replace this empty string", 10
.end:
length$read_byte = (.end - error$read_byte)

define_function "load-core-file", load_core_file
   ;; << unknown -- unknown >>
   xx literal, address$core_file
   xx literal, (end$core_file - address$core_file)
   xx push_reading_stack
   xx end

define_function "space-char?", space_char?
   ;; << char -- bool >>
   xx literal, 32
   xx less_or_equal?
   xx end

define_function "bar-ket-char?", bar_ket_char?
   ;; << char -- bool >>
   xx dup, literal, '(', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, ')', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, '[', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, ']', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, '{', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, '}', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx dup, literal, '"', equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx drop, false
   xx end

define_function "digit-char?", digit_char?
   ;; << char -- bool >>
   xx dup, literal, '0', less_than?, false?branch, 4
   xx   drop, false
   xx   end
   xx dup, literal, '9', less_or_equal?, false?branch, 4
   xx   drop, true
   xx   end
   xx drop, false
   xx end

define_function "digit-char->number", digit_char_to_number
   ;; << char -- decimal-digit >>
   xx literal, '0'
   xx subtraction
   xx end

define_function "number->digit-char", number_to_digit_char
   ;; << decimal-digit -- char >>
   xx literal, '0'
   xx addition
   xx end

;; return false when length == 0
define_primitive_function "compare-buffer", compare_buffer
   ;; << address, address, length -- bool >>
   pop_argument_stack rcx
   pop_argument_stack rdi
   pop_argument_stack rsi
   repe cmpsb
   sete al
   movzx rax, al
   push_argument_stack rax
   next

define_function "cursor->next-matching-byte", cursor_to_next_matching_byte
   ;; << cursor, byte -- cursor new address >>
   xx over, add1, fetch_byte
   xx over, equal?, false?branch, 4
   xx   drop, add1
   xx   end
   xx swap
   xx add1, swap
   xx tail_call, cursor_to_next_matching_byte

define_function "write-string", write_string
   ;; << string[address, length] -- >>
   xx dup, zero?, false?branch, 3
   xx   drop2
   xx   end
   xx sub1, swap
   xx dup, fetch_byte, write_byte
   xx add1, swap
   xx tail_call, write_string

define_function ".s", ALIAS__write_string
   ;; << integer -- >>
   xx write_string
   xx end

define_function "pretty-write-string", pretty_write_string
   ;; << integer -- >>
   xx write_string
   xx literal, 10
   xx write_byte
   xx end

define_function "empty-string?", empty_string?
  ;; << string[address, length] -- bool >>
  xx swap, drop
  xx zero?
  xx end

define_function "string-equal?", string_equal?
   ;; << string[address, length], string[address, length] -- bool >>
   xx xoverxx, equal?, false?branch, 4
   xx   swap
   xx   compare_buffer
   xx   end
   xx drop, drop2
   xx false
   xx end

define_function "string-head,byte", string_head__byte
   ;; << string[address, length] -- char >>
   xx drop, fetch_byte
   xx end

define_function "string-tail,byte", string_tail__byte
   ;; << string[address, length] -- [address + 1, length + 1] >>
   xx sub1, swap
   xx add1
   xx swap
   xx end

define_primitive_function "string->buffer!", string_to_buffer!
   ;; ( string[address, length], buffer[address] -- )
   pop_argument_stack rdi ;; destination
   pop_argument_stack rcx ;; counter
   pop_argument_stack rsi ;; source
   rep movsb
   next

match =64bit, machine {

buffer$string_reverse! labeling
   preserve 1024


define_primitive_function "string-reverse!", string_reverse!
   ;; << string[address, length] -- string[address, length] >>
   mov rdi, buffer$string_reverse!
   mov rcx, [pointer$argument_stack - (1 * jo_size)]
   mov rsi, [pointer$argument_stack - (2 * jo_size)]
   rep movsb

   mov rcx, [pointer$argument_stack - (1 * jo_size)]
   dec rdi ;; cursor back into string in buffer$string_reverse!
   mov rsi, [pointer$argument_stack - (2 * jo_size)]
.loop:
   mov al, byte [rdi]
   mov byte [rsi], al
   dec rdi
   inc rsi
   loop .loop

   next

}

match =32bit, machine {

buffer$string_reverse! labeling
   preserve 1024


define_primitive_function "string-reverse!", string_reverse!
   ;; << string[address, length] -- string[address, length] >>
   mov rbx, [pointer$argument_stack]
   mov rdi, buffer$string_reverse!
   mov rcx, [rbx - (1 * jo_size)]
   mov rsi, [rbx - (2 * jo_size)]
   rep movsb

   mov rcx, [rbx - (1 * jo_size)]
   dec rdi ;; cursor back into string in buffer$string_reverse!
   mov rsi, [rbx - (2 * jo_size)]
.loop:
   mov al, byte [rdi]
   mov byte [rsi], al
   dec rdi
   inc rsi
   loop .loop

   next

}

define_function "char-string?", char_string?
   ;; << string[address, length], char -- bool >>
   xx xxswapx
   xx dup, one?, false?, false?branch, 5
   xx   drop2, drop
   xx   false
   xx   end
   xx string_head__byte, equal?, false?branch, 3
   xx   true
   xx   end
   xx false
   xx end

define_function "zero-string?", zero_string?
   ;; << string[address, length] -- bool >>
   xx dup2, literal, '0', char_string?, false?branch, 4
   xx   drop2, true
   xx   end
   xx dup2
   xx string_head__byte, literal, '-', equal?, false?, false?branch, 4
   xx   drop2, false
   xx   end
   xx string_tail__byte, literal, '0', char_string?
   xx end

define_function "digit-string?", digit_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, true
   xx   end
   xx over, fetch_byte, digit_char?, false?branch, 4
   xx   string_tail__byte
   xx   tail_call, digit_string?
   xx drop2, false
   xx end

define_function "integer-string?", integer_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, literal, '-', char_string?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, string_head__byte, literal, '-', equal?, false?branch, 4
   xx   string_tail__byte
   xx   digit_string?
   xx   end
   xx digit_string?
   xx end

sum$digit_string_to_number:
   xx 0

counter$digit_string_to_number:
   xx 0

define_function "digit-string->number", digit_string_to_number
   ;; << string[address, length] -- integer >>
   xx zero, literal, sum$digit_string_to_number, save
   xx zero, literal, counter$digit_string_to_number, save

   xx dup2, string_reverse!
   xx   help__digit_string_to_number
   xx string_reverse!, drop2

   xx literal, sum$digit_string_to_number
   xx fetch
   xx end

define_function "help,digit-string->number", help__digit_string_to_number
   ;; << reversed-string[address, length] -- >>
   xx dup, zero?, false?branch, 3
   xx   drop2
   xx   end

   xx dup2, string_head__byte, digit_char_to_number
   xx   literal, 10
   xx   literal, counter$digit_string_to_number, fetch
   xx     one
   xx     literal, counter$digit_string_to_number
   xx     add_save
   xx   power
   xx multiple

   xx literal, sum$digit_string_to_number
   xx add_save

   xx string_tail__byte
   xx tail_call, help__digit_string_to_number

define_function "string->integer", string_to_integer
   ;; << string[address, length] -- integer >>
   xx dup2, string_head__byte, literal, '-', equal?, false?, false?branch, 3
   xx   digit_string_to_number
   xx   end
   xx string_tail__byte
   xx digit_string_to_number
   xx negate
   xx end

define_function "string,find-char", string__find_char
  ;; << string[address, length], char
  ;;    -- address, true
  ;;    -- false >>
  xx over, zero?, false?branch, 5
  xx   drop, drop2
  xx   false
  xx   end
  xx xoverxx, fetch_byte
  xx over, equal?, false?branch, 4
  xx   drop2
  xx   true
  xx   end
  xx xxswapx
  xx string_tail__byte
  xx xswapxx
  xx tail_call, string__find_char

define_function "space-string?", space_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, true
   xx   end
   xx dup2, string_head__byte, space_char?, false?branch, 4
   xx   string_tail__byte
   xx   tail_call, space_string?
   xx drop2, false
   xx end

define_function "string->word-begin", string_to_word_begin
   ;; << string[address, length] -- string[address, length] >>
   xx dup, zero?, false?branch, 2
   ;;   no error handling
   xx   end
   xx dup2, string_head__byte
   xx space_char?, false?, false?branch, 2
   xx   end
   xx string_tail__byte
   xx tail_call, string_to_word_begin

define_function "string->word-end", string_to_word_end
   ;; << string[address, length] -- string[address, length] >>
   xx dup, zero?, false?branch, 2
   ;;   no error handling
   xx   end
   xx dup2, string_head__byte
   xx bar_ket_char?, false?branch, 3
   xx   string_tail__byte
   xx   end
   xx help__string_to_word_end
   xx end

define_function "help,string->word-end", help__string_to_word_end
   ;; << string[address, length] -- address >>
   xx dup, zero?, false?branch, 2
   ;;   no error handling
   xx   end
   xx dup2, string_head__byte
   xx space_char?, false?branch, 2
   xx   end
   xx dup2, string_head__byte
   xx bar_ket_char?, false?branch, 2
   xx   end
   xx string_tail__byte
   xx tail_call, help__string_to_word_end

define_function "string-head,word", string_head__word
   ;; << string[address, length] -- word[address, length] >>
   xx string_to_word_begin
   xx dup2, string_to_word_end
   xx swap, drop
   xx subtraction
   xx end

define_function "string-tail,word", string_tail__word
   ;; << string[address, length] -- string[address, length] >>
   xx string_to_word_begin
   xx string_to_word_end
   xx end

;; 2 ^ 64 = 18446744073709551616
;; which is of length 20
;; so
;; I use 32 to align to 16

buffer$write_number labeling
   preserve 32

counter$write_number:
   xx 0

define_function "write-number", write_number
   ;; << number -- >>
   xx write_number__fill_buffer
   xx write_string
   xx end

define_function "write-number,fill-buffer", write_number__fill_buffer
   ;; << number -- string[address, length] >>
   xx zero
   xx literal, counter$write_number, save

   xx write_number__loop

   xx literal, buffer$write_number
   xx literal, counter$write_number, fetch
   xx string_reverse!
   xx end


define_function "write-number,loop", write_number__loop
   ;; << rest-number -- >>
   xx literal, 10, divmod

   xx number_to_digit_char
   xx literal, buffer$write_number
   xx literal, counter$write_number, fetch
   xx addition
   xx save_byte

   xx one
   xx literal, counter$write_number
   xx add_save

   xx dup, zero?, false?branch, 3
   xx   drop
   xx   end
   xx tail_call, write_number__loop

define_function "write-integer", write_integer
   ;; << integer -- >>
   xx dup, negative?, false?, false?branch, 3
   xx   write_number
   xx   end
   xx literal, '-', write_byte
   xx negate
   xx write_number
   xx end

define_function "pretty-write-integer", pretty_write_integer
   ;; << integer -- >>
   xx write_integer
   xx literal, 32
   xx write_byte
   xx end

define_function ".", ALIAS__pretty_write_integer
   ;; << integer -- >>
   xx pretty_write_integer
   xx end

max_word_length = 512

buffer$read_word labeling
   preserve max_word_length

buffer$read_word_for_REPL labeling
   preserve max_word_length

define_function "read-word-begin-char", read_word_begin_char
   ;; << -- non-blank-char >>
   xx read_byte
   xx dup, literal, 32 ;; ascii.space
   xx greater_than?, false?branch, 2
   xx   end
   xx drop
   xx tail_call, read_word_begin_char

define_function "read-word->buffer", read_word_to_buffer
   ;; << buffer -- word[address, length] >>
   xx pop_reading_stack
   xx dup2, space_string?, CICADA__not, false?branch, (.bad_tos-$)/jo_size
   xx   dup2, string_tail__word, push_reading_stack
   xx   string_head__word
   xx   xoverxx, xxoverx
   xx   xswapxx
   xx   string_to_buffer!
   xx   swap, drop
   xx   end
.bad_tos:
   xx reading_stack_empty?, false?branch, (.not_empty-$)/jo_size
   xx   drop2
   xx   literal, buffer$reading
   xx   literal, max_input_length
   xx   read_line_from_stdin
   xx   dup, positive?, false?branch, (.read_error-$)/jo_size
   xx     literal, buffer$reading
   xx     swap
   xx     push_reading_stack
   xx     tail_call, read_word_to_buffer
.read_error:
   ;;   ignore <end-of-file>
   ;;   ignore reading error
   xx   drop
   xx   literal, buffer$reading
   xx   literal, 0
   xx   push_reading_stack
   xx   tail_call, read_word_to_buffer
.not_empty:
   xx   literal, error$read_word_to_buffer
   xx   literal, length$read_word_to_buffer
   xx   write_string
   xx   literal, replace$reading
   xx   literal, 1024
   xx   read_line_from_stdin
   xx   literal, replace$reading
   xx   swap
   xx   push_reading_stack
   xx   tail_call, read_word_to_buffer

error$read_word_to_buffer:
   db "* (read-word->buffer) meets empty-string in reading-stack", 10
   db "  and this empty-stack is not at the bottom of the reading-stack", 10
   db "  you can type a line to replace this empty string", 10
.end:
length$read_word_to_buffer = (.end - error$read_word_to_buffer)

define_function "read-word", read_word
   ;; << -- word[address of buffer$read_word, length] >>
   xx literal, buffer$read_word, read_word_to_buffer
   xx end

define_function "read-word-for-REPL", read_word_for_REPL
   ;; << -- word[address of buffer$read_word_for_REPL, length] >>
   xx literal, buffer$read_word_for_REPL, read_word_to_buffer
   xx end

define_variable "*jo-link,core*", V__jo_link__core
   xx (last_link + jo_size)

define_function "jo-link,last-jo?", jo_link__last_jo?
   ;; << jo -- bool >>
   xx jo_to_link
   xx fetch
   xx zero?
   xx end

define_function "jo-link,find-jo", jo_link__find_jo
   ;; << word[address, length], jo
   ;;    -- jo, true
   ;;    -- false >>
   xx xxtuckx
   xx jo_to_name, xxoverxx
   xx string_equal?, false?branch, 4
   xx   drop2, true
   xx   end
   xx xswapxx
   xx dup, jo_link__last_jo?, false?branch, 5
   xx   drop, drop2
   xx   false
   xx   end
   xx jo_to_pre_jo
   xx tail_call, jo_link__find_jo

define_function "execute-word", execute_word
   ;; << word[address, length] -- unknown >>
   xx dup2, integer_string?, false?branch, 3
   xx   string_to_integer
   xx   end
   ;; maybe more

   xx dup2 ;; for to report undefined word
   xx V__jo_link__core
   xx jo_link__find_jo, false?branch, 5
   xx   xxswapx, drop2
   xx   execute_jo
   xx   end

   xx write_undefined_word_report__for_execute_word
   xx write_string
   xx literal, 10
   xx write_byte
   xx end


define_function "write-undefined-word-report,for-execute-word", write_undefined_word_report__for_execute_word
   ;; << -- >>
   xx literal, string$undefined_word_report__for_execute_word
   xx literal, length$undefined_word_report__for_execute_word
   xx write_string
   xx end

string$undefined_word_report__for_execute_word:
   db "* (execute-word) meets undefined word : "
.end:
length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)

define_function "basic-REPL", basic_REPL
   ;; << unknown -- unknown >>
   xx read_word_for_REPL
   xx execute_word
   xx tail_call, basic_REPL

define_function "colon-string?", colon_string?
   ;; << string[address, length] -- bool >>
   xx literal, ':'
   xx char_string?
   xx end

define_function "semicolon-string?", semicolon_string?
   ;; << string[address, length] -- bool >>
   xx literal, ';'
   xx char_string?
   xx end

string$comment_begin:
   db "<<"

define_function "comment-begin-string?", comment_begin_string?
   ;; << string[address, length] -- bool >>
   xx literal, string$comment_begin
   xx literal, 2
   xx string_equal?
   xx end


string$comment_end:
   db ">>"

define_function "comment-end-string?", comment_end_string?
   ;; << -- >>
   xx literal, string$comment_end
   xx literal, 2
   xx string_equal?
   xx end

buffer$colon labeling
   preserve 1024 * 1024

cursor$colon:
   xx 0

length$colon:
   xx 0


define_function ":", colon
   ;; << -- string[address of buffer$colon, length] >>
   xx literal, buffer$colon
   xx literal, cursor$colon, save
   xx help__loop__colon
   ;; address
   xx literal, buffer$colon
   ;; length
   xx literal, cursor$colon, fetch
   xx literal, buffer$colon
   xx subtraction
   xx dup, literal, length$colon, save
   xx end


define_function "", help__loop__colon
   ;; << -- >>
   xx read_byte
   xx help__save_byte__colon
   xx help__meet_end__colon?, false?branch, 7
   xx   literal, 3 ;; for the string " ; "
   xx   literal, cursor$colon
   xx   sub_save
   xx   end
   xx help__meet_comment__colon?, false?branch, 9
   xx   literal, 4 ;; for the string " << "
   xx   literal, cursor$colon
   xx   sub_save
   xx   ignore_comment
   xx   tail_call, help__loop__colon
   xx tail_call, help__loop__colon


define_function "", help__save_byte__colon
   ;; << byte -- >>
   xx literal, cursor$colon, fetch
   xx save_byte
   xx one
   xx literal, cursor$colon
   xx add_save
   xx end


define_function "", help__meet_end__colon?
   ;; << -- bool >>
   xx literal, cursor$colon, fetch
   xx literal, 3, subtraction
   xx fetch_byte, space_char?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx literal, cursor$colon, fetch
   xx literal, 2, subtraction
   xx fetch_byte, literal, ';', equal?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx literal, cursor$colon, fetch
   xx literal, 1, subtraction
   xx fetch_byte, space_char?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx true
   xx end

define_function "", help__meet_comment__colon?
   ;; << -- bool >>
   xx literal, cursor$colon, fetch
   xx literal, 4, subtraction
   xx fetch_byte, space_char?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx literal, cursor$colon, fetch
   xx literal, 3, subtraction
   xx fetch_byte, literal, '<', equal?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx literal, cursor$colon, fetch
   xx literal, 2, subtraction
   xx fetch_byte, literal, '<', equal?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx literal, cursor$colon, fetch
   xx literal, 1, subtraction
   xx fetch_byte, space_char?
   xx false?, false?branch, 3
   xx   false
   xx   end
   xx true
   xx end

define_function "<<", ignore_comment
   ;; << -- >>
   xx read_word_for_REPL
   xx dup2, comment_begin_string?, false?branch, 5
   xx   drop2
   xx     ignore_comment ;; for the new nested-comment
   xx   tail_call, ignore_comment ;; for the rest-comment
   xx dup2, comment_end_string?, false?branch, 3
   xx   drop2
   xx   end
   xx drop2
   xx tail_call, ignore_comment

size$jojo_area = 1024 * 1024 * jo_size

define_variable "*jojo-area*", V__jojo_area
  xx address$jojo_area

define_variable "*size,jojo-area*", V__size__jojo_area
  xx size$jojo_area


address$jojo_area labeling
   preserve size$jojo_area

define_variable "*current-free-address,jojo-area*", V__current_free_address__jojo_area
   xx address$jojo_area

define_function "jojo-area,stay", jojo_area__stay
   ;; << number -- >>
   xx V__current_free_address__jojo_area
   xx save

   xx literal, jo_size
   xx address, V__current_free_address__jojo_area
   xx add_save
   xx end

preserve jo_size * 64
address$syntax_stack labeling
   preserve jo_size * 1024

define_variable "*pointer-syntax-stack*", V__pointer_syntax_stack
   xx address$syntax_stack

define_function "push-syntax-stack", push_syntax_stack
   ;; << syntax-set[address] -- >>
   xx V__pointer_syntax_stack
   xx save
   xx V__jo_size
   xx address, V__pointer_syntax_stack
   xx add_save
   xx end

define_function "pop-syntax-stack", pop_syntax_stack
   ;; << -- syntax-set[address] >>
   xx V__jo_size
   xx address, V__pointer_syntax_stack
   xx sub_save
   xx V__pointer_syntax_stack, fetch
   xx end

define_function "tos-syntax-stack", tos_syntax_stack
   ;; << -- syntax-set[address] >>
   xx V__pointer_syntax_stack
   xx V__jo_size
   xx subtraction
   xx fetch
   xx end

define_function "drop-syntax-stack", drop_syntax_stack
   ;; << -- >>
   xx V__jo_size
   xx address, V__pointer_syntax_stack
   xx sub_save
   xx end

define_function "syntax-stack-empty?", syntax_stack_empty?
   ;; << -- bool >>
   xx V__pointer_syntax_stack
   xx literal, address$syntax_stack
   xx equal?
   xx end

define_function "find-syntax", find_syntax
   ;; << word[address, length]
   ;;    -- function, true
   ;;    -- false >>
   xx syntax_stack_empty?, false?branch, 4
   xx   drop2
   xx   false
   xx   end
   xx tos_syntax_stack
   xx find_rule
   xx end

define_function "rule-set,fetch-border", rule_set__fetch_border
   ;; << rule-set -- border >>
   xx V__jo_size, subtraction
   xx fetch
   xx end

define_function "rule-set,save-border", rule_set__save_border
   ;; << border, rule-set -- >>
   xx V__jo_size, subtraction
   xx save
   xx end

define_function "cursor->rule", cursor_to_rule
   ;; << cursor -- rule[predicate, function] >>
   xx V__jo_size, subtraction
   xx V__jo_size, subtraction
   xx literal, 2
   xx n_fetch
   xx end

define_function "cursor->predicate", cursor_to_predicate
   ;; << cursor -- predicate >>
   xx V__jo_size, subtraction
   xx V__jo_size, subtraction
   xx fetch
   xx end

define_function "cursor->function", cursor_to_function
   ;; << cursor -- function >>
   xx V__jo_size, subtraction
   xx fetch
   xx end

define_function "add-rule", add_rule
   ;; << rule[predicate, function], rule-set -- >>
   xx xxtuckx
   xx rule_set__fetch_border
   xx literal, 2
   xx n_save
   xx dup
   xx rule_set__fetch_border
   xx V__jo_size, addition
   xx V__jo_size, addition
   xx swap
   xx rule_set__save_border
   xx end

cursor$find_rule:
   xx 0

define_function "find-rule", find_rule
   ;; << word[address, length], rule-set
   ;;    -- function, true
   ;;    -- false >>
   xx dup, rule_set__fetch_border
   xx literal, cursor$find_rule, save
   xx find_rule__loop
   xx end

define_function "find-rule,loop", find_rule__loop
   ;; << word[address, length], rule-set
   ;;    -- function, true
   ;;    -- false >>
   xx literal, cursor$find_rule, fetch
   xx over, equal?, false?branch, 5
   xx   drop, drop2
   xx   false
   xx   end
   xx xxoverx
   xx literal, cursor$find_rule, fetch
   xx cursor_to_predicate
   xx execute_jo, false?branch, (.not_found-$)/jo_size
   xx   drop, drop2
   xx   literal, cursor$find_rule, fetch
   xx   cursor_to_function
   xx   true
   xx   end
.not_found:
   xx literal, cursor$find_rule, fetch
   xx V__jo_size, subtraction
   xx V__jo_size, subtraction
   xx literal, cursor$find_rule, save
   xx tail_call, find_rule__loop

size$rule_set__make_jojo = 1024 * jo_size

cursor$rule_set__make_jojo:
   xx address$rule_set__make_jojo
address$rule_set__make_jojo:
   times size$rule_set__make_jojo db 0

define_variable "*rule-set,make-jojo*", V__rule_set__make_jojo
   xx address$rule_set__make_jojo

define_function "init,rule-set,make-jojo", init__rule_set__make_jojo
   ;; << -- >>
   xx literal, integer_string?
   xx literal, syntax__integer_string__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, word_is_address?
   xx literal, syntax__address__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, word_is_jo?
   xx literal, syntax__jo__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, word_is_branch?
   xx literal, syntax__branch__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, word_is_false?branch?
   xx literal, syntax__false?branch__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, word_is_double_quote?
   xx literal, syntax__double_quote__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, local_variable_save_string?
   xx literal, syntax__local_variable_save__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx literal, local_variable_fetch_string?
   xx literal, syntax__local_variable_fetch__make_jojo
   xx V__rule_set__make_jojo, add_rule

   xx end

define_function "syntax,integer-string,make-jojo", syntax__integer_string__make_jojo
   ;; << string[address, length], word[address, length] --
   ;;    string[address, length] >>
   xx literal, literal
   xx   jojo_area__stay
   xx string_to_integer
   xx   jojo_area__stay
   xx end

string$word_is_address?:
   db "address"
.end:
length$word_is_address? = (.end - string$word_is_address?)

define_function "word:address?", word_is_address?
   ;; << word[address, length] -- bool >>
   xx literal, string$word_is_address?
   xx literal, length$word_is_address?
   xx string_equal?
   xx end

define_function "syntax,address,make-jojo", syntax__address__make_jojo
   ;; << string[address, length], word:address --
   ;;    string[address, length] >>
   xx drop2

   xx literal, address
   xx jojo_area__stay

   xx dup2
   xx string_head__word
   xx V__jo_link__core
   xx jo_link__find_jo, false?branch, 4
   xx   jojo_area__stay
   xx   string_tail__word
   xx   end

   xx write_undefined_word_report__for_address
   xx dup2, string_head__word, write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo


define_function "write-undefined-word-report,for-address", write_undefined_word_report__for_address
   ;; << -- >>
   xx literal, string$undefined_word_report__for_address
   xx literal, length$undefined_word_report__for_address
   xx write_string
   xx end

string$undefined_word_report__for_address:
   db "* (make-jojo (address)) the word follows (address) is undefined : "
.end:
length$undefined_word_report__for_address = (.end - string$undefined_word_report__for_address)

string$word_is_jo?:
   db "jo"
.end:
length$word_is_jo? = (.end - string$word_is_jo?)

define_function "word:jo?", word_is_jo?
   ;; << word[address, length] -- bool >>
   xx literal, string$word_is_jo?
   xx literal, length$word_is_jo?
   xx string_equal?
   xx end

define_function "syntax,jo,make-jojo", syntax__jo__make_jojo
   ;; << string[address, length], word:jo --
   ;;    string[address, length] >>
   xx drop2

   xx literal, literal
   xx jojo_area__stay

   xx dup2
   xx string_head__word
   xx V__jo_link__core
   xx jo_link__find_jo, false?branch, 4
   xx   jojo_area__stay
   xx   string_tail__word
   xx   end

   xx write_undefined_word_report__for_jo
   xx dup2, string_head__word, write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo


define_function "write-undefined-word-report,for-jo", write_undefined_word_report__for_jo
   ;; << -- >>
   xx literal, string$undefined_word_report__for_jo
   xx literal, length$undefined_word_report__for_jo
   xx write_string
   xx end

string$undefined_word_report__for_jo:
   db "* (syntax,jo,make-jojo) the word follows (jo) is undefined : "
.end:
length$undefined_word_report__for_jo = (.end - string$undefined_word_report__for_jo)

string$word_is_branch?:
   db "branch"
.end:
length$word_is_branch? = (.end - string$word_is_branch?)

define_function "word:branch?", word_is_branch?
   ;; << word[branch, length] -- bool >>
   xx literal, string$word_is_branch?
   xx literal, length$word_is_branch?
   xx string_equal?
   xx end

define_function "syntax,branch,make-jojo", syntax__branch__make_jojo
   ;; << string[address, length], word:jo --
   ;;    string[address, length] >>
   xx drop2

   xx literal, branch
   xx jojo_area__stay

   xx dup2
   xx string_head__word
   xx dup2, integer_string?, false?branch, 5
   xx   string_to_integer
   xx   jojo_area__stay
   xx   string_tail__word
   xx   end

   xx write_not_integer_string_report__for_branch
   xx dup2, string_head__word, write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo


define_function "write-not-integer-string-report,for-branch", write_not_integer_string_report__for_branch
   ;; << -- >>
   xx literal, string$not_integer_string_report__for_branch
   xx literal, length$not_integer_string_report__for_branch
   xx write_string
   xx end

string$not_integer_string_report__for_branch:
   db "* (syntax,branch,make-jojo) the word follows (branch) must be a integer string : "
.end:
length$not_integer_string_report__for_branch = (.end - string$not_integer_string_report__for_branch)

string$word_is_false?branch?:
   db "false?branch"
.end:
length$word_is_false?branch? = (.end - string$word_is_false?branch?)

define_function "word:false?branch?", word_is_false?branch?
   ;; << word[false?branch, length] -- bool >>
   xx literal, string$word_is_false?branch?
   xx literal, length$word_is_false?branch?
   xx string_equal?
   xx end

define_function "syntax,false?branch,make-jojo", syntax__false?branch__make_jojo
   ;; << string[address, length], word:jo --
   ;;    string[address, length] >>
   xx drop2

   xx literal, false?branch
   xx jojo_area__stay

   xx dup2
   xx string_head__word
   xx dup2, integer_string?, false?branch, 5
   xx   string_to_integer
   xx   jojo_area__stay
   xx   string_tail__word
   xx   end

   xx write_not_integer_string_report__for_false?branch
   xx dup2, string_head__word, write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo


define_function "write-not-integer-string-report,for-false?branch", write_not_integer_string_report__for_false?branch
   ;; << -- >>
   xx literal, string$not_integer_string_report__for_false?branch
   xx literal, length$not_integer_string_report__for_false?branch
   xx write_string
   xx end

string$not_integer_string_report__for_false?branch:
   db "* (syntax,false?branch,make-jojo) the word follows (false?branch) must be a integer string : "
.end:
length$not_integer_string_report__for_false?branch = (.end - string$not_integer_string_report__for_false?branch)

string$word_is_double_quote?:
   db '"'
.end:
length$word_is_double_quote? = (.end - string$word_is_double_quote?)

define_function "word:double-quote?", word_is_double_quote?
   ;; << word[double-quote, length] -- bool >>
   xx literal, string$word_is_double_quote?
   xx literal, length$word_is_double_quote?
   xx string_equal?
   xx end

define_function "syntax,double-quote,make-jojo", syntax__double_quote__make_jojo
   ;; << string[address, length], word:double-quote --
   ;;    string[address, length] >>
   xx drop2

   xx dup2
   xx literal, '"', string__find_char
   xx false?branch, (.not_found-$)/jo_size
   xx   xoverxx, subtraction
   ;;   << string[address, length], length >>

   ;; address
   xx   literal, literal
   xx     jojo_area__stay
   xx   V__current_free_address__string_area, add2
   xx     jojo_area__stay
   xx   xoverxx, over
   xx     string_area__stay

   ;; length
   xx   literal, literal
   xx     jojo_area__stay
   xx   dup
   xx     jojo_area__stay

   xx   tuck, subtraction
   xx   xxswapx
   xx   addition
   xx   swap

   xx   string_tail__byte ;; over the ending double-quote
   xx   end

   .not_found:
   xx write_not_integer_string_report__for_double_quote
   xx literal, 10, write_byte
   xx !undo_make_jojo


define_function "write-not-integer-string-report,for-double-quote", write_not_integer_string_report__for_double_quote
   ;; << -- >>
   xx literal, string$not_integer_string_report__for_double_quote
   xx literal, length$not_integer_string_report__for_double_quote
   xx write_string
   xx end

string$not_integer_string_report__for_double_quote:
   db "* (syntax,double-quote,make-jojo) can not find the ending double-quote"
.end:
length$not_integer_string_report__for_double_quote = (.end - string$not_integer_string_report__for_double_quote)

define_function "make-jojo,dispatch-syntax-word", make_jojo__dispatch_syntax_word
   ;; << jo, string[address, length], word[address, length] --
   ;;    jo, string[address, length] >>
   xx dup2
   xx find_syntax, false?branch, 3
   xx   execute_jo
   xx   end
   xx dup2
   xx V__jo_link__core
   xx jo_link__find_jo, false?branch, 5
   xx   xxswapx, drop2 ;; drop word
   xx   jojo_area__stay
   xx   end
   xx write_undefined_word_report__for_make_jojo
   xx write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo

define_function "write-undefined-word-report,for-make-jojo", write_undefined_word_report__for_make_jojo
   ;; << -- >>
   xx literal, string$undefined_word_report__for_make_jojo
   xx literal, length$undefined_word_report__for_make_jojo
   xx write_string
   xx end

string$undefined_word_report__for_make_jojo:
   db "* (make-jojo) meets undefined word : "
.end:
length$undefined_word_report__for_make_jojo = (.end - string$undefined_word_report__for_make_jojo)

define_function "make-jojo", make_jojo
   ;; << jo, string[address, length] -- >>
   xx local_variable_table__clear
   xx V__rule_set__make_jojo, push_syntax_stack
   xx make_jojo__loop
   xx drop_syntax_stack
   xx end

define_function "make-jojo,loop", make_jojo__loop
   ;; << jo, string[address, length] -- >>
   xx dup2, space_string?, false?branch, 4
   xx   drop2, drop
   xx   end
   xx dup2
   xx string_tail__word
   xx xxswapxx
   xx string_head__word
   ;; << tail[address, length], head[address, length] >>
   xx make_jojo__dispatch_syntax_word
   xx tail_call, make_jojo__loop

define_exception "!undo-make-jojo", !undo_make_jojo
   xx exception_reset_stack, !undo_make_jojo
   ;; << old V__current_free_address__string_area
   ;;    old V__current_free_address__jojo_area
   ;;    old V__jo_link__core
   ;;    string[address, length]
   ;;    -- >>

   xx drop_syntax_stack

   xx literal, string$undo_make_jojo_report
   xx literal, length$undo_make_jojo_report
   xx write_string

   xx write_string
   xx literal, 10, write_byte
   xx literal, ';', write_byte
   xx literal, 10, write_byte

   xx address, V__jo_link__core, save
   xx address, V__current_free_address__jojo_area, save
   xx address, V__current_free_address__string_area
   xx save
   xx end

string$undo_make_jojo_report:
   db "  the following jojo is not made :"
   db 10
   db ": "
.end:
length$undo_make_jojo_report = (.end - string$undo_make_jojo_report)

define_function "define-function", CICADA__define_function
   ;; << string[address, length] -- >>
   xx V__current_free_address__string_area, xxswapx
   xx V__current_free_address__jojo_area, xxswapx
   xx V__jo_link__core, xxswapx
   xx dup2
   ;; << old V__current_free_address__string_area
   ;;    old V__current_free_address__jojo_area
   ;;    old V__jo_link__core
   ;;    string[address, length] >>
   xx prepare_for
   xx   exception_head
   xx   !undo_make_jojo
   xx   end

   ;; << string[address, length] >>
   xx V__current_free_address__string_area
   xx   jojo_area__stay
   xx dup2, string_head__word
   xx   string_area__stay

   xx V__jo_link__core
   xx jo_to_link
   xx   jojo_area__stay

   xx V__current_free_address__jojo_area
   xx dup, address, V__jo_link__core, save

   xx literal, explain$function
   xx   jojo_area__stay

   xx xxswapx
   xx string_tail__word
   xx make_jojo

   xx drop2
   xx drop
   xx drop
   xx drop
   xx end

define_function "define-variable,with-tos", CICADA__define_variable__with_tos
   ;; << variable, string[address, length] -- >>
   xx literal, 1
   xx   jojo_area__stay

   xx V__current_free_address__string_area
   xx   jojo_area__stay
   xx dup2, string_head__word
   xx   string_area__stay

   xx V__jo_link__core
   xx jo_to_link
   xx   jojo_area__stay

   xx V__current_free_address__jojo_area
   xx address, V__jo_link__core
   xx save

   xx literal, explain$variable
   xx   jojo_area__stay

   xx drop2
   xx jojo_area__stay
   xx end

size$local_jo = 1024 * 1024 * jo_size

address$local_jo labeling
   preserve size$local_jo

current_free_address$local_jo:
   xx address$local_jo

define_primitive_function "local-data-allocate,jo", local_data_allocate__jo
   ;; << number -- >>
   pop_argument_stack rax
   imul rax, jo_size
   add [current_free_address$local_jo], rax
   next

match =64bit, machine {

define_primitive_function "n-fetch,local-jo", n_fetch__local_jo
   ;; << offset, n -- value-1, ..., value-n >>
   mov rbx, [pointer$return_stack - (2 * jo_size)]

   pop_argument_stack rcx
   pop_argument_stack rdx
   add rbx, rdx
.loop:
   mov rax, [rbx]
   push_argument_stack rax
   add rbx, jo_size
   loop .loop
   next

define_primitive_function "n-save,local-jo", n_save__local_jo
   ;; << value-n, ..., value-1, offset, n -- >>
   mov rbx, [pointer$return_stack - (2 * jo_size)]

   pop_argument_stack rcx
   pop_argument_stack rdx
   add rbx, rdx
     mov rax, jo_size
     imul rax, rcx
     add rbx, rax
     ;; for address is based on 0
     ;; but n is based on 1
     sub rbx, jo_size
.loop:
   pop_argument_stack rax
   mov [rbx], rax
   sub rbx, jo_size
   loop .loop
   next

}

match =32bit, machine {

define_primitive_function "n-fetch,local-jo", n_fetch__local_jo
   ;; << offset, n -- value-1, ..., value-n >>
   mov rax, [pointer$return_stack]
   mov rbx, [rax - (2 * jo_size)]

   pop_argument_stack rcx
   pop_argument_stack rdx
   add rbx, rdx
.loop:
   mov rax, [rbx]
   push_argument_stack rax
   add rbx, jo_size
   loop .loop
   next

define_primitive_function "n-save,local-jo", n_save__local_jo
   ;; << value-n, ..., value-1, offset, n -- >>
   mov rax, [pointer$return_stack]
   mov rbx, [rax - (2 * jo_size)]

   pop_argument_stack rcx
   pop_argument_stack rdx
   add rbx, rdx
     mov rax, jo_size
     imul rax, rcx
     add rbx, rax
     ;; for address is based on 0
     ;; but n is based on 1
     sub rbx, jo_size
.loop:
   pop_argument_stack rax
   mov [rbx], rax
   sub rbx, jo_size
   loop .loop
   next

}

size$local_variable_table = 100 * 1024

address$local_variable_table labeling
   preserve size$local_variable_table

border$local_variable_table:
   xx address$local_variable_table

offset$local_variable_table:
   xx 0

define_function "local-variable-table,clear", local_variable_table__clear
   ;; << -- >>
   xx literal, address$local_variable_table
   xx literal, border$local_variable_table, save
   xx literal, 0
   xx literal, offset$local_variable_table, save
   xx end

define_function "local-variable-table,insert", local_variable_table__insert
   ;; << string[address, length] -- offset >>

   ;; leave offset
   xx literal, offset$local_variable_table, fetch
   xx   xxtuckx ;; return value
   xx literal, border$local_variable_table, fetch, save
   xx V__jo_size
   xx literal, border$local_variable_table, add_save

   ;; update offset$local_variable_table
   xx dup2
   xx   count_front_colon
   xx   V__jo_size, multiple
   xx   literal, offset$local_variable_table, add_save

   ;; leave length
   xx dup
   xx literal, border$local_variable_table, fetch, save
   xx V__jo_size
   xx literal, border$local_variable_table, add_save

   xx tuck ;; for to update border$local_variable_table

   ;; leave string
   xx literal, border$local_variable_table, fetch
   xx string_to_buffer!

   ;; update border$local_variable_table
   xx literal, border$local_variable_table, add_save

   xx end

cursor$local_variable_table:
   xx address$local_variable_table

define_function "local-variable-table,find", local_variable_table__find
   ;; << string[address, length]
   ;;    -- offset, true
   ;;    -- false >>
   xx literal, address$local_variable_table
   xx literal, cursor$local_variable_table, save
   xx local_variable_table__find__loop
   xx end

define_function "local-variable-table,find,loop", local_variable_table__find__loop
   ;; << string[address, length]
   ;;    -- offset, true
   ;;    -- false >>
   xx literal, cursor$local_variable_table, fetch
   xx literal, border$local_variable_table, fetch
   xx greater_or_equal?, false?branch, 4
   xx   drop2
   xx   false
   xx   end
   xx dup2
   xx literal, cursor$local_variable_table, fetch
   xx   V__jo_size, addition
   xx   V__jo_size, addition ;; address of string
   xx literal, cursor$local_variable_table, fetch
   xx   V__jo_size, addition
   xx   fetch ;; length of string
   xx string_equal?, false?branch, 8
   xx   drop2
   xx   literal, cursor$local_variable_table, fetch
   xx     fetch ;; offset
   xx   true
   xx   end
   xx literal, cursor$local_variable_table, fetch
   xx   V__jo_size, addition
   xx   fetch ;; length of string
   xx V__jo_size, addition
   xx V__jo_size, addition
   xx literal, cursor$local_variable_table, add_save
   xx tail_call, local_variable_table__find__loop

define_function "count-front-colon", count_front_colon
   ;; << string[address, length] -- number >>
   xx literal, 0 ;; counter
   xx count_front_colon__loop
   xx end

define_function "count-front-colon,loop", count_front_colon__loop
   ;; << string[address, length], counter -- number >>
   xx over, zero?, false?branch, 4
   xx   xxswapx, drop2
   xx   end
   xx xxoverx, string_head__byte
   xx literal, ':', equal?, false?, false?branch, 4
   xx   xxswapx, drop2
   xx   end
   xx add1, xxswapx
   xx string_tail__byte, xswapxx
   xx tail_call, count_front_colon__loop

define_function "local-variable-fetch-string?", local_variable_fetch_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, addition, sub1
   xx fetch_byte, literal, ':'
   xx equal?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, count_front_colon
   xx dup, literal, 0, greater_than?, false?, false?branch, 5
   xx   drop, drop2, false
   xx   end
   xx subtraction
   xx swap, drop
   xx literal, 0, greater_than?
   xx end

define_function "syntax,local-variable-fetch,make-jojo", syntax__local_variable_fetch__make_jojo
   ;; << string[address, length], word[address, length] --
   ;;    string[address, length] >>
   xx dup2
   xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
   ;;   literal, <offese>, literal, n, n_fetch__local_jo
   xx     literal, literal
   xx       jojo_area__stay
   ;;     offset
   xx       jojo_area__stay
   xx     literal, literal
   xx       jojo_area__stay
   ;;     n
   xx     count_front_colon
   xx       jojo_area__stay
   xx     literal, n_fetch__local_jo
   xx       jojo_area__stay
   xx   end
.not_found:
   xx write_local_variable_not_bound_report
   xx write_string
   xx literal, 10, write_byte
   xx !undo_make_jojo

define_function "write-local-variable-not-bound-report", write_local_variable_not_bound_report
   xx literal, string$local_variable_not_bound_report
   xx literal, length$local_variable_not_bound_report
   xx write_string
   xx end

string$local_variable_not_bound_report:
   db "* local-variable not bound : "
.end:
length$local_variable_not_bound_report = (.end - string$local_variable_not_bound_report)

define_function "local-variable-save-string?", local_variable_save_string?
   ;; << string[address, length] -- bool >>
   xx dup, zero?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, addition, sub1
   xx fetch_byte, literal, ':'
   xx equal?, false?branch, 4
   xx   drop2, false
   xx   end
   xx dup2, string_head__byte
   xx literal, '>', equal?, false?, false?branch, 4
   xx   drop2, false
   xx   end
   xx string_tail__byte
   xx dup2, count_front_colon
   xx dup, literal, 0, greater_than?, false?, false?branch, 5
   xx   drop, drop2, false
   xx   end
   xx subtraction
   xx swap, drop
   xx literal, 0, greater_than?
   xx end

define_function "syntax,local-variable-save,make-jojo", syntax__local_variable_save__make_jojo
   ;; << string[address, length], word[address, length] --
   ;;    string[address, length] >>
   xx string_tail__byte
   xx dup2
   xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
   ;;   literal, <offese>, literal, n, n_save__local_jo
   xx     literal, literal
   xx       jojo_area__stay
   ;;     offset
   xx       jojo_area__stay
   xx     literal, literal
   xx       jojo_area__stay
   ;;     n
   xx     count_front_colon
   xx       jojo_area__stay
   xx     literal, n_save__local_jo
   xx       jojo_area__stay
   xx   end
.not_found:
   xx dup2
   xx local_variable_table__insert
   xx xxswapx
   xx count_front_colon
   ;; literal, <number>, local_data_allocate__jo
   xx   literal, literal
   xx     jojo_area__stay
   ;;   number of jo
   xx     dup, jojo_area__stay
   xx   literal, local_data_allocate__jo
   xx     jojo_area__stay
   ;; literal, <offese>, literal, n, save_local_data
   xx   literal, literal
   xx     jojo_area__stay
   ;;   offset
   xx   swap
   xx     jojo_area__stay
   xx   literal, literal
   xx     jojo_area__stay
   ;;   n
   xx     jojo_area__stay
   xx   literal, n_save__local_jo
   xx     jojo_area__stay
   xx end

size$local_byte = 1024 * 1024 * 6

address$local_byte labeling
   preserve size$local_byte

current_free_address$local_byte:
   xx address$local_byte

define_primitive_function "allocate-local-memory", allocate_local_memory
   ;; << size -- address >>
   pop_argument_stack rbx
   mov rax, [current_free_address$local_byte]
   push_argument_stack rax
   add [current_free_address$local_byte], rbx
   next

string$string_to_syscall_string:
   times 256 db 0

define_function "string->syscall-string", string_to_syscall_string
   ;; << string[address, length] -- syscall-string[address] >>
   xx dup
   xx   literal, string$string_to_syscall_string
   xx   addition
   xx   literal, 0
   xx   swap, save_byte
   xx literal, string$string_to_syscall_string
   xx string_to_buffer!
   xx literal, string$string_to_syscall_string
   xx end

string$string_to_syscall_string_2:
   times 256 db 0

define_function "string->syscall-string-2", string_to_syscall_string_2
   ;; << string[address, length] -- syscall-string[address] >>
   xx dup
   xx   literal, string$string_to_syscall_string_2
   xx   addition
   xx   literal, 0
   xx   swap, save_byte
   xx literal, string$string_to_syscall_string_2
   xx string_to_buffer!
   xx literal, string$string_to_syscall_string_2
   xx end

match =linux =64bit, platform machine {

define_primitive_function "syscall", CICADA__syscall
   ;; << ..., argument2, argument1,
   ;;    syscall-number,
   ;;    number-of-arguments
   ;;    -- return-value >>
   pop_argument_stack rax
   cmp rax, 0
   je __syscall_with_0
   cmp rax, 1
   je __syscall_with_1
   cmp rax, 2
   je __syscall_with_2
   cmp rax, 3
   je __syscall_with_3
   cmp rax, 4
   je __syscall_with_4
   cmp rax, 5
   je __syscall_with_5
   cmp rax, 6
   je __syscall_with_6
   jmp __syscall_with_too_many

__syscall_with_0:
   pop_argument_stack linux64_sys_n_rax
   syscall
   push_argument_stack rax
   next

__syscall_with_1:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   syscall
   push_argument_stack rax
   next

__syscall_with_2:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   pop_argument_stack linux64_sys_2_rsi
   syscall
   push_argument_stack rax
   next

__syscall_with_3:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   pop_argument_stack linux64_sys_2_rsi
   pop_argument_stack linux64_sys_3_rdx
   syscall
   push_argument_stack rax
   next

__syscall_with_4:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   pop_argument_stack linux64_sys_2_rsi
   pop_argument_stack linux64_sys_3_rdx
   pop_argument_stack linux64_sys_4_r10
   syscall
   push_argument_stack rax
   next

__syscall_with_5:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   pop_argument_stack linux64_sys_2_rsi
   pop_argument_stack linux64_sys_3_rdx
   pop_argument_stack linux64_sys_4_r10
   pop_argument_stack linux64_sys_5_r9
   syscall
   push_argument_stack rax
   next

__syscall_with_6:
   pop_argument_stack linux64_sys_n_rax
   pop_argument_stack linux64_sys_1_rdi
   pop_argument_stack linux64_sys_2_rsi
   pop_argument_stack linux64_sys_3_rdx
   pop_argument_stack linux64_sys_4_r10
   pop_argument_stack linux64_sys_5_r9
   pop_argument_stack linux64_sys_6_r8
   syscall
   push_argument_stack rax
   next

__syscall_with_too_many:
   call __exit_with_six

}

match =linux =32bit, platform machine {

define_primitive_function "syscall", CICADA__syscall
   ;; << ..., argument2, argument1,
   ;;    syscall-number,
   ;;    number-of-arguments
   ;;    -- return-value >>
   pop_argument_stack rax
   cmp rax, 0
   je __syscall_with_0
   cmp rax, 1
   je __syscall_with_1
   cmp rax, 2
   je __syscall_with_2
   cmp rax, 3
   je __syscall_with_3
   cmp rax, 4
   je __syscall_with_4
   cmp rax, 5
   je __syscall_with_5
   jmp __syscall_with_too_many

__syscall_with_0:
   pop_argument_stack linux32_sys_n_eax
   syscall
   push_argument_stack rax
   next

__syscall_with_1:
   pop_argument_stack linux32_sys_n_eax
   pop_argument_stack linux32_sys_1_ebx
   syscall
   push_argument_stack rax
   next

__syscall_with_2:
   pop_argument_stack linux32_sys_n_eax
   pop_argument_stack linux32_sys_1_ebx
   pop_argument_stack linux32_sys_2_ecx
   syscall
   push_argument_stack rax
   next

__syscall_with_3:
   pop_argument_stack linux32_sys_n_eax
   pop_argument_stack linux32_sys_1_ebx
   pop_argument_stack linux32_sys_2_ecx
   pop_argument_stack linux32_sys_3_edx
   syscall
   push_argument_stack rax
   next

__syscall_with_4:
   pop_argument_stack linux32_sys_n_eax
   pop_argument_stack linux32_sys_1_ebx
   pop_argument_stack linux32_sys_2_ecx
   pop_argument_stack linux32_sys_3_edx
   pop_argument_stack linux32_sys_4_esi
   syscall
   push_argument_stack rax
   next

__syscall_with_5:
   pop_argument_stack linux32_sys_n_eax
   pop_argument_stack linux32_sys_1_ebx
   pop_argument_stack linux32_sys_2_ecx
   pop_argument_stack linux32_sys_3_edx
   pop_argument_stack linux32_sys_4_esi
   pop_argument_stack linux32_sys_5_edi
   syscall
   push_argument_stack rax
   next

__syscall_with_too_many:
   call __exit_with_six

}

define_variable "*explainer,function*", CICADA__explain$function
   xx explain$function

define_variable "*explainer,exception*", CICADA__explain$exception
   xx explain$exception

define_variable "*explainer,variable*", CICADA__explain$variable
   xx explain$variable

define_function "platform", the_platform
   xx literal, string$platform
   xx literal, length$platform
   xx end

string$platform:

match =linux, platform {
   db "linux"
}

.end:
length$platform = (.end - string$platform)

define_variable "*un-initialized-memory*", V__un_initialized_memory
  xx address$un_initialized_memory

define_variable "*size,un-initialized-memory*", V__size__un_initialized_memory
  xx size$un_initialized_memory

define_variable "*current-free-address,un-initialized-memory*", V__current_free_address__un_initialized_memory
  xx current_free_address$un_initialized_memory

define_variable "*current-free-address,string-area*", V__current_free_address__string_area
   xx current_free_address$string_area

last_link = link

size$un_initialized_memory = 88 * 1024 * 1024 ;; (byte)

match =linux, platform {

segment readable writeable
address$un_initialized_memory:
   rb size$un_initialized_memory

}
