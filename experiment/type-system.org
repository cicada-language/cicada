#+TITLE:  type system experiment
#+AUTHOR: 謝宇恆 / XIE Yuheng

* ===================================
* pattern match
  #+begin_src cicada-nymph
  : maybe ({type #type} :type -> type)
    nothing ({type #type} -> :type maybe)
    just ({type #type} :type -> :type maybe)
  ; define-type

  : maybe-apply
    ({type #type #type'}
     :type' (:type -> :type') :type maybe -> :type')
    * :default :function nothing
    | :default
    * :default :function :value just
    | :value :function apply
  ; define-function
  #+end_src
* proof
** red-black-tree
   #+begin_src cicada-nymph
   : red-black-tree
     import
       preliminaries
     assume
       key (-> type)
       compare (key key -> order)
       value (-> type)
   ; define-module

   : color (-> type)
     red (-> color)
     black (-> color)
   ; define-type

   : tree (-> type)
     empty (-> tree)
     node (tree tree color key value -> tree)
   ; define-type

   : balance
     (tree -> tree)
     * :a
       :b red ::x node
                    :c red ::y node
                                 :d black ::z node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *              :a
       :b
       :c red ::y node red ::x node
                                 :d black ::z node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *                           :a
       :b
       :c red ::y node
                    :d red ::z node black ::x node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *                           :a
                    :b
       :c
       :d red ::z node red ::y node black ::x node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     * :already-balanced-tree
     | :already-balanced-tree
   ; define-function

   : insert,help
     (tree key value -> tree)
     * empty :key :value
     | empty empty
       red :key :value node
     * :left :right
       :color :key :value node
       :key' :value'
     | :key :key' compare
       * equal
       | :left
         :right
         :color :key' :value' node
       * less
       | :left :key' :value' insert,help
         :right
         :color :key :value node balance
       * greater
       | :left
         :right :key' :value' insert,help
         :color :key :value node balance
   ; define-function

   : blacken-root
     (tree -> tree)
     * empty
     | empty
     * :left :right :color ::key-value node
     | :left :right black ::key-value node
   ; define-function

   : insert
     (tree key value -> tree)
     insert,help
     blacken-root
     end
   ; define-function

   : black-high? (tree natural -> type)
     black-high?empty
     (--------------->
      empty 1 black-high?)
     black-high?red
     ({natural #high tree #left #right key value ##key-value}
      :left :high black-high?
      :right :high black-high?
      ----------------------->
      :right :high red ::key-value node :high black-high?)
     black-high?black
     ({natural #high tree #left #right key value ##key-value}
      :left :high black-high?
      :right :high black-high?
      ----------------------->
      :right :high black ::key-value node :high add1 black-high?)
   ; introduce-axiom

   : black-high?blacken-root
     ({tree #tree natural #high}
      :tree :high black-high?
      ---------------------->
      natural #high'
      :tree blacken-root :high' black-high?)
     * black-high?empty
     | 1 black-high?empty
     * :black-high?left :black-high?right black-high?red
     | _ :black-high?left :black-high?right black-high?black
     * :black-high?left :black-high?right black-high?black
     | _ :black-high?left :black-high?right black-high?black
   ; proof-theorem

   : black-high?example
     assume
       k1 (-> key)
       k2 (-> key)
       v1 (-> value)
       v2 (-> value)
     : t (-> tree)
       empty empty red k1 v1 node
                            empty black k2 v2 node
     ; define-function
     : black-high?t
       (-------------->
        t 2 black-high?)
       black-high?empty
       black-high?empty
       black-high?red
       black-high?empty
       black-high?black
     ; proof-theorem
   ; define-sub-module

   : black-high?balance,red
     ({tree #left #right key value ##key-value natural #high}
      :left :high black-high?
      :right :high black-high?
      ----------------------->
      :left :right red ##key-value balance :high add1 black-high?)
     * ?
     | ?
   ; proof-theorem

   : black-high?balance,black
     ({tree #left #right key value ##key-value natural #high}
      :left :high black-high?
      :right :high black-high?
      ----------------------->
      :left :right black ##key-value balance :high add1 black-high?)
     * ?
     | ?
   ; proof-theorem

   : black-high?insert,help
     ({tree #tree key value ##key-value natural #high}
      :tree :high black-high?
      ---------------------->
      natural #high'
      :tree ::key-value insert,help :high black-high?)
     * ?
     | ?
   ; proof-theorem

   : black-high?insert
     ({tree #tree key value ##key-value natural #high}
      :tree :high black-high?
      ---------------------->
      natural #high'
      :tree ::key-value insert :high' black-high?)
     black-high?insert,help
     black-high?blacken-root
     end
   ; proof-theorem
   #+end_src
** map
   * 在則式中
     當出現
     (...
      (:type -> :type') #function
      ...) 時
     :function (-> (:type -> :type'))
   #+begin_src cicada-nymph
   : map
     ({type #type #type'}
      (:type -> :type') #function
       :type list -> :type' list)
     * :function null
     | null
     * :function :car :cdr cons
     | :car :function apply
       :function :cdr map cons
   ; define-function

   : list-length? ({type #type} :type list natural -> type)
     list-length?null
     (---------->
      null 0 list-length?)
     list-length?cons
     ({natural #length
       :type #car
       :type list #cdr}
      :cdr :length list-length?
      ------------------------->
      :car :cdr cons :length add1 list-length?)
   ; introduce-axiom

   : list-length?map
     ({type #type #type'
       (:type -> :type') #function
       :type list #list natural #length}
      :list :length list-length?
      -------------------------->
      :list :function map :length list-length?)
     * list-length?null
     | list-length?null
     * :inductive-hypothesis list-length?cons
     | :inductive-hypothesis list-length?map list-length?cons
   ; proof-theorem

   << explicit argument >>

   : list-length? ({type #type} :type list natural -> type)
     list-length?null
     (------------->
      null 0 list-length?)
     list-length?cons
     (natural #length
      :type #car
      :type list #cdr
      :cdr :length list-length?
      ------------------------->
      :car :cdr cons :length add1 list-length?)
   ; introduce-axiom

   : list-length?map
     ({type #type #type'}
      (:type -> :type') #function
      :type list #list natural #length
      :list :length list-length?
      -------------------------->
      :list map :function apply :length list-length?)
     * :function null 0
       list-length?null
     | list-length?null
     * :function :car :cdr cons :length add1
       :length
       :car
       :cdr
       :inductive-hypothesis
       list-length?cons
     | :length
       :car :function apply
       :cdr :function map
       :function :cdr :length :inductive-hypothesis list-length?map
       list-length?cons
   ; proof-theorem
   #+end_src
* type class
** equal & order
   #+begin_src cicada-nymph
   : equal-able < type
     equal??
     ({equal-able #value} :value :value -> (true | false))
   ; define-class

   : not-equal??
     ({equal-able #value} :value :value -> (true | false))
     equal?? not
     end
   ; define-abstruct-function

   : natural (-> equal-able)
     ><><><
   ; define-instance

   : order-able < equal-able
     ({order-able #value} :value :value -> (less-than | equal | greater-than))
   ; define-class

   : sort
     ({order-able #value} :value list -> :value list)
     ><><><
   ; define-function
   #+end_src
** functor
   #+begin_src cicada-nymph
   : map-able < (type -> type) << have-functor >>
   ; define-class

   : function-map
     ({type #type #type'} {map-able #functor}
      (:type -> :type')
      :type :functor apply -> :type' :functor apply)
   ; define-method

   : functor-map
     ({type #type #type'} {map-able #functor}
      (:type -> :type') ->
      (:type :functor apply -> :type' :functor apply))
   ; define-method

   : (list -> list) (-> map-able)
   ; define-instance

   : map
     ({(list -> list) #functor}
       (list -> list) list :functor apply -> list :functor apply)
     * :function null
     | null
     * :function :car :cdr cons
     | :car :function apply
       :function :cdr map cons
   ; define-function
   #+end_src
* ===================================
