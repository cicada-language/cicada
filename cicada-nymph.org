#+TITLE:  cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** more documentations on the nature of the language and the interpreter
** proper exception handling
** more debug functions
** "if & else & then" in cicada-nymph itself
* ===================================
* note
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
** threaded-code interpreter
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
** the order of development
   * indirect-threaded-code interpreter
     1. macro about argument_stack & return_stack
     2. macro about jo & jojo
     3. macro about next
     4. the way to do memory allocation
     5. begin_to_interpret_threaded_code
     6. little_test
     7. special primitive function
   * basic-REPL as postfix-notation function executer
     1. write-byte & read-byte
     2. read-word & write-string
     3. string->integer & find & execute-word & basic-REPL
   * define & make things into memory
     1. ":" and ";" are used to read a string of words for compiler
        [looks like bar-ket but special]
     2. "<< >>" as the only way todo comment
** different from the re-designed cicada-language
   * simplifications are for teaching purpose only
   * first and foremost
     function programming will NOT be supported will in this implementation
   * a helper function must be defined before it is used
   * no mixfix-notation
     * function call is "function" instead of "(function)"
     * no such thing like
       1 2 (add) = 1 (add 2) = (add 1 2)
   * no named local argument
     * thus no inited local argument
   * no title-name-table
     * and single name space
   * no type
     * no type inference
     * no dynamic type tag
     * no static type declaration
   * global linked-list for naming
     * not hash-table
     * in classical forth
       the linked-list of jo is called dictionary
   * no dynamic-memory-management
     * no garbage-collectior
   * about comment
     * the comment of the argument & return value of function
       is allowed to be written in free style normal comment
** convention
*** naming convention
    * a predicate of a type
      which denotes a subtype of that type
      uses that type as postfix
      such as
      "space-char?"
    * a function of a type
      uses that type as prefix
      such as
      "string-reverse"
      "string-equal?"
    * side-effect of structured data is postfixed by "!"
*** convention in assembly code
    * using underline to compose big word from small words
    * using "$" as prefix and postfix separator
    * indentation level = 3
    * naming convention of jo
      | convention   | jo type  |
      |--------------+----------|
      | prefix "V__" | variable |
      | prefix "M__" | macro    |
    * but I use
      1. "zero" instead of "V__zero"
      2. "true" instead of "V__true"
*** convention in cicada-nymph code
    * using dash to compose big word from small words
    * using "," as prefix and postfix separator
    * indentation style = free
    * words are separated by space
      except for bar-ket
      every bar-ket is viewed as a word
*** syntax of cicada-nymph
    * syntax &  semantic
      | syntax          | semantic                |
      |-----------------+-------------------------|
      | borderfix "* *" | variable                |
      | borderfix "+ +" | [maybe use]             |
      | bar-ket ( )     | not use                 |
      | bar-ket [ ]     | not use                 |
      | bar-ket { }     | macro call              |
      |                 | (for macros of which    |
      |                 | the number of           |
      |                 | arguments is not fix)   |
      | prefix "!"      | exception               |
      | postfix "!"     | some of the side-effect |
      | postfix "?"     | predicate               |
    * but I use
      1. "true" instead of "*true*"
      2. "false" instead of "*false*"
* -----------------------------------
* prolog
** include linux header
   #+begin_src fasm :tangle cicada-nymph.fasm
   include "include/linux-header.inc"
   #+end_src
** format header
   #+begin_src fasm :tangle cicada-nymph.fasm
   format elf64 executable 3
   #+end_src
** entry
   #+begin_src fasm :tangle cicada-nymph.fasm
   entry begin_to_interpret_threaded_code
   segment readable executable writeable
   #+end_src
* -----------------------------------
* macro in assembly code
** misc
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate
   #+end_src
** bead_size
   * 64-bits
   * note that how "xx" is used as "dq" in a 64-bits version implementation
     when one wishs to port the implementation to 32-bits machine
     just use "xx equ dd"
   #+begin_src fasm :tangle cicada-nymph.fasm
   bead_size = 8 ;; (byte)
   xx equ dq
   #+end_src
** argument_stack & return_stack
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   ;; =================================
   define pointer$argument_stack   r15
   define pointer$return_stack     r14
   ;; =================================

   macro push_argument_stack register {
      mov [pointer$argument_stack], register
      add pointer$argument_stack, bead_size
      }
   macro pop_argument_stack register {
      sub pointer$argument_stack, bead_size
      mov register, [pointer$argument_stack]
      }

   macro push_return_stack register {
      mov [pointer$return_stack], register
      add pointer$return_stack, bead_size
      }
   macro pop_return_stack register {
      sub pointer$return_stack, bead_size
      mov register, [pointer$return_stack]
      }
   #+end_src
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle cicada-nymph.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** exit
   * this makes 0 a very special jo
     one important effect is that
     #+begin_src fasm
     xx literal, 0
     #+end_src
     is not allowed
   #+begin_src fasm :tangle cicada-nymph.fasm
   exit = 0
   #+end_src
** next
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro next {
      pop_return_stack rbx
        mov rax, qword[rbx]
      add rbx, bead_size
        mov rcx, qword[rbx]
        test rcx, rcx
        jz @f
      push_return_stack rbx
   @@:  jmp qword[rax]
   }
   #+end_src
** note play with jo & jojo
   1. if we have
      * the following one jojo in the return-stack
        #+begin_src picture
        - [ (square) ]
            (square)
            (exit)
        #+end_src
      * and 2 in the argument-stack
        denoted by << 2 >>
      * and as following
        the jo "square" is defined
        #+begin_src fasm
        define_function "square", square
           ;; << number -- square of number >>
           xx dup
           xx multiple
           xx exit
        #+end_src
   2. when "next" is called
      * "next" moves the jojo on top of return-stack
        #+begin_src picture
            (square)
        - [ (square) ]
            (exit)
        #+end_src
      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "square"
        "explain$function" is called
        to help to explain the meaning of the function-jo "square"
        the function body of the jo "square"
        is pushed to return-stack as a new jojo
        #+begin_src picture
            (square)
        - [ (square) ] - [ (dup) ]
            (exit)         (multiple)
                           (exit)
        #+end_src
   3. "next" is called again
      * "next" moves the jojo on top of return-stack
        #+begin_src picture
            (square)       (dup)
        - [ (square) ] - [ (multiple) ]
            (exit)         (exit)
        #+end_src
      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "dup"
        as a primitive-function-jo
        "dup" explains itself
        the argument-stack becomes << 2, 2 >>
   4. "next" is called again
      * "next" moves the jojo on top of return-stack
        by the ending "exit"
        "next" recognizes that
        it is the last jo in the jojo
        so "next" pops the jojo out of return-stack
        #+begin_src picture
            (square)
        - [ (square) ]
            (exit)
        #+end_src
      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "multiple"
        a primitive-function-jo again
        the argument-stack becomes << 4 >>
   5. "next" is called again
      * "next" moves the jojo on top of return-stack
        by the ending "exit"
        "next" recognizes that
        it is the last jo in the jojo
        so "next" pops the jojo out of return-stack
        the return-stack is empty now
        #+begin_src picture
        - [  ]
        #+end_src
      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "square"
        "explain$function" is called
        to help to explain the meaning of the function-jo "square"
        the function body of the jo "square"
        is pushed to return-stack as a new jojo
        #+begin_src picture
        - [ (dup) ]
            (multiple)
            (exit)
        #+end_src
   6. "next"
      * return-stack
        #+begin_src picture
            (dup)
        - [ (multiple) ]
            (exit)
        #+end_src
      * argument-stack
        << 4, 4 >>
   7. "next"
      * return-stack
        #+begin_src picture
        - [  ]
        #+end_src
      * argument-stack
        << 16 >>
   8. return-stack is empty now
      it is clear that
      if "next" is called again
      an error will occur
      actually
      in real situation
      return-stack will never be empty
      at the end of the return-stack
      there is a tail recursive function [a loop]
      which protects the return-stack from being empty
** note let us do a little review
   1. at the beginning
      * return-stack
        #+begin_src picture
        - [ (square) ]
            (square)
            (exit)
        #+end_src
      * argument-stack
        << 2 >>
   2. next
      * return-stack
        #+begin_src picture
            (square)
        - [ (square) ] - [ (dup) ]
            (exit)         (multiple)
                           (exit)
        #+end_src
   3. next
      * return-stack
        #+begin_src picture
            (square)       (dup)
        - [ (square) ] - [ (multiple) ]
            (exit)         (exit)
        #+end_src
      * argument-stack
        << 2, 2 >>
   4. next
      * return-stack
        #+begin_src picture
            (square)
        - [ (square) ]
            (exit)
        #+end_src
      * argument-stack << 4 >>
   5. next
      * return-stack
        #+begin_src picture
        - [ (dup) ]
            (multiple)
            (exit)
        #+end_src
   6. next
      * return-stack
        #+begin_src picture
            (dup)
        - [ (multiple) ]
            (exit)
        #+end_src
      * argument-stack
        << 4, 4 >>
   7. next
      * return-stack
        #+begin_src picture
        - [  ]
        #+end_src
      * argument-stack
        << 16 >>
   8. it is really simple
      ^-^
      is it not ?
* -----------------------------------
* jo
** ----------------------------------
** link
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; initial link to point to 0 (as null)
   link = 0
   #+end_src
** primitive_string_heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$primitive_string_heap = 100 * 1024 ;; (byte)

   address$primitive_string_heap:
      times size$primitive_string_heap db 0

   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** make_primitive_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro make_primitive_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dw (.end$string - .start$string)
      load .length word from (.end$string)
   end virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      end virtual
      store byte .char at (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   end repeat

   }
   #+end_src
** ----------------------------------
** note
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
** define_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; here follows a jojo as function-body

      }
   #+end_src
** explain$function
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0 or 1
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$function:
      add rax, bead_size
      push_return_stack rax
      next
   #+end_src
** ----------------------------------
** note
   * the same as function
     we need to redefine it
     for the value of explainer
     is used to decide the type of the jo
** define_macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_macro string, jo {

   define_macro__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$macro

      ;; here follows a jojo as function-body

      }
   #+end_src
** explain$macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$macro:
      add rax, bead_size
      push_return_stack rax
      next
   #+end_src
** ----------------------------------
** note
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
** define_primitive_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:

      ;; here follows assembly code
      ;; as primitive function body

      }
   #+end_src
** ----------------------------------
** note
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
** define_variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; here follows a value of bead_size
      ;; only one value is allowed

      }
   #+end_src
** explain$variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$variable:
      add rax, bead_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
** ----------------------------------
** note
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
** define_exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_exception string, jo {

   define_exception__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$exception

      ;; here follows a jojo as function-body

      }
   #+end_src
** >< explain$exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$exception:
   #+end_src
** ----------------------------------
** execute-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack rax
      jmp qword [rax]
   #+end_src
** ----------------------------------
** jo->name
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->name", jo_to_name
      ;; << jo -- string[address, length] >>
      xx literal, bead_size, subtraction
      xx literal, bead_size, subtraction
      xx fetch
      xx dup
      xx   literal, 2, addition, swap
      xx fetch_two_bytes
      xx exit
   #+end_src
** jo->link
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->link", jo_to_link
      ;; << jo -- link >>
      xx literal, bead_size, subtraction
      xx exit
   #+end_src
** null-jo?
   * first jo in assembly code
     is the null of the linked list of jo
     so I call it null jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "null-jo?", null_jo?
      ;; << jo -- bool >>
      xx jo_to_link
      xx fetch
      xx zero?
      xx exit
   #+end_src
** jo->pre-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->pre-jo", jo_to_pre_jo
      ;; << jo -- pre-jo >>
      xx jo_to_link
      xx fetch
      xx literal, bead_size, addition
      xx exit
   #+end_src
** jo->type
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->type", jo_to_type
      ;; << jo -- type >>
      xx dup

      xx dup, fetch
      xx swap, subtraction, literal, 8, equal?, false?branch, 4
      xx   drop, zero
      xx   exit

      xx fetch
      xx exit
   #+end_src
** ----------------------------------
** primitive-function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "primitive-function-jo?", primitive_function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx zero?
      xx exit
   #+end_src
** function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "function-jo?", function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$function
      xx equal?
      xx exit
   #+end_src
** macro-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "macro-jo?", macro_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$macro
      xx equal?
      xx exit
   #+end_src
** variable-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "variable-jo?", variable_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$variable
      xx equal?
      xx exit
   #+end_src
** ----------------------------------
* -----------------------------------
* the story begin
** begin_to_interpret_threaded_code
   #+begin_src fasm :tangle cicada-nymph.fasm
   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented

      mov pointer$argument_stack,  address$argument_stack
      mov pointer$return_stack,    address$return_stack

      mov rax, first_jojo
      push_return_stack rax
      next


   first_jojo:
      xx basic_REPL

      ;; xx little_test
   #+end_src
** exit_with_TOS a.k.a. bye
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bye", exit_with_TOS
      pop_argument_stack sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall
   #+end_src
** little_test
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", V__little_test_number
      xx 3


   define_function "little_test", little_test

      ;;;; variable
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; 3

      ;;;; literal
      ;; xx literal, 4
      ;; xx exit_with_TOS
      ;;;; 4

      ;;;; address
      ;; xx address, V__little_test_number, fetch, add2
      ;; xx address, V__little_test_number, save
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; 5

      ;;;; write_byte
      ;; xx literal, 64, write_byte
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; @

      ;;;; read_byte
      ;; xx read_byte, write_byte
      ;; xx exit_with_TOS
      ;;;;

      ;;;; branch
      ;; xx read_byte, write_byte
      ;; xx branch, -3
      ;;;; read a string that ended by <return>
      ;;;; write the readed string
      ;;;; or we can say
      ;;;; read line and write line
      ;;;; or we can say
      ;;;; echo line

      ;;;; false?branch
      ;; xx V__false, false?branch, 9
      ;; xx   literal, 64, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx V__true, false?branch, 9
      ;; xx   literal, 65, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; A

      ;;;; read_word & write_string
      ;; xx read_word, write_string
      ;; xx literal, 10, write_byte
      ;; xx read_word_for_REPL, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; read line
      ;;;; write first two words of the line

      ;;;; string->integer
      ;; xx read_word, string_to_integer
      ;; xx exit_with_TOS
      ;;;;

      ;;;; use jo_to_name to test the macro make_primitive_string
      ;; xx literal, jo_to_name, jo_to_name, write_string
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;;

      ;;;; basic-REPL (without the ability to define function)
      ;;;; after this test
      ;;;; we will use basic-REPL to do further tests
      xx basic_REPL
      ;;;; 1 2 add .
   #+end_src
* argument_stack
** memory allocation
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * bead_size
   address$argument_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
** drop
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "drop", drop
      ;; << a -- >>
      pop_argument_stack rax
      next

   define_primitive_function "drop2", drop2
      ;; << a b -- >>
      pop_argument_stack rax
      pop_argument_stack rax
      next
   #+end_src
** dup
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "dup", dup
      ;; << a -- a a >>
      mov  rax, [pointer$argument_stack - (1 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      mov  rbx, [pointer$argument_stack - (1 * bead_size)]
      mov  rax, [pointer$argument_stack - (2 * bead_size)]
      push_argument_stack rax
      push_argument_stack rbx
      next
   #+end_src
** over
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov  rax, [pointer$argument_stack - (2 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov  rax, [pointer$argument_stack - (3 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov  rax, [pointer$argument_stack - (3 * bead_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (3 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov  rax, [pointer$argument_stack - (4 * bead_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (4 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (4 * bead_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov  rax, [pointer$argument_stack - (6 * bead_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (6 * bead_size)]
      push_argument_stack rax
      next
   #+end_src
** tuck
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tuck", tuck
      ;; << a b -- b | a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|tuck|xx", xtuckxx
      ;; << a | b c -- b c | a | b c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|x", xxtuckx
      ;; << a b | c -- c | a b | c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|xx", xxtuckxx
      ;; << a b | c d -- c d | a b | c d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   define_primitive_function "xxx|tuck|x", xxxtuckx
      ;; << a b c | d -- d | a b c | d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
** swap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack rax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
* return_stack
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * bead_size
   address$return_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
* special primitive function
** ----------------------------------
** note side-effect
   * a special primitive function
     does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
** note naming
   * the naming convention in assembly code
     of special primitive function
     is the same as it of jo
   * the name of a special primitive function
     is not exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
** ----------------------------------
** note about exit
   * note that
     the jo 0 is used as exit
     so
     #+begin_src fasm
     xx literal, 0
     #+end_src
     [and so on]
     are not allowed
** literal
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; << -- fixnum >>
      pop_return_stack rbx
        mov rax, [rbx]
        push_argument_stack rax
      add rbx, bead_size
        mov rax, [rbx]
        test rax, rax
        jz .meet_end
      push_return_stack rbx
   .meet_end:
      next
   #+end_src
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address
      ;; << -- address >>
      pop_return_stack rbx
        mov rax, [rbx]
        add rax, bead_size
        push_argument_stack rax
      add rbx, bead_size
        mov rax, [rbx]
        test rax, rax
        jz .meet_end
      push_return_stack rbx
   .meet_end:
      next
   #+end_src
** ----------------------------------
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", branch
      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, bead_size
      add rbx, rax
      ;; the following handles branching to "exit"
      mov rax, [rbx]
      test rax, rax
      jz .meet_end
      push_return_stack rbx
   .meet_end:
      next
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", false?branch
      ;; << true of false -- >>
      pop_argument_stack rax
      test rax, rax
      jnz help__false?branch__not_to_branch

      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, bead_size
      add rbx, rax
      ;; the following handles branching to "exit"
      mov rax, [rbx]
      test rax, rax
      jz .meet_end
      push_return_stack rbx
   .meet_end:
      next

   help__false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, bead_size
      mov rax, [rbx]
      test rax, rax
      jz .meet_end
      push_return_stack rbx
   .meet_end:
      next
   #+end_src
** ----------------------------------
** note usage
   #+begin_src fasm
   xx prepare_for
   xx exception_header
   xx   !exception_1
   xx   !exception_2
   xx   exit
   xx function_1
   xx function_2
   xx exit
   #+end_src
** prepare_for
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", prepare_for
      ;; << -- >>

      next
   #+end_src
** exception_header
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", exception_header
      ;; << -- >>

      next
   #+end_src
** ----------------------------------
* bool
** false & true
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "false", false
      ;; << -- false >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "true", true
      ;; << -- true >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** false? & true?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "false?", false?
      ;; << bool -- bool >>
      xx false, equal?
      xx exit

   define_function "true?", true?
      ;; << bool -- bool >>
      xx true, equal?
      xx exit
   #+end_src
** bitwise operations
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bitwise-and", bitwise_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      and [pointer$argument_stack - (1 * bead_size)], rbx
      next

   define_primitive_function "bitwise-or", bitwise_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      or  [pointer$argument_stack - (1 * bead_size)], rbx
      next

   define_primitive_function "bitwise-xor", bitwise_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      xor [pointer$argument_stack - (1 * bead_size)], rbx
      next

   define_primitive_function "bitwise-invert", bitwise_invert
      ;; << a -- invert a >>
      not qword [pointer$argument_stack - (1 * bead_size)]
      next
   #+end_src
* fixnum
** zero & one
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "zero", zero
      ;; << -- 0 >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "one", one
      ;; << -- 1 >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** zero? & one?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero?", zero?
      ;; << bool -- bool >>
      xx zero, equal?
      xx exit

   define_function "one?", one?
      ;; << bool -- bool >>
      xx one, equal?
      xx exit
   #+end_src
** add & sub & mul & div & mod & negate & power
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      inc qword [pointer$argument_stack - (1 * bead_size)]
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      add qword [pointer$argument_stack - (1 * bead_size)], 2
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      add qword [pointer$argument_stack - (1 * bead_size)], 3
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      add qword [pointer$argument_stack - (1 * bead_size)], 4
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      add qword [pointer$argument_stack - (1 * bead_size)], 8
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      dec qword [pointer$argument_stack - (1 * bead_size)]
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      sub qword [pointer$argument_stack - (1 * bead_size)], 2
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      sub qword [pointer$argument_stack - (1 * bead_size)], 3
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      sub qword [pointer$argument_stack - (1 * bead_size)], 4
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      sub qword [pointer$argument_stack - (1 * bead_size)], 8
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rax
      add qword [pointer$argument_stack - (1 * bead_size)], rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rax
      sub qword [pointer$argument_stack - (1 * bead_size)], rax
      next

   define_primitive_function "mul", multiple
      ;; << a b -- a*b >>
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next

   define_primitive_function "moddiv", moddiv
      ;; << a, b -- a mod b, quotient >>
      ;; << dividend, divisor -- remainder, quotient >>
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   define_function "divmod", divmod
      ;; << a, b -- quotient, a mod b >>
      xx moddiv, swap
      xx exit

   define_function "div", division
      ;; << a, b -- quotient >>
      xx divmod, drop
      xx exit

   define_function "mod", modulo
      ;; << a, b -- a mod b >>
      xx moddiv, drop
      xx exit

   define_function "negate", negate
      ;; << n --  -n >>
      xx zero
      xx swap, subtraction
      xx exit


   define_function "power", power
      ;; n must be nature number for now
      ;; << a, n -- a^n >>
      xx literal, 1, swap ;; leave product
      xx help__power
      xx exit

   define_function "help,power", help__power
      ;; << a, product, n -- a^n >>
      xx dup, zero?, false?branch, 5
      xx   drop, swap, drop
      xx   exit
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx help__power
      xx exit
   #+end_src
** equal & greater-than & less-than
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "equal?", equal?
      ;; << a, b -- a, b, true of false >>
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "less-than?", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-than?", greater_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   define_primitive_function "less-or-equal?", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-or-equal?", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** negative? & positive?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negative?", negative?
      ;; << integer -- bool >>
      xx zero, less_than?
      xx exit

   define_function "positive?", positive?
      ;; << integer -- bool >>
      xx negative?, false?
      xx exit
   #+end_src
* memory
  * although the following functions are all side-effect
    but I use "save" instead of "save!"
  #+begin_src fasm :tangle cicada-nymph.fasm
  ;; "save" and "fetch" default to a bead_size
  ;; the rule of "fetch2" and so on are:
  ;;   in memory:
  ;;     ||  1 : value-1  ||
  ;;     ||  1 : value-2  ||
  ;;     ||  1 : value-3  ||
  ;;     ...
  ;;   on stack:
  ;;     << value-1, value-2, value-3, ... >>
  ;; of course we have:
  ;;   fetch2 : memory=copy=>stack
  ;;   save2  : stack->memory

  define_primitive_function "save", save
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov qword[rbx], rax
     next

  define_primitive_function "save-byte", save_byte
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov byte[rbx], al
     next

  define_primitive_function "save-two-bytes", save_two_bytes
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov word [rbx], ax
     next

  define_primitive_function "save-four-bytes", save_four_bytes
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov dword [rbx], eax
     next

  define_primitive_function "n-save", n_save
     ;; << value-n, ..., value-1, address, n -- >>
     pop_argument_stack rcx
     pop_argument_stack rdx
     mov rax, bead_size
     imul rax, rcx
     add rdx, rax
     ;; for address is based on 0
     ;; but n is based on 1
     sub rdx, bead_size
  .loop:
     pop_argument_stack rax
     mov qword [rdx], rax
     sub rdx, bead_size
     loop .loop
     next

  define_function "save2", save2
     ;; << value-2, value-1, address -- >>
     xx literal, 2
     xx n_save
     xx exit

  define_primitive_function "n-save-byte", n_save_byte
     ;; << value-n, ..., value-1, address, n -- >>
     pop_argument_stack rcx
     pop_argument_stack rdx
     add rdx, rcx
     dec rdx
  .loop:
     pop_argument_stack rax
     mov byte [rdx], al
     dec rdx
     loop .loop
     next

  define_primitive_function "fetch", fetch
     ;; ( address -- value )
     pop_argument_stack  rbx
     mov rax, qword[rbx]
     push_argument_stack rax
     next

  define_primitive_function "fetch-byte", fetch_byte
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov al, byte[rbx]
     push_argument_stack rax
     next
  define_primitive_function "fetch-two-bytes", fetch_two_bytes
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov ax, word[rbx]
     push_argument_stack rax
     next

  define_primitive_function "fetch-four-bytes", fetch_four_bytes
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov eax, dword[rbx]
     push_argument_stack rax
     next

  ;;   in memory:
  ;;     ||  1 : value-1  ||
  ;;     ...
  ;;     ||  1 : value-n  ||
  define_primitive_function "n-fetch", n_fetch
     ;; << address, n -- value-1, ..., value-n >>
     pop_argument_stack  rcx
     pop_argument_stack  rdx
  .loop:
     mov rax, qword[rdx]
     push_argument_stack rax
     add rdx, bead_size
     loop .loop
     next

  define_primitive_function "n-fetch-byte", n_fetch_byte
     ;; << address, n -- byte-1, ..., byte-n >>
     pop_argument_stack  rcx
     pop_argument_stack  rdx
     xor rax, rax
  .loop:
     mov al, byte [rdx]
     push_argument_stack rax
     inc rdx
     loop .loop
     next

  define_function "fetch2", fetch2
     ;; << address -- value-1, value-2 >>
     xx literal, 2
     xx n_fetch
     xx exit

  define_primitive_function "add-save", add_save
     ;; ( number to add, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     add qword[rbx], rax
     next

  define_primitive_function "sub-save", sub_save
     ;; ( number to add, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     sub qword[rbx], rax
     next
  #+end_src
* io
** ----------------------------------
** note byte
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_input_length = 1024 * 1024

   buffer$read_byte labeling
      preserve max_input_length
   #+end_src
** write-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al
      mov sys_3_rdx, 1                 ;; max length to be write
      mov sys_2_rsi, buffer$write_byte ;; address
      mov sys_1_rdi, 1                 ;; stdout
      mov sys_n_rax, syscall_write
      syscall
      next
   #+end_src
** read-byte
   * calls the Linux read system call to fill buffer$read_byte
   * if it detects that stdin has closed
     it exits the program
     which is why when you hit C-d the system exits
   * add the teature to unread one ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   flag$unreaded_ket_char:
      xx 0

   char$unreaded_ket_char:
      xx 0

   define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
      ;; << -- bool >>
      xx literal, flag$unreaded_ket_char, fetch
      xx exit

   define_function "unread-ket-char", unread_ket_char
      ;; << char -- >>
      xx literal, char$unreaded_ket_char, save
      xx true, literal, flag$unreaded_ket_char, save
      xx exit


   ;; help__read_byte is the old do function without unread ket-char
   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx have_unreaded_ket_char?, false?branch, 9
      xx   literal, char$unreaded_ket_char, fetch_byte
      xx   zero, literal, flag$unreaded_ket_char, save
      xx   exit
      xx help__read_byte
      xx exit



   cursor$read_byte:
      xx 0

   border$read_byte:
      xx 0

   define_primitive_function "help,read-byte", help__read_byte
      ;; << -- byte >>
      call help__help__read_byte
      push_argument_stack rax
      next


   help__help__read_byte:
      mov rbx, [cursor$read_byte]
      cmp rbx, [border$read_byte]
      ;; [cursor$read_byte] <  [border$read_byte]
      jl .we_still_have_buffered_byte
      ;; [cursor$read_byte] >= [border$read_byte]
      jmp .do_a_new_buffer


   .do_a_new_buffer:
      mov rbx, buffer$read_byte
      mov [cursor$read_byte], rbx
      mov [border$read_byte], rbx

      mov sys_3_rdx, max_input_length ;; max length to be read
      mov sys_2_rsi, buffer$read_byte ;; buffer address
      xor sys_1_rdi, sys_1_rdi        ;; stdin
      mov sys_n_rax, syscall_read
      syscall
      ;; the return value of syscall read
      ;; is a count of the number of bytes transferred
      test rax, rax
      jz .error ;; rax = 0
      js .error ;; rax < 0

      ;; update [border$read_byte]
      add [border$read_byte], rax
      jmp help__help__read_byte


   .we_still_have_buffered_byte:
      ;; for the following will just uses the al part of rax
      ;; it is necessary to clear rax
      xor rax, rax
      mov al, byte [rbx]
      inc rbx
      mov [cursor$read_byte], rbx
      ret


   .error:
      ;; exit with exit code = 0
      xor sys_1_rdi, sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall
   #+end_src
** ----------------------------------
** note word
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_word_length = 1024

   buffer$read_word labeling
      preserve max_word_length

   buffer$read_word_for_REPL labeling
      preserve max_word_length
   #+end_src
** read-word-begin-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-begin-char", read_word_begin_char
      ;; << -- non-blank-char >>
      xx read_byte
      xx dup, literal, 32 ;; ascii.space
      xx greater_than?, false?branch, 2
      xx   exit
      xx drop
      xx read_word_begin_char
      xx exit
   #+end_src
** read-word->buffer
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word->buffer", read_word_to_buffer
      ;; << buffer -- word[address, length] >>
      xx read_word_begin_char
      ;; no metter what the begin char is
      ;; save it into buffer
      xx dup2, swap, save_byte
      xx swap, add1, swap
      xx one, swap ;; leave length counter
      ;; << cursor[address in buffer], counter, begin char >>
      xx dup, bar_ket_char?, false?branch, 4
      xx   drop
      xx   help__read_word_to_buffer__bar_ket
      xx   exit
      ;; maybe add other type of chars
      xx drop
      xx help__read_word_to_buffer__regular
      xx exit

   define_function "help,read-word->buffer,bar-ket", help__read_word_to_buffer__bar_ket
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx tuck, subtraction, swap
      xx exit

   define_function "help,read-word->buffer,regular", help__read_word_to_buffer__regular
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx read_byte
      xx dup, bar_ket_char?, false?branch, 6
      xx   unread_ket_char
      xx   tuck, subtraction, swap
      xx   exit
      xx dup, space_char?, false?branch, 6
      xx   drop
      xx   tuck, subtraction, swap
      xx   exit
      xx xoverxx, save_byte
      xx add1
      xx swap, add1, swap
      xx help__read_word_to_buffer__regular
      xx exit
   #+end_src
** read-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word", read_word
      ;; << -- word[address of buffer$read_word, length] >>
      xx literal, buffer$read_word, read_word_to_buffer
      xx exit
   #+end_src
** read-word-for-REPL
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-for-REPL", read_word_for_REPL
      ;; << -- word[address of buffer$read_word_for_REPL, length] >>
      xx literal, buffer$read_word_for_REPL, read_word_to_buffer
      xx exit
   #+end_src
** ----------------------------------
** note string
** write-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-string", write_string
      ;; << string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   exit
      xx sub1, swap
      xx dup, fetch_byte, write_byte
      xx add1, swap
      xx write_string
      xx exit
   #+end_src
** pretty_write_string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".s", pretty_write_string
      ;; << integer -- >>
      xx write_string
      xx literal, 10, write_byte
      xx exit
   #+end_src
** ----------------------------------
** write-nature-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; 2 ^ 64 = 18446744073709551616
   ;; which is of length 20
   ;; so
   ;; I use 32 to align to 16

   buffer$write_nature_number labeling
      preserve 32

   counter$write_nature_number:
      xx 0


   define_function "write-nature-number", write_nature_number
      ;; << nature-number -- >>
      xx zero
      xx literal, counter$write_nature_number, save

      xx help__write_nature_number

      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx string_reverse!
      xx write_string
      xx exit


   define_function "help,write-nature-number", help__write_nature_number
      ;; << rest-number -- >>
      xx literal, 10, divmod

      xx decimal_digital_to_char
      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx addition
      xx save_byte

      xx one
      xx literal, counter$write_nature_number
      xx add_save

      xx dup, zero?, false?branch, 3
      xx   drop
      xx   exit
      xx help__write_nature_number
      xx exit
   #+end_src
** write-integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-integer", write_integer
      ;; << integer -- >>
      xx dup, positive?, false?branch, 3
      xx   write_nature_number
      xx   exit
      xx literal, '-', write_byte
      xx negate, write_nature_number
      xx exit
   #+end_src
** pretty_write_integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".", pretty_write_integer
      ;; << integer -- >>
      xx write_integer
      xx literal, 32, write_byte
      xx exit
   #+end_src
** ----------------------------------
* char
** space-char?
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-char?", space_char?
      ;; << char -- bool >>
      xx literal, 32, less_or_equal?
      xx exit
   #+end_src
** bar-ket-char?
   * () [] {}
     but not <>
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "bar-ket-char?", bar_ket_char?
      ;; << char -- bool >>
      xx dup, literal, '(', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx dup, literal, ')', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx dup, literal, '[', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx dup, literal, ']', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx dup, literal, '{', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx dup, literal, '}', equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx drop, false
      xx exit
   #+end_src
** decimal-digital-char?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-char?", decimal_digital_char?
      ;; << char -- bool >>
      xx dup, literal, '0', less_than?, false?branch, 4
      xx   drop, false
      xx   exit
      xx dup, literal, '9', less_or_equal?, false?branch, 4
      xx   drop, true
      xx   exit
      xx drop, false
      xx exit
   #+end_src
** note digital
   * a decimal-digital is number from 0 to 9
   * a binary-digital is number from 0 to 1
** char->decimal-digital & decimal-digital->char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char->decimal-digital", char_to_decimal_digital
      ;; << char -- decimal-digital >>
      xx literal, '0', subtraction
      xx exit

   define_function "decimal-digital->char", decimal_digital_to_char
      ;; << decimal-digital -- char >>
      xx literal, '0', addition
      xx exit
   #+end_src
* buffer
** note
   * a buffer is a large vector
     and some functions do not care about how large it is
** compare-buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; return false when length == 0
   define_primitive_function "compare-buffer", compare_buffer
      ;; << address, address, length -- bool >>
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
* string
** string-equal?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-equal?", string_equal?
      ;; << string[address, length], string[address, length] -- bool >>
      xx xoverxx, equal?, false?branch, 4
      xx   swap, compare_buffer
      xx   exit
      xx drop, drop2
      xx false
      xx exit
   #+end_src
** string-[head|tail],char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,char", string_head__char
      ;; << string[address, length] -- char >>
      xx drop, fetch_byte
      xx exit

   define_function "string-tail,char", string_tail__char
      ;; << string[address, length] -- [address + 1, length + 1] >>
      xx sub1, swap
      xx add1, swap
      xx exit
   #+end_src
** string->buffer!
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "string->buffer!", string_to_buffer!
      ;; ( string[address, length], buffer[address] -- )
      pop_argument_stack rdi ;; destination
      pop_argument_stack rcx ;; counter
      pop_argument_stack rsi ;; source
      rep movsb
      next
   #+end_src
** string-reverse!
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rdi, buffer$string_reverse!
      mov rcx, [pointer$argument_stack - (1 * bead_size)]
      mov rsi, [pointer$argument_stack - (2 * bead_size)]
      rep movsb

      mov rcx, [pointer$argument_stack - (1 * bead_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [pointer$argument_stack - (2 * bead_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next
   #+end_src
** digital-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-string?", digital_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   exit
      xx over, fetch_byte, decimal_digital_char?, false?branch, 4
      xx   string_tail__char
      xx   digital_string?
      xx   exit
      xx drop2, false
      xx exit
   #+end_src
** char-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char-string?", char_string?
      ;; << string[address, length], char -- bool >>
      xx xxswapx
      xx dup, one?, false?, false?branch, 5
      xx   drop2, drop
      xx   false
      xx   exit
      xx string_head__char, equal?, false?branch, 3
      xx   true
      xx   exit
      xx false
      xx exit
   #+end_src
** zero-string?
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "exit"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero-string?", zero_string?
      ;; << string[address, length] -- bool >>
      xx dup2, literal, '0', char_string?, false?branch, 4
      xx   drop2, true
      xx   exit
      xx dup2
      xx string_head__char, literal, '-', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   exit
      xx string_tail__char, literal, '0', char_string?
      xx exit
   #+end_src
** integer-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "integer-string?", integer_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   exit
      xx dup2, literal, '-', char_string?, false?branch, 4
      xx   drop2, false
      xx   exit
      xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
      xx   string_tail__char, digital_string?
      xx   exit
      xx digital_string?
      xx exit
   #+end_src
** string->integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->integer", string_to_integer
      ;; << string[address, length] -- integer >>
      xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
      xx   digital_string_to_integer
      xx   exit
      xx string_tail__char
      xx digital_string_to_integer, negate
      xx exit


   sum$digital_string_to_integer:
      xx 0

   counter$digital_string_to_integer:
      xx 0

   define_function "digital-string->integer", digital_string_to_integer
      ;; << string[address, length] -- integer >>
      xx zero, literal, sum$digital_string_to_integer, save
      xx zero, literal, counter$digital_string_to_integer, save

      xx dup2, string_reverse!
      xx   help__digital_string_to_integer
      xx string_reverse!, drop2

      xx literal, sum$digital_string_to_integer, fetch
      xx exit

   define_function "help,digital-string->integer", help__digital_string_to_integer
      ;; << reversed-string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   exit

      xx dup2, string_head__char, char_to_decimal_digital
      xx   literal, 10
      xx   literal, counter$digital_string_to_integer, fetch
      xx     one
      xx     literal, counter$digital_string_to_integer
      xx     add_save
      xx   power
      xx multiple

      xx literal, sum$digital_string_to_integer
      xx add_save

      xx string_tail__char
      xx help__digital_string_to_integer
      xx exit
   #+end_src
* word
** ----------------------------------
** find
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
   * note that
     the stack-comment would be easy to write
     if one use always return the same number of return-values
     although when failing to find something
     often only the signal as a return-value would be useful
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*first-jo-in-dictionary*", V__first_jo_in_dictionary
      xx last_jo_in_assembly

   define_function "find", find
      ;; << word[address, length] -- jo, found or not >>
      xx V__first_jo_in_dictionary
      xx help__find
      xx exit

   define_function "help,find", help__find
      ;; << word[address, length], jo -- jo, found or not >>
      xx dup, null_jo?, false?branch, 6
      xx   drop, drop2
      xx   false, false
      xx   exit
      xx xxtuckx
      xx jo_to_name, xxoverxx
      xx string_equal?, false?branch, 4
      xx   drop2, true
      xx   exit
      xx xswapxx, jo_to_pre_jo
      xx help__find
      xx exit
   #+end_src
** execute-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "execute-word", execute_word
      ;; << word[address, length] -- unknown >>
      xx dup2, integer_string?, false?branch, 3
      xx   string_to_integer
      xx   exit
      ;; maybe more

      xx dup2 ;; for to report undefined word

      xx find, false?branch, 5
      xx   xxswapx, drop2
      xx   execute_jo
      xx   exit
      xx drop  ;; jo

      xx write_undefined_word_report
      xx write_string
      xx literal, 10, write_byte
      xx exit

   define_function "write-undefined-word-report", write_undefined_word_report
      ;; << -- >>
      xx literal, string$undefined_word_report
      xx literal, length$undefined_word_report
      xx write_string
      xx exit

   string$undefined_word_report:
      db "   UNDEFINED-WORD : "
   .end:
   length$undefined_word_report = (.end - string$undefined_word_report)
   #+end_src
** ----------------------------------
** note
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
** space-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-string?", space_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   exit
      xx over, fetch_byte, space_char?, false?branch, 4
      xx   string_tail__char
      xx   digital_string?
      xx   exit
      xx drop2, false
      xx exit
   #+end_src
** left-trim,[space-char|non-space-char]
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "left-trim,space-char", left_trim__space_char
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      xx   exit
      xx dup2, string_head__char, space_char?, false?, false?branch, 2
      xx   exit
      xx string_tail__char
      xx left_trim__space_char
      xx exit

   define_function "left-trim,non-space-char", left_trim__non_space_char
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      xx   exit
      xx dup2, string_head__char, space_char?, false?branch, 2
      xx   exit
      xx string_tail__char
      xx left_trim__non_space_char
      xx exit
   #+end_src
** string-[head|tail],word
   * note that
     the following functions do not create new strings
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,word", string_head__word
      ;; << string[address, length] -- word[address, length] >>
      xx left_trim__space_char
      xx dup2, left_trim__non_space_char
      xx swap, drop
      xx subtraction
      xx exit

   define_function "string-tail,word", string_tail__word
      ;; << string[address, length] -- string[address, length] >>
      xx left_trim__space_char
      xx left_trim__non_space_char
      xx exit
   #+end_src
** ----------------------------------
** exit-word?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$exit_word:
      db "exit"
   .end:
   length$exit_word = (.end - string$exit_word)

   define_function "exit-word?", exit_word?
      ;; << word[address, length] -- bool >>
      xx literal, string$exit_word
      xx literal, length$exit_word
      xx string_equal?
      xx exit
   #+end_src
** ----------------------------------
* basic-REPL
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "basic-REPL", basic_REPL
     ;; << unknown -- unknown >>
     xx read_word_for_REPL
     xx execute_word
     xx basic_REPL
     xx exit
  #+end_src
* -----------------------------------
* : & ;
** note
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first:
     #+begin_src
     define-function factorial
       << n -- n! >>
       dup one? if
         exit
       then
       dup sub1 factorial *
       exit
     end
     #+end_src
   * second:
     #+begin_src cicada-nymph
     : factorial
       << n -- n! >>
       dup one? if
         exit
       then
       dup sub1 factorial *
       exit
     ; define-function
     #+end_src
** [colon|semicolon]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "colon-string?", colon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ':', char_string?
      xx exit

   define_function "semicolon-string?", semicolon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ';', char_string?
      xx exit
   #+end_src
** comment-[begin|end]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$comment_begin:
      db "<<"

   define_function "comment-begin-string?", comment_begin_string?
      ;; (* string[address, length] -- bool *)
      xx literal, string$comment_begin
      xx literal, 2
      xx string_equal?
      xx exit


   string$comment_end:
      db ">>"

   define_function "comment-end-string?", comment_end_string?
      ;; (* -- *)
      xx literal, string$comment_end
      xx literal, 2
      xx string_equal?
      xx exit
   #+end_src
** colon & semicolon
   * nested : ; is not allow
     and no error check for it
   * nested << >> must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in << >>
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     but "<" & ">" are not viewed as bar-ket
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$colon labeling
      preserve 1024 * 1024

   cursor$colon:
      xx 0

   define_function ":", colon
      ;; << -- string[address of buffer$colon, length] >>
      xx literal, buffer$colon
      xx literal, cursor$colon, save

      xx help__loop__colon

      xx literal, buffer$colon
      xx literal, cursor$colon, fetch
      xx literal, buffer$colon
      xx subtraction
      xx exit


   define_function "help,loop,colon", help__loop__colon
      ;; << -- >>
      xx read_word
      xx dup2, semicolon_string?, false?branch, 3
      xx   drop2
      xx   exit
      xx dup2, comment_begin_string?, false?branch, 5
      xx   drop2
      xx   ignore_comment
      xx   help__loop__colon
      xx   exit
      xx help__add__colon
      xx help__loop__colon
      xx exit


   ;; when add a word into buffer
   ;; tail it with a space
   define_function "help,add,colon", help__add__colon
      ;; << word[address, length] -- >>
      ;; <* word[address, length] -- *>
      ;; << word[address, length] -- >>
      xx tuck
      xx   literal, cursor$colon, fetch
      xx   string_to_buffer!
      xx literal, cursor$colon, add_save
      xx one
      xx   literal, 32
      xx   literal, cursor$colon, fetch
      xx   save_byte
      xx literal, cursor$colon, add_save
      xx exit
   #+end_src
** ignore-comment
   * this function is for basic-REPL
     but it is reused by colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "<<", ignore_comment
      ;; << -- >>
      xx read_word
      xx dup2, comment_begin_string?, false?branch, 5
      xx   drop2
      xx     ignore_comment ;; for the new nested-comment
      xx   ignore_comment ;; for the rest-comment
      xx   exit
      xx dup2, comment_end_string?, false?branch, 3
      xx   drop2
      xx   exit
      xx drop2
      xx ignore_comment
      xx exit
   #+end_src
** test
   #+begin_src cicada-nymph
   1 << 989 >> 64 add .
   << 65 >>

   : kkk << 989 << 989 >> >> ; .s
   << kkk >>
   #+end_src
* >< function & jojo
** ----------------------------------
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   address$jo_heap labeling
      preserve 3 * 1024 * 1024 * bead_size

   define_variable "*current-free-address,jo-heap*", V__current_free_address__jo_heap
      xx address$jo_heap
   #+end_src
** ----------------------------------
** note
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
** make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo", make_jojo
      ;; << string[address, length] -- >>
      xx dup2, space_string?, false?branch, 3
      xx   drop2
      xx   exit
      xx dup2
      xx string_tail__word
      xx xxswapxx
      xx string_head__word
      ;; << tail[address, length], head[address, length] >>
      xx make_jojo__dispatch_word
      xx make_jojo
      xx exit

   define_function "make-jojo,dispatch-word", make_jojo__dispatch_word
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2, exit_word?, false?branch, 5
      xx   drop2
      xx   zero
      xx     save_into__jo_heap
      xx   exit
      xx dup2, zero_string?, false?branch, 6
      xx   drop2
      xx   literal, zero
      xx     save_into__jo_heap
      xx   exit
      xx dup2, integer_string?, false?branch, 7
      xx   literal, literal
      xx     save_into__jo_heap
      xx   string_to_integer
      xx     save_into__jo_heap
      xx   exit
      xx dup2
      xx find, false?, false?branch, 8
      xx   drop ;; jo
      xx   write_undefined_word_report__for_funtion_body
      xx   write_string
      xx   literal, 10, write_byte
      ;;   ><><><
      ;;   here we should not compile the function into memory at all
      ;;   note that
      ;;     proper exception handling
      ;;     can be implemented by doing side-effect on return-stack
      xx   exit
      xx xxswapx, drop2 ;; word
      xx make_jojo__dispatch_jo
      xx exit

   define_function "make-jojo,dispatch-jo", make_jojo__dispatch_jo
      ;; << string[address, length], jo --
      ;;    string[address, length] >>
      xx dup, function_jo?, false?branch, 3
      xx   save_into__jo_heap
      xx   exit
      xx dup, primitive_function_jo?, false?branch, 3
      xx   save_into__jo_heap
      xx   exit
      xx dup, variable_jo?, false?branch, 3
      xx   save_into__jo_heap
      xx   exit
      xx dup, macro_jo?, false?branch, 3
      xx   execute_jo
      xx   exit
      xx drop
      xx exit

   define_function "write-undefined-word-report,for-funtion-body", write_undefined_word_report__for_funtion_body
      ;; << -- >>
      xx literal, string$undefined_word_report__for_funtion_body
      xx literal, length$undefined_word_report__for_funtion_body
      xx write_string
      xx exit

   string$undefined_word_report__for_funtion_body:
      db "   make-jojo meets UNDEFINED-WORD : "
   .end:
   length$undefined_word_report__for_funtion_body = (.end - string$undefined_word_report__for_funtion_body)
   #+end_src
** ----------------------------------
** note macro in cicada-nymph
   * a macro is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
   * a macro should be highlight by text editor in a special way
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_macro "address", M__address
      ;; << string[address, length] -- string[address, length] >>
      xx literal, address
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx find, false?branch, 4
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   exit
      xx drop

      xx dup2
      xx write_undefined_word_report__for_funtion_body
      xx string_head__word, write_string
      xx literal, 10, write_byte
      ;; ><><><
      ;; here we should not compile the function into memory at all
      xx exit
   #+end_src
** >< branch
** >< false?branch
** ----------------------------------
** note
   * you can see how the naming convention is used
     for functions that create structured data into memory
** save-into,primitive-string-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,primitive-string-heap", save_into__primitive_string_heap
      ;; << string[address, length] -- address >>
      xx dup, V__current_free_address__primitive_string
      xx save_two_bytes

      xx literal, 2
      xx address, V__current_free_address__primitive_string
      xx add_save

      xx tuck
      xx V__current_free_address__primitive_string
      xx string_to_buffer!

      xx address, V__current_free_address__primitive_string
      xx add_save

      xx exit
   #+end_src
** save-into,jo-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,jo-heap", save_into__jo_heap
      ;; << number -- address >>
      xx V__current_free_address__jo_heap
      xx save

      xx literal, bead_size
      xx address, V__current_free_address__jo_heap
      xx add_save

      xx exit
   #+end_src
** ----------------------------------
** note
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
** define-function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-function", CICADA__define_function
      ;; << string[address, length] -- >>
      xx dup2

      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$function
      xx   save_into__jo_heap

      xx dup2, string_tail__word
      xx   make_jojo

      ;; when debugging
      ;; instead of drop2
      ;; one may wish to do some thing to the string
      xx drop2
      xx exit
   #+end_src
** test
   #+begin_src cicada-nymph
   : addadd add add exit ; define-function
   1 2 3 addadd . << 6 >>

   : add1 1 add exit ; define-function
   1 add1 . << 2 >>

   : negate 0 swap sub exit ; define-function
   1 negate . << -1 >>
   #+end_src
** ----------------------------------
** define-macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-macro", CICADA__define_macro
      ;; << string[address, length] -- >>
      xx dup2

      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$macro
      xx   save_into__jo_heap

      xx dup2, string_tail__word
      xx   make_jojo

      ;; when debugging
      ;; instead of drop2
      ;; one may wish to do some thing to the string
      xx drop2
      xx exit
   #+end_src
** ----------------------------------
** define-variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-variable", CICADA__define_variable
      ;; << variable, string[address, length] -- >>
      xx dup2

      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$variable
      xx   save_into__jo_heap

      ;; when debugging
      ;; instead of drop2
      ;; one may wish to do some thing to the string
      xx drop2
      xx   save_into__jo_heap
      xx exit
   #+end_src
** ----------------------------------
** test
   #+begin_src cicada-nymph
   233 : *three* ; define-variable
   : add-three *three* add exit ; define-function
   1 add-three . << 234 >>

   : fix-*three* 3 address *three* save exit ; define-function
   fix-*three*
   1 add-three . << 4 >>
   #+end_src
* -----------------------------------
* epilog
** last_jo_in_assembly
   * this word helps to initialize V__first_jo_in_dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", last_jo_in_assembly
      ;; << -- >>
      xx 0
   #+end_src
** *current-free-address,primitive-string-heap*
   * the last_primitive_string_in_assembly
     is just "*current-free-address,primitive-string-heap*"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*current-free-address,primitive-string-heap*", V__current_free_address__primitive_string
      xx current_free_address$primitive_string_heap
   #+end_src
** un_initialized_memory
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   segment readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory
   #+end_src
* ===================================
