#+TITLE:  小蟬語 / cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* 整理中文筆記 並寫更多中文筆記
* change some names
* primitive-function about bit-wise operations
  * I need these primitive-functions
    to implement syscalls well
* todo
** protect on the overloading of a variety of memories
** better naming of headings
** add more notes about the limitations of the program
** add more notes about exception handling on io functions
** optimize local-variable by new instruction
   * too many literal is too waste of memory
** bare-metal version of cicada-nymph for x86 :maybe:
** make instruction a type of jo      :maybe:
   this is needed when doing report of the dictionary
* ===================================
* note
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
** naming convention
   * a predicate of a type
     which denotes a subtype of that type
     uses that type as postfix
     such as
     "space-char?"
   * a function of a type
     uses that type as prefix
     such as
     "string-reverse"
     "string-equal?"
   * side-effect of structured data is postfixed by "!"
** convention in assembly code
   * using underline to compose big word from small words
   * using "$" as prefix and postfix separator
   * indentation level = 3
   * naming convention of jo
     | convention   | jo type  |
     |--------------+----------|
     | prefix "V__" | variable |
     | prefix "M__" | macro    |
   * but I use
     1. "zero" instead of "V__zero"
     2. "true" instead of "V__true"
** convention in cicada-nymph code
   * using dash to compose big word from small words
   * using "," as prefix and postfix separator
   * indentation style = free
   * words are separated by space
     except for bar-ket
     every bar-ket is viewed as a word
** syntax of cicada-nymph
   * syntax &  semantic
     | syntax          | semantic                  |
     |-----------------+---------------------------|
     | borderfix "* *" | variable                  |
     | borderfix "+ +" | [maybe use]               |
     | bar-ket ( )     | not use                   |
     | bar-ket [ ]     | not use                   |
     | bar-ket { }     | macro call                |
     |                 | (for macros of which      |
     |                 | the number of             |
     |                 | arguments is not fix)     |
     | double-quote    | viewed as special bar-ket |
     |                 | (bar is the same as ket)  |
     |                 | to support string literal |
     | prefix "!"      | exception                 |
     | postfix "!"     | some of the side-effect   |
     | postfix "?"     | predicate                 |
   * but I use
     1. "true" instead of "*true*"
     2. "false" instead of "*false*"
** unique id
   * if one wish to get a named unique id
     a jo maybe used
     for a jo is an address in memory
     it is unique as a memory address
   * but there is not effort made
     to distinguish address and fixnum
     as different type of things
     thus
     this kind of unique id is not fit
     for some tasks
** different from the re-designed cicada-language
    * simplifications are for teaching purpose only
    * first and foremost
      function programming will NOT be supported in this implementation
    * a helper function must be defined before it is used
    * no mixfix-notation
      * function call is "function" instead of "(function)"
      * no such thing like
        1 2 (add) = 1 (add 2) = (add 1 2)
    * no named local argument
      * thus no inited local argument
    * no title-name-table
      * thus in this implementation
        we only use single name space
      * thus in this implementation
        we do NOT have the concept of "context"
        so
        the syntax is not as flexible as it will be in cicada-language
    * no type
      * no type inference
      * no dynamic type tag
      * no static type declaration
    * global linked-list for naming
      * not hash-table
      * by the way
        in classical forth
        the linked-list of jo is called dictionary
    * no dynamic-memory-management
      * no garbage-collector
    * about comment
      * the comment of the argument & return value of function
        is allowed to be written in free style normal comment
* note instar
** 1st-instar
   * indirect-threaded-code interpreter
     1. macro about argument_stack & return_stack
     2. macro about jo & jojo
     3. macro about next
     4. the way to do memory allocation
     5. begin_to_interpret_threaded_code
     6. little_test
** 2ed-instar
   * instruction as special primitive function
     1. literal
     2. address
   * and primitive functions about
     1. the stack
     2. bool
     3. fixnum
     4. memory
   * and taca for explicit tail-call
   * false?branch and taca are needed for "power"
** 3rd-instar
   * primitive function about io
     1. write_byte
     2. read_byte
** 4th-instar
   * more function about io
     1. about word
     2. about string
     3. about number
   * more function
     1. jo
     2. char
     3. buffer
   * more in epilog
     1. last_link
   * function about dictionary
     1. find
     2. execute-word
   * basic-REPL as postfix-notation function executer
     1. basic-REPL
** 5th-instar
   * type of jo
   * more in epilog
     1. *current-free-address,primitive-string-heap*
   * colon semicolon
     1. ":" and ";" are used to read a string of words for compiler
        [looks like bar-ket but special]
     2. comment is handled here
        "<< >>" as the only way to do comment
   * compiler
     * make-jojo
       and macro for make-jojo
       1. macro system
       2. exception handling system
     * function about definition
       which leave data into memory
** 6th-instar
   * local-variable
* 記 數據結構與口總結
** jojo
   * jo 的數組
     每個數組外加一些元數據
** dictionary of jojo
   * 單項鏈接的鏈表
** primitive-string
** argument-stack
** return-stack
   * jo 的詮釋者
     決定了 如何入這個棧
   * 結尾詞
     決定了 如何出這個棧
** eval-string-stack
   * 兩個一對
** syntax-set
** local-variable-table
   * a heap like table of string
   * 只有一個 local-variable-table
     用以在編譯時期解決局部變元的名與值的對應
     這個數據結構被 syntax__local_variable_save__make_jojo
     和 syntax__local_variable_fetch__make_jojo 所使用
   * 其中保存
     * offset-in-local-data-vector
     * length-of-string
     * address-of-string
   * 並且每次在定義一個新的函數體的時候
     這個 local-variable-table 會被初始化
   * 基本的接口是
     * clear
       清空 offset 和 border
     * insert
       插入字符串 和 offset-in-local-data-vector
     * find
       通過字符串尋找 offset-in-local-data-vector
     有兩個全局變量幫助實現這些接口
     * cursor
       每次 find 的時候使用一個新的 cursor 來做循環
     * border
       insert 會擴大 border
       find 以 border 爲邊界
     另外 還有一個全局變量
     * offset
       用以計算 offset-in-local-data-vector
* 記 性狀總結
** 自動管理加載文件時所使用的搜索路徑列表
   * 原理如下
     * 在 cicada-nymph 中 load 一個 file 的時候
       需要指定出這個 被 load 的 file 的路徑
     * 維護一個需要被搜索的路徑的列表
       以使得 load 的 file 的時候
       不必使用完整的路徑
     * 提供自動管理搜索路徑的機制
   * 維護搜索路徑的列表的方式是
     利用文件系統中的一個某個固定路徑
     也就是說 只有唯一的一個需要被找到的路徑
     而其他的路徑都是被自動管理的
     這個路徑將有一個默認值
     並且可以被環境變量覆蓋
   * 限制加載文件的方式
     使得只能使用所提供的動態管理機制來加載文件
     這樣就可以減輕理解這個系統的困難
** >< 局部變元
* note problem
** about div                          :bug:
   * div can not handle the following
     -8 2 div .
** about inline comment               :bug:
   * inline comment such as
     add1 << dup . >> swap
     will be viewed as
     add1swap
** about comment in string            :bug:
   * << >> can not be in ""
** about stack                        :limit:
   * there are 64 positions below the all those stacks
     when you are belowing-stack so much
     bad things happen
* ===================================
* prolog
** ----------------------------------
** note conditional preprocessing
   * flower bar-ket can not be nested in fasm's "match"
     so
     1. when defining macro conditionally
        one should use "if eq" & "finish if"
     2. when doing "define" or "equ"
        one should use "match { }"
** platform configuration
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;;;; before you compile the code
   ;;;; do not forget to choose your platform
   ;;;; in the following code

   include "platform-configuration.inc"
   #+end_src
** misc
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; in fasm, "end" is a reserved word
   finish equ end
   end equ exit
   #+end_src
** ----------------------------------
** jo_size                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   jo_size = 8 ;; (byte)
   xx equ dq

   }
   #+end_src
** jo_size                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   jo_size = 4 ;; (byte)
   xx equ dd

   rax equ eax
   rbx equ ebx
   rcx equ ecx
   rdx equ edx
   rsp equ esp
   rbp equ ebp
   rsi equ esi
   rdi equ edi

   syscall equ int 80h

   }
   #+end_src
** ----------------------------------
** header                             :64bit:linux:
   * /usr/include/asm/unistd_64.h (on archlinux)
   * http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define linux64_sys_6_r8  r8
   define linux64_sys_5_r9  r9
   define linux64_sys_4_r10 r10
   define linux64_sys_3_rdx rdx
   define linux64_sys_2_rsi rsi
   define linux64_sys_1_rdi rdi
   define linux64_sys_n_rax rax

   define linux64_syscall_read   0
   define linux64_syscall_write  1
   define linux64_syscall_open   2
   define linux64_syscall_close  3
   define linux64_syscall_getpid 39
   define linux64_syscall_exit   60
   ;; about open & read & write

   }
   #+end_src
** format                             :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   format ELF64 executable 3

   }
   #+end_src
** entry                              :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   entry begin_to_interpret_threaded_code
   segment readable executable writeable

   }
   #+end_src
** ----------------------------------
** header                             :32bit:linux:
   * /usr/include/asm/unistd_32.h (on archlinux)
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define linux32_sys_6_ebp ebp
   define linux32_sys_5_edi edi
   define linux32_sys_4_esi esi
   define linux32_sys_3_edx edx
   define linux32_sys_2_ecx ecx
   define linux32_sys_1_ebx ebx
   define linux32_sys_n_eax eax

   define linux32_syscall_exit    1
   define linux32_syscall_read    3
   define linux32_syscall_write   4
   define linux32_syscall_open    5
   define linux32_syscall_close   6
   define linux32_syscall_getpid  20

   }
   #+end_src
** format                             :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   format ELF executable 3

   }
   #+end_src
** entry                              :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   entry begin_to_interpret_threaded_code
   segment readable executable writeable

   }
   #+end_src
** ----------------------------------
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle cicada-nymph.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** ----------------------------------
* -----------------------------------
* note stack
  * when doing "push"
    a stack-pointer moves to lower address
  * note that another style is that
    when doing "push"
    a stack-pointer moves to higher address
  * the stack-pointer
    always stores the address of current-free-address of the stack
  * note that another style is that
    under the stack-pointer
    there always stores the value of the-top-of-the-stack
* argument_stack
** ----------------------------------
** memory allocation
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$argument_stack = 1024 * 1024 * jo_size

      preserve 64 * jo_size
   address$argument_stack labeling
      preserve size$argument_stack
   #+end_src
** ----------------------------------
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$argument_stack r15

   }
   #+end_src
** push & pop                         :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_argument_stack register \{
      mov [pointer$argument_stack], register
      add pointer$argument_stack, jo_size
   \}

   macro pop_argument_stack register \{
      sub pointer$argument_stack, jo_size
      mov register, [pointer$argument_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$argument_stack:
      xx address$argument_stack

   }
   #+end_src
** push & pop                         :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   macro pop_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* return_stack
** ----------------------------------
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$return_stack = 1024 * 1024 * jo_size

      preserve 64 * jo_size
   address$return_stack labeling
      preserve size$return_stack
   #+end_src
** ----------------------------------
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$return_stack r14

   }
   #+end_src
** push & pop                         :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_return_stack register \{
      mov [pointer$return_stack], register
      add pointer$return_stack, jo_size
   \}

   macro pop_return_stack register \{
      sub pointer$return_stack, jo_size
      mov register, [pointer$return_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$return_stack:
      xx address$return_stack

   }
   #+end_src
** push & pop                         :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_return_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$return_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$return_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$return_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$return_stack], eax
      pop eax
      finish if
   \}

   macro pop_return_stack register \{
      if register in <eax>
      mov ebx, [pointer$return_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$return_stack], ebx
      else
      mov eax, [pointer$return_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$return_stack], eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* -----------------------------------
* next
  #+begin_src fasm :tangle cicada-nymph.fasm
  match =64bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp qword [rax]
  \}

  }


  match =32bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp dword [rax]
  \}

  }
  #+end_src
* note play with jo & jojo
  1. at the beginning
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
       - [@][@][ (square) ]
                 (square)
                 (end)
       #+end_src
  2. next
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
                 (square)
       - [@][@][ (square) ] - [@][@][ (dup) ]
                 (end)                (mul)
                                      (end)
       #+end_src
  3. next
     * argument-stack
       << 2, 2 >>
     * return-stack
       #+begin_src return-stack
                 (square)             (dup)
       - [@][@][ (square) ] - [@][@][ (mul) ]
                 (end)                (end)
       #+end_src
  4. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
                                      (dup)
                 (square)             (mul)
       - [@][@][ (square) ] - [@][@][ (end) ]
                 (end)
       #+end_src
  5. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)
       - [@][@][ (end) ] - [@][@][ (dup) ]
                                   (mul)
                                   (end)
       #+end_src
  6. next
     * argument-stack
       << 4, 4 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)          (dup)
       - [@][@][ (end) ] - [@][@][ (mul) ]
                                   (end)
       #+end_src
  7. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
                 (square)          (dup)
                 (square)          (mul)
       - [@][@][ (end) ] - [@][@][ (end) ]
       #+end_src
  8. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)
       - [@][@][ (end) ]
       #+end_src
  9. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
       - [  ]
       #+end_src
  10. it is really simple
      ^-^
      is it not ?
* -----------------------------------
* link
  #+begin_src fasm :tangle cicada-nymph.fasm
  ;; initial link to point to 0 (as null)
  link = 0
  #+end_src
* primitive_string_heap
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$primitive_string_heap = 64 * 1024 ;; (byte)

   address$primitive_string_heap:
      times size$primitive_string_heap db 0

   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** make_primitive_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro make_primitive_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dw (.end$string - .start$string)
      load .length word from (.end$string)
   finish virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      finish virtual
      store byte .char at (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   finish repeat

   }
   #+end_src
* function-jo
** note
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
** define_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; here follows a jojo as function-body

   }
   #+end_src
** explain$function
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$function:
      mov rbx, [current_free_address$local_data_heap]
      push_return_stack rbx
      mov rbx, [current_free_address$local_data_vector]
      push_return_stack rbx
      add rax, jo_size
      push_return_stack rax
      next
   #+end_src
* primitive-function-jo
** note
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
** define_primitive_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:

      ;; here follows assembly code
      ;; as primitive function body

   }
   #+end_src
* variable-jo
** note
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
** define_variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; here follows a value of jo_size
      ;; only one value is allowed

   }
   #+end_src
** explain$variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$variable:
      add rax, jo_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
* exception-jo
** 記
   * (prepare-for) 展開
   * (exception_head) 無爲
   * (!exception)
     其 jo 本身用以搜索到位置
     而 定義其 jo 的 jojo 被植入到所搜索到的位置
   * 設計的不足之處在於
     在調用 (!exception) 的時候
     調用它的函數不能傳遞給 (!exception) 一些參數
** note
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
** define_exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_exception string, jo {

   define_exception__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$exception

      ;; here follows a jojo as function-body

   }
   #+end_src
** note return-stack in action
   1. when "explain$exception" is called
      jojo by jojo
      it searchs the jo stored in "rax" in the return-stack
      of course
      only jojo with "exception_head" as head needs to be searched
   2. for example
      we have
      #+begin_src fasm
      define_exception "!exception-1", !exception_1
         xx fun1
         xx fun2
         xx end
      #+end_src
   3. return-stack
      #+begin_src return-stack
                                          (prepare_for)
                                            (exception_head)
                                            (!exception_1)
                                            (!exception_2)
                                            (end)
           (prepare_for)                  (function_1)
      - [@][ (exception_head) ] - [@][@][ (function_2) ] - ... - [@][@][ (!exception_1) ]
             (!exception_1)               (end)                          (end)
             (!exception_2)
             (end)
           (function_1)
           (function_2)
           (end)
      #+end_src
   4. next
      * pointer$argument_stack
        should be set to the above [@]
      * and
        to call "next" again
        the return-stack should be change to
        #+begin_src return-stack
        - [@][@][ (fun1) ]
                  (fun2)
                  (end)
        #+end_src
** note the plan
   * so
     we need a two-level loop
   * note that
     although
     we have to use assembly code
     to write primitive functions
     but
     we still can use argument-stack
     to pass arguments
** explain$exception                  :64bit:
   * no error handling for now
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   explain$exception:
      mov rsi, rax

   .next_jojo:
      pop_return_stack rbx
      mov rax, qword [rbx]
      cmp rax, exception_head
      je .next_jo
      cmp pointer$return_stack, address$return_stack
      je .not_found
      jmp .next_jojo


   .next_jo:
      ;; expecting
      ;;   rbx jojo
      ;;   rsi jo (to cmp)
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, rsi
      je .found
      test rax, rax
      jz .next_jojo
      jmp .next_jo


   .found:
      ;; expecting
      ;;   pointer$return_stack
      ;;   rsi jo
      pop_return_stack rax
      mov pointer$argument_stack, rax

      mov rbx, [current_free_address$local_data_vector]
      push_return_stack rbx

      mov rbx, [current_free_address$local_data_heap]
      push_return_stack rbx

      add rsi, jo_size
      push_return_stack rsi
      next

   .not_found:
      call __exit_with_six

   }
   #+end_src
** explain$exception                  :32bit:
   * no error handling for now
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   explain$exception:
      mov rsi, rax

   .next_jojo:
      pop_return_stack rbx
      mov rax, dword [rbx]
      cmp rax, exception_head
      je .next_jo
      mov rdx, [pointer$return_stack]
      cmp rdx, address$return_stack
      je .not_found
      jmp .next_jojo


   .next_jo:
      ;; expecting
      ;;   rbx jojo
      ;;   rsi jo (to cmp)
      add rbx, jo_size
      mov rax, dword [rbx]
      cmp rax, rsi
      je .found
      test rax, rax
      jz .next_jojo
      jmp .next_jo


   .found:
      ;; expecting
      ;;   pointer$return_stack
      ;;   rsi jo
      pop_return_stack rax
      mov [pointer$argument_stack], rax

      mov rbx, [current_free_address$local_data_vector]
      push_return_stack rbx

      mov rbx, [current_free_address$local_data_heap]
      push_return_stack rbx

      add rsi, jo_size
      push_return_stack rsi
      next

   .not_found:
      call __exit_with_six

      }
   #+end_src
* -----------------------------------
* execute-jo & structure of jo
** ----------------------------------
** execute-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack rax
      jmp qword [rax]

   }


   match =32bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack eax
      jmp dword [eax]

   }
   #+end_src
** ----------------------------------
** *jo-size*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*jo-size*", V__jo_size
      xx jo_size
   #+end_src
** jo->name
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->name", jo_to_name
      ;; << jo -- string[address, length] >>
      xx literal, jo_size, subtraction
      xx literal, jo_size, subtraction
      xx fetch
      xx address_to_primitive_string
      xx end
   #+end_src
** jo->link
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->link", jo_to_link
      ;; << jo -- link >>
      xx literal, jo_size
      xx subtraction
      xx end
   #+end_src
** last-jo,dictionary?
   * first jo in assembly code
     is the last jo in dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "last-jo,dictionary?", last_jo__dictionary?
      ;; << jo -- bool >>
      xx jo_to_link
      xx fetch
      xx zero?
      xx end
   #+end_src
** jo->pre-jo
   * treat last-jo,dictionary specially
     i.e. return zero on that case
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->pre-jo", jo_to_pre_jo
      ;; << jo -- pre-jo >>
      xx jo_to_link
      xx fetch
      xx dup, zero?, false?branch, 2
      xx   end
      xx literal, jo_size
      xx addition
      xx end
   #+end_src
** jo->type
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->type", jo_to_type
      ;; << jo -- type >>
      xx dup

      xx dup, fetch
      xx swap, subtraction, literal, jo_size, equal?, false?branch, 4
      xx   drop, zero
      xx   end

      xx fetch
      xx end
   #+end_src
** ----------------------------------
* primitive-string-heap
** *primitive-string-heap*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*primitive-string-heap*", V__primitive_string_heap
      xx address$primitive_string_heap

   define_variable "*size,primitive-string-heap*", V__size__primitive_string_heap
      xx size$primitive_string_heap

   ;; *current-free-address,primitive-string-heap*
   ;; is at epilog
   #+end_src
** address->primitive-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "address->primitive-string", address_to_primitive_string
      ;; << address -- string[address, length] >>
      xx dup
      xx literal, 2, addition  ;; address
      xx swap, fetch_two_bytes ;; length
      xx end
   #+end_src
* type of jo
** primitive-function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "primitive-function-jo?", primitive_function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx zero?
      xx end
   #+end_src
** function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "function-jo?", function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$function
      xx equal?
      xx end
   #+end_src
** exception-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "exception-jo?", exception_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$exception
      xx equal?
      xx end
   #+end_src
** variable-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "variable-jo?", variable_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$variable
      xx equal?
      xx end
   #+end_src
* -----------------------------------
* end & taca
** 記 結尾珠
   * end 和 taca 這兩個結尾珠代表將執行退出操作
     在退出時
     它們將會從返回棧頂取出三個值
     從棧頂開始數 這三個值分別是
     1. 結束執行的一串珠珠本身
        這個值是被捨棄的
     2. local_data_vector 中的一個地址
        用於重置
        [current_free_address$local_data_vector]
     3. local_data_heap 中的一個地址
        用於重置
        [current_free_address$local_data_heap]
   * end 和 taca 的區別在於
     * end
       入返回棧一串新的珠珠
       [三個值一組的存在]
     * taca
       用一串新的珠珠
       代替返回棧頂的一串珠珠
       [三個值一組的存在]
** end
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "end", end
      pop_return_stack rbx
      pop_return_stack rax
      mov [current_free_address$local_data_vector], rax
      pop_return_stack rax
      mov [current_free_address$local_data_heap], rax
      next
   #+end_src
** taca
   * tail-call
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      pop_return_stack rax
      mov [current_free_address$local_data_vector], rax
      pop_return_stack rax
      mov [current_free_address$local_data_heap], rax
      mov rax, [rbx]
      jmp qword [rax]
   }


   match =32bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      pop_return_stack rcx
      mov [current_free_address$local_data_vector], rcx
      pop_return_stack rcx
      mov [current_free_address$local_data_heap], rcx
      mov rax, [rbx]
      jmp dword [rax]

   ;;;; old note
   ;; ><><>< can not be the following
   ;; maybe still something wrong with pop_return_stack
   ;; but I care less about this now
   ;; define_primitive_function "<>", taca
   ;;    pop_return_stack ebx
   ;;    pop_return_stack eax
   ;;    mov [current_free_address$local_data_vector], eax
   ;;    mov eax, [ebx]
   ;;    jmp dword [eax]

   }
   #+end_src
** note explicit tail call in action
   1. the tail position of a function body must be recognized
      explicit tail call is used to achieve this
   2. thus
      tail-recursive-call can be use to do loop
      without pushing too many address into return-stack
   3. for example if we have a function
      which is called "example"
      #+begin_src fasm
      define_function "example", example
         xx fun1
         xx fun2
         xx taca, example
      #+end_src
   4. and we have the following jojo in return-stack
      #+begin_src return-stack
      - [@][@][ (example) ]
                (end)
      #+end_src
   5. next
      #+begin_src return-stack
                (example)
      - [@][@][ (end) ] - [@][@][ (fun1) ]
                                  (fun2)
                                  (taca)
                                  (example)
      #+end_src
   6. next
      #+begin_src return-stack
                (example)         (fun1)
      - [@][@][ (end) ] - [@][@][ (fun2) ]
                                  (taca)
                                  (example)
      #+end_src
   7. next
      #+begin_src return-stack
                                  (fun1)
                (example)         (fun2)
      - [@][@][ (end) ] - [@][@][ (taca) ]
                                  (example)
      #+end_src
   8. next
      by the definition of taca
      #+begin_src return-stack
                (example)
      - [@][@][ (end) ] - [@][@][ (fun1) ]
                                  (fun2)
                                  (taca)
                                  (example)
      #+end_src
   9. you can see return-stack of (8.)
      is the same as (5.)
      it is clear how the example function
      is actually a loop now
* -----------------------------------
* helper function in assembly
** ----------------------------------
** __exit_with_TOS                    :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_TOS:
      pop_argument_stack linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_zero                   :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_zero:
      xor linux64_sys_1_rdi, linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_six                    :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_six:
      mov linux64_sys_1_rdi, 6
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __print_string                     :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __print_string:
      ;; << address, length -- >>
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      pop_argument_stack linux64_sys_3_rdx     ;; max length to be write
      pop_argument_stack linux64_sys_2_rsi     ;; address
      mov linux64_sys_1_rdi, 1                 ;; stdout
      mov linux64_sys_n_rax, linux64_syscall_write
      syscall
      ret

   }
   #+end_src
** __reset_argument_stack             :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __reset_argument_stack:
      mov pointer$argument_stack,  address$argument_stack
      ret

   }
   #+end_src
** __reset_return_stack               :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __reset_return_stack:
      mov pointer$return_stack,    address$return_stack
      ret

   }
   #+end_src
** ----------------------------------
** __exit_with_TOS                    :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_TOS:
      pop_argument_stack linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_zero                   :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_zero:
      xor linux32_sys_1_ebx, linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_six                    :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_six:
      mov linux32_sys_1_ebx, 6
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __print_string                     :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __print_string:
      ;; << address, length -- >>
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      pop_argument_stack linux32_sys_3_edx     ;; max length to be write
      pop_argument_stack linux32_sys_2_ecx     ;; address
      mov linux32_sys_1_ebx, 1                 ;; stdout
      mov linux32_sys_n_eax, linux32_syscall_write
      syscall
      ret

   }
   #+end_src
** __reset_argument_stack             :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __reset_argument_stack:
      mov rax, address$argument_stack
      mov [pointer$argument_stack], rax
      ret

   }
   #+end_src
** __reset_return_stack               :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __reset_return_stack:
      mov rax, address$return_stack
      mov [pointer$return_stack], rax
      ret

   }
   #+end_src
** ----------------------------------
** __reset_local_data_vector
   #+begin_src fasm :tangle cicada-nymph.fasm
   __reset_local_data_vector:
      mov rax, address$local_data_vector
      mov [current_free_address$local_data_vector], rax
      ret
   #+end_src
** __reset_local_data_heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   __reset_local_data_heap:
      mov rax, address$local_data_heap
      mov [current_free_address$local_data_heap], rax
      ret
   #+end_src
** ----------------------------------
* -----------------------------------
* *the-story-begin*
** ----------------------------------
** 記 匯編代碼中的初始化
   * 注意
     所入返回棧的應該是 jojo 而不是 jo
** begin_to_interpret_threaded_code   :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented

      call __reset_argument_stack
      call __reset_return_stack

      pop_return_stack rax
      mov rax, jojo_for__report_return_stack_is_empty_and_exit
      push_return_stack rax

      mov rax, address$local_data_heap
      push_return_stack rax

      mov rax, address$local_data_vector
      push_return_stack rax

      mov rax, first_jojo
      push_return_stack rax
      next

   first_jojo:
      ;; xx little_test
      xx initialization
      xx load_core_file
      xx taca, basic_REPL

   }
   #+end_src
** ----------------------------------
** note top-level-REPL
   * a top-level-REPL always lives at the bottom of return-stack
     #+begin_src return-stack
               (function)
               (function)
     - [@][@][ (taca) ]
               (top-level-REPL)
     #+end_src
   * right below the return-stack
     there is a (report-return-stack-is-empty-and-exit)
     so actually
     #+begin_src return-stack
                                                             (function)
                                                             (function)
     - [ (report-return-stack-is-empty-and-exit) ] - [@][@][ (taca) ]
                                                             (top-level-REPL)
     #+end_src
   * when you say bye to a top-level-REPL
     (report-return-stack-is-empty-and-exit) will be executed
** report-return-stack-is-empty-and-exit
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$report_return_stack_is_empty_and_exit:
      db "* the return-stack is empty now", 10
      db "* good bye ^-^/", 10
   .end:
   length$report_return_stack_is_empty_and_exit = (.end - string$report_return_stack_is_empty_and_exit)

   define_primitive_function "report-return-stack-is-empty-and-exit", report_return_stack_is_empty_and_exit
      ;; << -- >>
      mov rax, string$report_return_stack_is_empty_and_exit
      mov rcx, length$report_return_stack_is_empty_and_exit
      push_argument_stack rax
      push_argument_stack rcx
      call __print_string
      call __exit_with_zero

   jojo_for__report_return_stack_is_empty_and_exit:
      xx report_return_stack_is_empty_and_exit
   #+end_src
** reset-top-level-REPL
   * local_data_vector & local_data_heap
     will get reseted in by this function
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
      ;; << top_level_REPL [jo] -- >>
      call __reset_return_stack
      call __reset_local_data_vector
      call __reset_local_data_heap
      pop_argument_stack rax
      jmp qword [rax]

   }

   match =32bit, machine {

   define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
      ;; << top_level_REPL [jo] -- >>
      call __reset_return_stack
      call __reset_local_data_vector
      call __reset_local_data_heap
      pop_argument_stack rax
      jmp dword [rax]

   }
   #+end_src
** ----------------------------------
** exit_with_TOS a.k.a. bye
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bye", exit_with_TOS
      call __exit_with_TOS
   #+end_src
** ----------------------------------
** little_test
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", V__little_test_number
      xx 3

   define_function "little_test", little_test

      ;;;; variable
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 3

      ;;;; literal
      ;; xx literal, 4
      ;; xx exit_with_TOS
      ;;;; exit ocde : 4

      ;;;; address
      ;; xx address, V__little_test_number, fetch, add2
      ;; xx address, V__little_test_number, save
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 5

      ;;;; end
      ;; xx literal, 2, negate
      ;; xx literal, 8
      ;; xx addition
      ;; xx exit_with_TOS
      ;;;; 6

      ;;;; taca
      ;; xx literal, 2
      ;; xx literal, 4
      ;; xx power
      ;; xx exit_with_TOS
      ;;;; exit ocde : 16

      ;;;; write_byte
      ;; xx literal, 64, write_byte
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; @

      ;;;; read_byte
      ;; xx read_byte, write_byte
      ;; xx exit_with_TOS
      ;;;;

      ;;;; branch
      ;; xx read_byte, write_byte
      ;; xx branch, -3
      ;;;; read a string that ended by <return>
      ;;;; write the readed string
      ;;;; or we can say
      ;;;; read line and write line
      ;;;; or we can say
      ;;;; echo line

      ;;;; false?branch
      ;; xx false, false?branch, 9
      ;; xx   literal, 64, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx true, false?branch, 9
      ;; xx   literal, 65, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; A

      ;;;; read_word & write_string
      ;; xx read_word, write_string
      ;; xx literal, 10, write_byte
      ;; xx read_word_for_REPL, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; read line
      ;;;; write first two words of the line

      ;;;; string->integer
      ;; xx read_word, string_to_integer
      ;; xx exit_with_TOS
      ;;;; type 123
      ;;;; exit code 123

      ;;;; use jo_to_name to test the macro make_primitive_string
      ;; xx literal, jo_to_name, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx literal, addition, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; print "jo->name"
      ;;;; print "add"

      ;;;; xxoverxx
      ;; xx literal, 1
      ;; xx literal, 2
      ;; xx literal, 3
      ;; xx literal, 4
      ;; xx xxoverxx
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 2 1 4 3 2 1

      ;;;; find
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, find ;; add
      ;; xx drop ;; true
      ;; xx execute_jo
      ;; xx write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 1 2 add
      ;;;; print "3"

      ;;;; basic-REPL (without the ability to define function)
      ;;;; after this test
      ;;;; we will use basic-REPL to do further tests
      ;; xx basic_REPL
      ;;;; 1 2 add .
   #+end_src
** ----------------------------------
* -----------------------------------
* instruction
** ----------------------------------
** note side-effect
   * an instruction
     is a special primitive function
     which does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
** note naming
   * the naming convention in assembly code
     of instruction
     is the same as it of jo
   * the name of an instruction
     might not be exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
** ----------------------------------
** literal
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; << -- fixnum >>
      pop_return_stack rbx
        mov rax, [rbx]
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address
      ;; << -- address >>
      pop_return_stack rbx
        mov rax, [rbx]
        add rax, jo_size
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*branch*", V__branch
      xx branch

   define_primitive_function "", branch
      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*false?branch*", V__false?branch
      xx false?branch

   define_primitive_function "", false?branch
      ;; << true of false -- >>
      pop_argument_stack rax
      test rax, rax
      jnz help__false?branch__not_to_branch

      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next

   help__false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** note action of prepare_for
   1. proper exception handling
      is implemented by doing side-effect on return-stack
   2. when executing the following code block
      #+begin_src fasm
      xx prepare_for
      xx exception_head
      xx   !exception_1
      xx   !exception_2
      xx   end
      xx function_1
      xx function_2
      xx end
      #+end_src
   3. note that
      for (prepare_for)
      (end) is used as an unique id
      but not a ending-jo
   3. return-stack
      #+begin_src return-stack
      - [@][@][ (prepare_for) ]
                  (exception_head)
                  (!exception_1)
                  (!exception_2)
                  (end)
                (function_1)
                (function_2)
                (end)
      #+end_src
   4. next
      * this is how the return-stack looks
        right before exception_head is executed
        #+begin_src return-stack
                (prepare_for)
        - [@][@][ (exception_head) ]
                  (!exception_1)
                  (!exception_2)
                  (end)
                (function_1)
                (function_2)
                (end)
        #+end_src
      * after exception_head is executed
        #+begin_src return-stack
                                            (prepare_for)
                                              (exception_head)
                                              (!exception_1)
                                              (!exception_2)
             (prepare_for)                    (end)
        - [@][ (exception_head) ] - [@][@][ (function_1) ]
               (!exception_1)               (function_2)
               (!exception_2)               (end)
               (end)
             (function_1)
             (function_2)
             (end)
        #+end_src
** prepare_for                        :64bit:
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "", prepare_for
      ;; << -- >>
      pop_return_stack rbx

      pop_return_stack rcx
      pop_return_stack rdx

      push_return_stack pointer$argument_stack
      push_return_stack rbx

      push_return_stack rdx
      push_return_stack rcx

   .next:
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, end
      je .then
      jmp .next
   .then:
      add rbx, jo_size
      push_return_stack rbx
      next

   }
   #+end_src
** prepare_for                        :32bit:
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "", prepare_for
      ;; << -- >>
      pop_return_stack ebx

      pop_return_stack ecx
      pop_return_stack edx

      mov eax, [pointer$argument_stack]
      push_return_stack eax
      push_return_stack ebx

      push_return_stack edx
      push_return_stack ecx

   .next:
      add ebx, jo_size
      mov eax, dword [ebx]
      cmp eax, end
      je .then
      jmp .next
   .then:
      add ebx, jo_size
      push_return_stack ebx
      next

   }
   #+end_src
** *prepare-for*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*prepare-for*", V__prepare_for
      xx prepare_for
   #+end_src
** note action of exception_head
   * return-stack
     #+begin_src return-stack
          (prepare_for)
     - [@][ (exception_head) ]
            (!exception_1)
            (!exception_2)
            (end)
          (function_1)
          (function_2)
          (end)
     #+end_src
   * next
     * this is how the return-stack looks
       right before exception_head is executed
       #+begin_src return-stack
            (prepare_for)
              (exception_head)
       - [@][ (!exception_1) ]
              (!exception_2)
              (end)
            (function_1)
            (function_2)
            (end)
       #+end_src
     * after exception_head is executed
       the above two value in return-stack is removed
       note that
       only two value (not three)
       #+begin_src return-stack
       - [ ]
       #+end_src
** exception_head
   * this jo is served as a label in return-stack
     when explained
     it pops the jojo itself in
     and
     it pops the argument-stack pointer after it
   * and "explain$exception" will search for them
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", exception_head
      ;; << -- >>
      pop_return_stack rax
      pop_return_stack rax
      next
   #+end_src
** *exception-head*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*exception-head*", V__exception_head
      xx exception_head
   #+end_src
** ----------------------------------
* -----------------------------------
* the stack
** ----------------------------------
** note
   * the stack is the argument-stack
** ----------------------------------
** drop
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "drop", drop
      ;; << a -- >>
      pop_argument_stack rax
      next

   define_primitive_function "drop2", drop2
      ;; << a b -- >>
      pop_argument_stack rax
      pop_argument_stack rax
      next
   #+end_src
** dup                                :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "dup", dup
      ;; << a -- a, a >>
      mov  rax, [pointer$argument_stack - (1 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      mov  rbx, [pointer$argument_stack - (1 * jo_size)]
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      push_argument_stack rbx
      next

   }
   #+end_src
** dup                                :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "dup", dup
      ;; << a -- a a >>
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   }
   #+end_src
** over                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxxx", xoverxxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (5 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      next

   }
   #+end_src
** over                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxxx", xoverxxxx
      ;; << a | b c d -- a | b c d | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (5 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (6 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (5 * jo_size)]
      push_argument_stack rax
      next

   }
   #+end_src
** tuck
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tuck", tuck
      ;; << a b -- b | a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|tuck|xx", xtuckxx
      ;; << a | b c -- b c | a | b c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|x", xxtuckx
      ;; << a b | c -- c | a b | c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|xx", xxtuckxx
      ;; << a b | c d -- c d | a b | c d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   define_primitive_function "xxx|tuck|x", xxxtuckx
      ;; << a b c | d -- d | a b c | d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
** swap                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack rax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   }
   #+end_src
** swap                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack eax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack eax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next

   }
   #+end_src
** ----------------------------------
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*the-stack*", V__the_stack
      xx address$argument_stack
   #+end_src
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
      xx address$argument_stack

   define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
      ;; << -- >>
      mov [V__the_stack_pointer_snapshot + jo_size], pointer$argument_stack
      next

   }
   #+end_src
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
      xx address$argument_stack

   define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
      ;; << -- >>
      mov eax, [pointer$argument_stack]
      mov [V__the_stack_pointer_snapshot + jo_size], eax
      next

   }
   #+end_src
** ----------------------------------
* bool
** false & true
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "false", false
      ;; << -- false >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "true", true
      ;; << -- true >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** false? & true?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "false?", false?
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "true?", true?
      ;; << bool -- bool >>
      xx true, equal?
      xx end
   #+end_src
** and & or & not
   * the following two functions are for bool value
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "not", CICADA__not
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "and", CICADA__and
      ;; << bool, bool -- bool >>
      xx false?, false?branch, 4
      xx   drop
      xx   false
      xx   end
      xx false?branch, 3
      xx   true
      xx   end
      xx false
      xx end

   define_function "or", CICADA__or
      ;; << bool, bool -- bool >>
      xx false?branch, 4
      xx   drop
      xx   true
      xx   end
      xx false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
* fixnum
** ----------------------------------
** zero & one
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "zero", zero
      ;; << -- 0 >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "one", one
      ;; << -- 1 >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** zero? & one?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero?", zero?
      ;; << bool -- bool >>
      xx zero, equal?
      xx end

   define_function "one?", one?
      ;; << bool -- bool >>
      xx one, equal?
      xx end
   #+end_src
** ----------------------------------
** add & sub                          :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      inc qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      dec qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rax
      add qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rax
      sub qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   }
   #+end_src
** add & sub                          :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      pop_argument_stack rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      pop_argument_stack rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      pop_argument_stack rax
      add rax, 8
      push_argument_stack rax
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      pop_argument_stack rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      pop_argument_stack rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      pop_argument_stack rax
      sub rax, 8
      push_argument_stack rax
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      add rax, rbx
      push_argument_stack rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      sub rax, rbx
      push_argument_stack rax
      next

   }
   #+end_src
** mul
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "mul", multiple
      ;; << a b -- a*b >>
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next
   #+end_src
** negate
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negate", negate
      ;; << n --  -n >>
      xx zero
      xx swap, subtraction
      xx end
   #+end_src
** power
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "power", power
      ;; n must be nature number for now
      ;; << a, n -- a^n >>
      ;; 1. when a = 0, n =/= 0
      ;;    the power__loop returns 0
      ;; 2. when a = 0, n = 0
      ;;    the power__loop returns 1
      ;;    but I need it to return 0
      xx over, zero?, false?branch, 3
      xx   drop
      xx   end
      xx literal, 1, swap ;; leave product
      xx power__loop
      xx end

   define_function "power,loop", power__loop
      ;; << a, product, n -- a^n >>
      xx dup, zero?, false?branch, 5
      xx   drop, swap, drop
      xx   end
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx taca, power__loop
   #+end_src
** div & mod
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "moddiv", moddiv
      ;; << a, b -- a mod b, quotient >>
      ;; << dividend, divisor -- remainder, quotient >>
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   define_function "divmod", divmod
      ;; << a, b -- quotient, a mod b >>
      xx moddiv, swap
      xx end

   define_function "div", division
      ;; << a, b -- quotient >>
      xx divmod, drop
      xx end

   define_function "mod", modulo
      ;; << a, b -- a mod b >>
      xx moddiv, drop
      xx end
   #+end_src
** ----------------------------------
** equal? & greater-than? & less-than?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "equal?", equal?
      ;; << a, b -- bool >>
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "less-than?", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-than?", greater_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   define_primitive_function "less-or-equal?", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-or-equal?", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** equal2?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "equal2?", equal2?
      ;; << a1, b1, a2, b2 -- bool >>
      xx xswapxx
      xx equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx equal?
      xx end
   #+end_src
** negative? & positive?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negative?", negative?
      ;; << integer -- bool >>
      xx zero, less_than?
      xx end

   define_function "positive?", positive?
      ;; << integer -- bool >>
      xx zero, greater_than?
      xx end
   #+end_src
** ----------------------------------
* memory
** note
   * although the following functions are all side-effect
     but I use "save" instead of "save!"
** save                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; "save" and "fetch" default to a jo_size
   ;; the rule of "fetch2" and so on are:
   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ||  1 : value-2  ||
   ;;     ||  1 : value-3  ||
   ;;     ...
   ;;   on stack:
   ;;     << value-1, value-2, value-3, ... >>
   ;; of course we have:
   ;;   fetch2 : memory=copy=>stack
   ;;   save2  : stack->memory

   define_primitive_function "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov [rbx], rax
      next

   define_primitive_function "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   define_primitive_function "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   define_primitive_function "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   define_primitive_function "n-save", n_save
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, jo_size
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, jo_size
   .loop:
      pop_argument_stack rax
      mov qword [rdx], rax
      sub rdx, jo_size
      loop .loop
      next

   define_function "save2", save2
      ;; << value-2, value-1, address -- >>
      xx literal, 2
      xx n_save
      xx end

   define_primitive_function "n-save-byte", n_save_byte
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      add rdx, rcx
      dec rdx
   .loop:
      pop_argument_stack rax
      mov byte [rdx], al
      dec rdx
      loop .loop
      next

   define_primitive_function "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add qword [rbx], rax
      next

   define_primitive_function "sub-save", sub_save
      ;; ( number to sub, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub qword [rbx], rax
      next

   }
   #+end_src
** fetch                              :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword [rbx]
      push_argument_stack rax
      next

   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ...
   ;;     ||  1 : value-n  ||
   define_primitive_function "n-fetch", n_fetch
      ;; << address, n -- value-1, ..., value-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, qword [rdx]
      push_argument_stack rax
      add rdx, jo_size
      loop .loop
      next

   define_primitive_function "n-fetch-byte", n_fetch_byte
      ;; << address, n -- byte-1, ..., byte-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
      xor rax, rax
   .loop:
      mov al, byte [rdx]
      push_argument_stack rax
      inc rdx
      loop .loop
      next

   define_function "fetch2", fetch2
      ;; << address -- value-1, value-2 >>
      xx literal, 2
      xx n_fetch
      xx end

   }
   #+end_src
** save                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   ;; "save" and "fetch" default to a jo_size
   ;; the rule of "fetch2" and so on are:
   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ||  1 : value-2  ||
   ;;     ||  1 : value-3  ||
   ;;     ...
   ;;   on stack:
   ;;     << value-1, value-2, value-3, ... >>
   ;; of course we have:
   ;;   fetch2 : memory=copy=>stack
   ;;   save2  : stack->memory

   define_primitive_function "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov [rbx], rax
      next

   define_primitive_function "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   define_primitive_function "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   define_primitive_function "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   define_primitive_function "n-save", n_save
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, jo_size
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, jo_size
   .loop:
      pop_argument_stack rax
      mov dword [rdx], rax
      sub rdx, jo_size
      loop .loop
      next

   define_function "save2", save2
      ;; << value-2, value-1, address -- >>
      xx literal, 2
      xx n_save
      xx end

   define_primitive_function "n-save-byte", n_save_byte
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      add rdx, rcx
      dec rdx
   .loop:
      pop_argument_stack rax
      mov byte [rdx], al
      dec rdx
      loop .loop
      next

   define_primitive_function "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add dword [rbx], rax
      next

   define_primitive_function "sub-save", sub_save
      ;; ( number to sub, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub dword [rbx], rax
      next

   }
   #+end_src
** fetch                              :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword [rbx]
      push_argument_stack rax
      next

   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ...
   ;;     ||  1 : value-n  ||
   define_primitive_function "n-fetch", n_fetch
      ;; << address, n -- value-1, ..., value-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, dword [rdx]
      push_argument_stack rax
      add rdx, jo_size
      loop .loop
      next

   define_primitive_function "n-fetch-byte", n_fetch_byte
      ;; << address, n -- byte-1, ..., byte-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
      xor rax, rax
   .loop:
      mov al, byte [rdx]
      push_argument_stack rax
      inc rdx
      loop .loop
      next

   define_function "fetch2", fetch2
      ;; << address -- value-1, value-2 >>
      xx literal, 2
      xx n_fetch
      xx end

   }
   #+end_src
** clear
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "clear-memory", clear_memory
      ;; << size, address -- >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      xor rax, rax
   .loop:
      mov byte [rdx], al
      inc rdx
      dec rcx
      loop .loop
      next
   #+end_src
* bit
** note
** or & and & xor & invert            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "bitwise-and", bitwise_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      and [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-or", bitwise_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      or  [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-xor", bitwise_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      xor [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-invert", bitwise_invert
      ;; << a -- invert a >>
      not qword [pointer$argument_stack - (1 * jo_size)]
      next

   }
   #+end_src
** or & and & xor & invert            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "bitwise-and", bitwise_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      and [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-or", bitwise_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      or  [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-xor", bitwise_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      xor [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-invert", bitwise_invert
      ;; << a -- invert a >>
      mov rax, [pointer$argument_stack]
      not dword [rax - (1 * jo_size)]
      next

   }
   #+end_src
* -----------------------------------
* basic io
** ----------------------------------
** note byte
   * basic io is about byte
** ----------------------------------
** write-byte                         :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al
      mov linux64_sys_3_rdx, 1                 ;; max length to be write
      mov linux64_sys_2_rsi, buffer$write_byte ;; address
      mov linux64_sys_1_rdi, 1                 ;; stdout
      mov linux64_sys_n_rax, linux64_syscall_write
      syscall
      next

   }
   #+end_src
** write-byte                         :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al
      mov linux32_sys_3_edx, 1                 ;; max length to be write
      mov linux32_sys_2_ecx, buffer$write_byte ;; address
      mov linux32_sys_1_ebx, 1                 ;; stdout
      mov linux32_sys_n_eax, linux32_syscall_write
      syscall
      next

   }
   #+end_src
** ----------------------------------
** note
   * do not exit the program
     when meeting <end-of-file>
     so
     when you hit <C-d>
     some you will not exit the interpreter
   * add the feature to unread one ket-char
** note factoring
   * reading from file of stdin is slow
     thus
     1. when reading from file
        a whole file is readed at a time
        and saved to a buffer
     2. when reading from stdin
        a whole line is readed at a time
     3. note that
        reading line instead of keyboard-code
        will limit the design of the user interface
   * by factoring out the low-level calls
     that read a line from stdin
     we are able to implement eval-string easily
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_input_length = 1024 * 1024

   buffer$read_byte labeling
      preserve max_input_length
   #+end_src
** read-line-from-stdin               :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "read-line-from-stdin", read_line_from_stdin
      ;; << buffer address, max length -- counter >>
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      xor linux64_sys_1_rdi, linux64_sys_1_rdi ;; stdin
      mov linux64_sys_n_rax, linux64_syscall_read
      syscall
      ;; the return value
      ;; is a count of the number of bytes transferred
      push_argument_stack rax
      next

   }
   #+end_src
** read-line-from-stdin               :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "read-line-from-stdin", read_line_from_stdin
      ;; << buffer address, max length -- counter >>
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_2_ecx
      xor linux32_sys_1_ebx, linux32_sys_1_ebx ;; stdin
      mov linux32_sys_n_eax, linux32_syscall_read
      syscall
      ;; the return value
      ;; is a count of the number of bytes transferred
      push_argument_stack rax
      next

   }
   #+end_src
** test read-line-from-stdin
   #+begin_src fasm
   define_function "", test__read_line_from_stdin
      xx literal, buffer$read_byte
      xx literal, max_input_length
      xx read_line_from_stdin
      xx pretty_write_integer
      xx literal, buffer$read_byte
      xx literal, 10
      xx write_string
      xx exit_with_TOS
      xx end
   #+end_src
** read-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx have_unreaded_ket_char?, false?branch, 9
      xx   literal, char$unreaded_ket_char, fetch_byte
      xx   zero, literal, flag$unreaded_ket_char
      xx   save
      xx   end
      xx read_byte__without_unread
      xx end

   define_function "read-byte,without-unread", read_byte__without_unread
      ;; << -- byte >>
      xx eval_string_stack_empty?, false?branch, (.not_empty-$)/jo_size
      xx   literal, buffer$read_byte
      xx   literal, max_input_length
      xx   read_line_from_stdin
      xx     dup, positive?, false?, false?branch, 4
      ;;     ignore <end-of-file>
      ;;     ignore reading error
      xx     drop
      xx     taca, read_byte__without_unread
      xx   push_eval_string_stack
      xx   literal, buffer$read_byte
      xx   push_eval_string_stack
      xx   taca, read_byte__without_unread
      .not_empty:
      xx pop_eval_string_stack
      xx pop_eval_string_stack
      xx dup, zero?, false?branch, 4
      xx   drop2
      xx   taca, read_byte__without_unread
      xx sub1, push_eval_string_stack
      xx dup
      xx add1, push_eval_string_stack
      xx fetch_byte
      xx end
   #+end_src
** unread-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   flag$unreaded_ket_char:
      xx 0

   char$unreaded_ket_char:
      xx 0

   define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
      ;; << -- bool >>
      xx literal, flag$unreaded_ket_char
      xx fetch
      xx end

   define_function "unread-ket-char", unread_ket_char
      ;; << char -- >>
      xx literal, char$unreaded_ket_char, save
      xx true, literal, flag$unreaded_ket_char
      xx save
      xx end
   #+end_src
** ----------------------------------
* eval-string
** note
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   * the size$eval_string_stack
     defines the max depth
     of nested call to eval string
   * cursor and border of a evaled string
     can be stored in eval_string_stack
     so
     when evaling a string
     the eval_string_stack will be
     << counter, cursor >>
     when evaling is nested depth is 2
     << counter, cursor, counter, cursor >>
   * interface to eval-string-stack
     | eval-string | push |
     | read-byte   | pop  |
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$eval_string_stack = 1024 * jo_size

      preserve 64 * jo_size
   address$eval_string_stack labeling
      preserve size$eval_string_stack
   #+end_src
** pointer
   #+begin_src fasm :tangle cicada-nymph.fasm
   pointer$eval_string_stack:
      xx address$eval_string_stack
   #+end_src
** push & pop                         :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

    define_primitive_function "push-eval-string-stack", push_eval_string_stack
       ;; argument-stack -> eval-string-stack
       pop_argument_stack rax
       mov rbx, [pointer$eval_string_stack]
       mov [rbx], rax
       add qword [pointer$eval_string_stack], jo_size
       next

    define_primitive_function "pop-eval-string-stack", pop_eval_string_stack
       ;; eval-string-stack -> argument-stack
       sub qword [pointer$eval_string_stack], jo_size
       mov rbx, [pointer$eval_string_stack]
       mov rax, [rbx]
       push_argument_stack rax
       next

   }
   #+end_src
** push & pop                         :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

    define_primitive_function "push-eval-string-stack", push_eval_string_stack
       ;; argument-stack -> eval-string-stack
       pop_argument_stack rax
       mov rsi, [pointer$eval_string_stack]
       mov [rsi], rax
       add dword [pointer$eval_string_stack], jo_size
       next

    define_primitive_function "pop-eval-string-stack", pop_eval_string_stack
       ;; eval-string-stack -> argument-stack
       sub dword [pointer$eval_string_stack], jo_size
       mov rsi, [pointer$eval_string_stack]
       mov rax, [rsi]
       push_argument_stack rax
       next

   }
   #+end_src
** clear                              :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "clear-eval-string-stack", clear_eval_string_stack
      ;; << -- >>
      mov qword [pointer$eval_string_stack], address$eval_string_stack
      next

   }
   #+end_src
** clear                              :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "clear-eval-string-stack", clear_eval_string_stack
      ;; << -- >>
      mov eax, address$eval_string_stack
      mov dword [pointer$eval_string_stack], eax;address$eval_string_stack
      next

   }
   #+end_src
** empty?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "eval-string-stack-empty?", eval_string_stack_empty?
      ;; << -- bool >>
      mov rax, [pointer$eval_string_stack]
      cmp rax, address$eval_string_stack
      ;; less-than is treated as equal
      setle al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** note nested call of eval-string
   * nested call of eval-string is handled
     by using a eval_string_stack
     to remember the old string
   * but
     in my view
     meta-programming should NOT
     be achieved by editing string
   * note that
     this point of view
     is not conflict with my macro system
** eval-string,ready
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "eval-string,ready", eval_string__ready
      ;; << string[address, length] -- unknown >>
      xx push_eval_string_stack
      xx push_eval_string_stack
      xx end
   #+end_src
* -----------------------------------
* port
** ----------------------------------
** open-input-port                    :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   name_buffer$open_input_port labeling
      preserve 512

   define_primitive_function "open-input-port", open_input_port
      ;; << file-name-string[address, length] --
      ;;    [file handle] or [error code] >>
      pop_argument_stack rcx
      pop_argument_stack rsi
      ;; copy file-name as a null-terminal string
      mov rdi, name_buffer$open_input_port
      rep movsb
      xor rax, rax
      mov byte [rdi], al
      mov linux64_sys_2_rsi, 0 ;; OPEN__read_only
      mov linux64_sys_1_rdi, name_buffer$open_input_port
      mov linux64_sys_n_rax, linux64_syscall_open
      syscall
      push_argument_stack rax
      next

   }
   #+end_src
** close-port                         :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "close-port", close_port
      ;; << file-handle -- >>
      pop_argument_stack linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_close
      syscall
      next

   }
   #+end_src
** read-port                          :64bit:linux:
   * from disk to memory
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "read-port", read_port
      ;; << [file handle], buffer[address, length] --
      ;;    [number of char] or [error code] >>
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_read
      syscall
      push_argument_stack rax
      next

   }
   #+end_src
** ----------------------------------
** open-input-port                    :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   name_buffer$open_input_port labeling
      preserve 512

   define_primitive_function "open-input-port", open_input_port
      ;; << file-name-string[address, length] --
      ;;    [file handle] or [error code] >>
      pop_argument_stack rcx
      pop_argument_stack rsi
      ;; copy file-name as a null-terminal string
      mov rdi, name_buffer$open_input_port
      rep movsb
      xor rax, rax
      mov byte [rdi], al
      mov linux32_sys_2_ecx, 0 ;; OPEN__read_only
      mov linux32_sys_1_ebx, name_buffer$open_input_port
      mov linux32_sys_n_eax, linux32_syscall_open
      syscall
      push_argument_stack rax
      next

   }
   #+end_src
** close-port                         :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "close-port", close_port
      ;; << file-handle -- >>
      pop_argument_stack linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_close
      syscall
      next

   }
   #+end_src
** read-port                          :32bit:linux:
   * from disk to memory
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "read-port", read_port
      ;; << [file handle], buffer[address, length] --
      ;;    [number of char] or [error code] >>
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_read
      syscall
      push_argument_stack rax
      next

   }
   #+end_src
** ----------------------------------
* system environment
** ----------------------------------
** note two directories
   * all files about cicada
     are stored in two directories only
     1. user :
        "/home/<user>/.cicada"
     2. system :
        "/etc/cicada"
   * note that
     the convention of linux is not followed
     "/share" and "/include" are not used
** note linux system environment
   * pid is the key to all the linux system environment
   * command-line
     /proc/<pid>/cmdline
   * environment-string-variable-list
     /proc/<pid>/environ
** ----------------------------------
** init-operating-system-environment  :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   define_function "init-operating-system-environment", init_operating_system_environment
      ;; << -- >>
      xx init_pid
      xx init_command_line
      xx init_environment_string_variable_list
      xx end

   }
   #+end_src
** ----------------------------------
** init-pid                           :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "init-pid", init_pid
      ;; << -- pid >>
      mov linux64_sys_n_rax, linux64_syscall_getpid
      syscall
      mov [value$get_pid], rax
      next

   }
   #+end_src
** init-pid                           :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "init-pid", init_pid
      ;; << -- pid >>
      mov linux32_sys_n_eax, linux32_syscall_getpid
      syscall
      mov [value$get_pid], rax
      next

   }
   #+end_src
** get-pid                            :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   value$get_pid:
      xx 2

   define_function "get-pid", get_pid
      ;; << -- pid >>
      xx literal, value$get_pid, fetch
      xx end

   }
   #+end_src
** ----------------------------------
** [init|get]-command-line            :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   file$init_command_line:
      db "/cmdline" ;; length of 8

   path$init_command_line:
      db "/proc/"   ;; length of 6
   pid$init_command_line:
      db "********************************"

   address$init_command_line:
      times 512 db 0
   length$init_command_line:
      xx 0

   define_function "init-command-line", init_command_line
      ;; << -- >>
      xx get_pid
      xx write_nature_number__fill_buffer
      xx tuck
      xx literal, pid$init_command_line
      xx string_to_buffer!
      xx literal, file$init_command_line
      xx literal, 8
      xx literal, pid$init_command_line
      xx xoverxxx, addition
      xx string_to_buffer!
      xx literal, path$init_command_line
      xx swap
      xx literal, 8, addition
      xx literal, 6, addition
      xx open_input_port
      xx literal, address$init_command_line
      xx literal, 512
      xx read_port
      xx literal, length$init_command_line
      xx save
      xx end

   define_function "get-command-line", get_command_line
      ;; << -- string[address, length] >>
      xx literal, address$init_command_line
      xx literal, length$init_command_line, fetch
      xx end

   }
   #+end_src
** [init|get]-environment-string-variable-list :linux:
   * the size of /proc/<pid>/environ is limited to 4k
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   file$init_environment_string_variable_list:
      db "/environ" ;; length of 8

   path$init_environment_string_variable_list:
      db "/proc/"   ;; length of 6
   pid$init_environment_string_variable_list:
      db "********************************"

   address$init_environment_string_variable_list:
      times (4 * 1024) db 0
   length$init_environment_string_variable_list:
      xx 0

   define_function "init-environment-string-variable-list", init_environment_string_variable_list
      ;; << -- >>
      xx get_pid
      xx write_nature_number__fill_buffer
      xx tuck
      xx literal, pid$init_environment_string_variable_list
      xx string_to_buffer!
      xx literal, file$init_environment_string_variable_list
      xx literal, 8
      xx literal, pid$init_environment_string_variable_list
      xx xoverxxx, addition
      xx string_to_buffer!
      xx literal, path$init_environment_string_variable_list
      xx swap
      xx literal, 8, addition
      xx literal, 6, addition
      xx open_input_port
      xx literal, address$init_environment_string_variable_list
      xx literal, (4 * 1024)
      xx read_port
      xx literal, length$init_environment_string_variable_list
      xx save
      xx end

   define_function "get-environment-string-variable-list", get_environment_string_variable_list
      ;; << -- string[address, length] >>
      xx literal, address$init_environment_string_variable_list
      xx literal, length$init_environment_string_variable_list, fetch
      xx end

   }
   #+end_src
** ----------------------------------
** find-environment-string-variable   :linux:
   * the string used to find an environment-string-variable
     can not contain "="
     no error handling on this
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   define_function "find-environment-string-variable", find_environment_string_variable
      ;; << string[address, length]
      ;;    -- string[address, length], true
      ;;    -- false >>
      xx literal, address$init_environment_string_variable_list ;; cursor
      xx find_environment_string_variable__loop
      xx end

   define_function "find-environment-string-variable,loop", find_environment_string_variable__loop
      ;; << string[address, length], cursor
      ;;    -- string[address, length], true
      ;;    -- false >>
      xx dup
      xx literal, address$init_environment_string_variable_list
      xx literal, length$init_environment_string_variable_list, fetch
      xx addition
      xx greater_than?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx xxoverx, xoverxx, swap
      xx compare_buffer, false?, false?branch, 7
      xx   literal, 0
      xx   cursor_to_next_matching_byte
      xx   add1
      xx   taca, find_environment_string_variable__loop
      xx dup, xoverxx, addition, fetch_byte
      xx literal, '=', equal?, false?, false?branch, 7
      xx   literal, 0
      xx   cursor_to_next_matching_byte
      xx   add1
      xx   taca, find_environment_string_variable__loop
      xx xswapxx, drop
      xx addition, add1
      xx dup
      xx literal, 0
      xx cursor_to_next_matching_byte
      xx over, subtraction
      xx true
      xx end

   }
   #+end_src
** ----------------------------------
** [init|get]-path,home-directory     :linux:
   * need error handling
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   string$init_path__home_directory:
      db "HOME"

   define_function "init-path,home-directory", init_path__home_directory
      ;; << -- >>
      xx literal, string$init_path__home_directory
      xx literal, 4
      xx find_environment_string_variable
      xx drop
      xx dup
      xx literal, length$get_path__home_directory
      xx save
      xx literal, string$get_path__home_directory
      xx string_to_buffer!
      xx end

   string$get_path__home_directory:
      times 512 db 0
   length$get_path__home_directory:
      xx 0

   define_function "get-path,home-directory", get_path__home_directory
      ;; << -- string[address, length] >>
      xx literal, string$get_path__home_directory
      xx literal, length$get_path__home_directory, fetch
      xx end

   }
   #+end_src
** [init|get]-path,working-directory  :linux:
   * need error handling
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   string$init_path__working_directory:
      db "PWD"

   define_function "init-path,working-directory", init_path__working_directory
      ;; << -- >>
      xx literal, string$init_path__working_directory
      xx literal, 3
      xx find_environment_string_variable
      xx drop
      xx dup
      xx literal, length$get_path__working_directory
      xx save
      xx literal, string$get_path__working_directory
      xx string_to_buffer!
      xx end

   string$get_path__working_directory:
      times 512 db 0
   length$get_path__working_directory:
      xx 0

   define_function "get-path,working-directory", get_path__working_directory
      ;; << -- string[address, length] >>
      xx literal, string$get_path__working_directory
      xx literal, length$get_path__working_directory, fetch
      xx end

   }
   #+end_src
** [init|get]-path,user-core-file     :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   string$init_path__user_core_file:
      db "/.cicada/core.cn"
   .end:
   length$init_path__user_core_file = (.end - string$init_path__user_core_file)


   define_function "init-path,user-core-file", init_path__user_core_file
      ;; << -- >>
      xx get_path__home_directory
      xx tuck
      xx literal, string$get_path__user_core_file
      xx string_to_buffer!

      xx literal, string$init_path__user_core_file
      xx literal, length$init_path__user_core_file
      xx xoverxx
      xx literal, string$get_path__user_core_file
      xx addition
      xx string_to_buffer!

      xx literal, length$init_path__user_core_file
      xx addition
      xx literal, length$get_path__user_core_file
      xx save
      xx end

   string$get_path__user_core_file:
      times 510 db 0

   length$get_path__user_core_file:
      xx 0

   define_function "get-path,user-core-file", get_path__user_core_file
      ;; << -- string[address, length] >>
      xx literal, string$get_path__user_core_file
      xx literal, length$get_path__user_core_file, fetch
      xx end

   }
   #+end_src
** get-path,system-core-file          :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   string$get_path__system_core_file:
      db "/etc/cicada/core.cn"
   .end:
   length$get_path__system_core_file = (.end - string$get_path__system_core_file)

   define_function "get-path,system-core-file", get_path__system_core_file
      ;; << -- string[address, length] >>
      xx literal, string$get_path__system_core_file
      xx literal, length$get_path__system_core_file
      xx end

   }
   #+end_src
** get-path,loaded-core-file          :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   string$get_path__loaded_core_file:
      times 510 db 0

   length$get_path__loaded_core_file:
      xx 0

   define_function "get-path,loaded-core-file", get_path__loaded_core_file
      ;; << -- string[address, length] >>
      xx literal, string$get_path__loaded_core_file
      xx literal, length$get_path__loaded_core_file, fetch
      xx end

   }
   #+end_src
** ----------------------------------
* to load core file
** path-file?
   #+begin_src fasm :tangle cicada-nymph.fasm
   address$path_file?:
      db 0

   define_function "path-file?", path_file?
      ;; << path[address, length] -- bool >>
      xx open_input_port
      xx dup, negative?, false?branch, 4
      xx   drop
      xx   false
      xx   end
      xx dup
      xx literal, address$path_file?
      xx literal, 1
      xx read_port
      xx swap, close_port
      xx positive?, false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
** load-first-file
   * load is read and eval
   * load-first-file can not be nested
   * a function (load-file) will be implemented in core
     to support nested loading
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$load_first_file labeling
     preserve 128 * 1024

   define_function "load-first-file", load_first_file
      ;; << name-string[address, length] -- unknown >>
      xx open_input_port
      xx dup
      xx   literal, buffer$load_first_file ;; buffer
      xx   literal, 1024 * 1024      ;; length
      xx   read_port
      xx swap, close_port
      xx dup, positive?, false?branch, (.error-$)/jo_size
      xx   literal, buffer$load_first_file
      xx   swap
      xx   eval_string__ready
      xx   end
   .error:
      xx error_report__load_first_file
      xx write_integer
      xx literal, 10, write_byte
      xx end

   define_function "error-report,load-file", error_report__load_first_file
      ;; << -- >>
      xx literal, string$error_report__load_first_file
      xx literal, length$error_report__load_first_file
      xx write_string
      xx end

   string$error_report__load_first_file:
      db "* (load-file) meets error  (read-port) error code : "
   .end:
   length$error_report__load_first_file = (.end - string$error_report__load_first_file)
   #+end_src
** load-core-file                     :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   define_function "load-core-file", load_core_file
      ;; << unknown -- unknown >>
      xx get_path__user_core_file, path_file?, false?branch, (.fail_user_core_file-$)/jo_size
      xx   get_path__user_core_file
      xx   dup
      xx   literal, length$get_path__loaded_core_file
      xx   save
      xx   literal, string$get_path__loaded_core_file
      xx   string_to_buffer!
      xx   get_path__user_core_file, load_first_file
      xx   end
   .fail_user_core_file:

      xx get_path__system_core_file, path_file?, false?branch, (.fail_system_core_file-$)/jo_size
      xx   get_path__system_core_file
      xx   dup
      xx   literal, length$get_path__loaded_core_file
      xx   save
      xx   literal, string$get_path__loaded_core_file
      xx   string_to_buffer!
      xx   get_path__system_core_file, load_first_file
      xx   end
   .fail_system_core_file:

      xx literal, string$load_core_file__report_1
      xx literal, length$load_core_file__report_1
      xx write_string
      xx get_path__user_core_file, write_string
      xx literal, string$load_core_file__report_2
      xx literal, length$load_core_file__report_2
      xx write_string
      xx get_path__system_core_file, write_string
      xx literal, string$load_core_file__report_3
      xx literal, length$load_core_file__report_3
      xx write_string

      xx end

   string$load_core_file__report_1:
      db "* (load-core-file)", 10
      db "  * no core file is loaded", 10
      db "  * when cicada-nymph is started", 10
      db "    first", 10
      db "    it trys to load the user's core file from :", 10
      db "       "
   .end:
   length$load_core_file__report_1 = (.end - string$load_core_file__report_1)

   string$load_core_file__report_2:
      db 10
      db "    if it fails", 10
      db "    then", 10
      db "    it trys to load the system core file from :", 10
      db "       "
   .end:
   length$load_core_file__report_2 = (.end - string$load_core_file__report_2)

   string$load_core_file__report_3:
      db 10
      db "    if it fails", 10
      db "    no core file is loaded", 10
      db "  * now you are running cicada-nymph without core", 10
   .end:
   length$load_core_file__report_3 = (.end - string$load_core_file__report_3)

   }
   #+end_src
* -----------------------------------
* syscall
** note
   * there are two ways to treat the syscall
     1. syscall is NOT expose to cicada-nymph
        system functions are wraped in assembly code
        thus
        make cicada-nymph code be more clean
     2. syscall is expose to cicada-nymph
        system functions are wraped in cicada-nymph code
        thus
        more easy to wraped more system functions
        and
        make assembly code be more clean
        [only needs some system functions to load core file]
   * I choose the second way for now
** string->syscall-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$string_to_syscall_string:
      times 256 db 0

   define_function "string->syscall-string", string_to_syscall_string
      ;; << string[address, length] -- syscall-string[address] >>
      xx dup
      xx   literal, string$string_to_syscall_string
      xx   addition
      xx   literal, 0
      xx   swap, save_byte
      xx literal, string$string_to_syscall_string
      xx string_to_buffer!
      xx literal, string$string_to_syscall_string
      xx end
   #+end_src
** syscall                            :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "syscall", CICADA__syscall
      ;; << ..., argument2, argument1,
      ;;    syscall-number,
      ;;    number-of-arguments
      ;;    -- return-value >>
      pop_argument_stack rax
      cmp rax, 0
      je __syscall_with_0
      cmp rax, 1
      je __syscall_with_1
      cmp rax, 2
      je __syscall_with_2
      cmp rax, 3
      je __syscall_with_3
      cmp rax, 4
      je __syscall_with_4
      cmp rax, 5
      je __syscall_with_5
      cmp rax, 6
      je __syscall_with_6
      jmp __syscall_with_too_many

   __syscall_with_0:
      pop_argument_stack linux64_sys_n_rax
      syscall
      push_argument_stack rax
      next

   __syscall_with_1:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      syscall
      push_argument_stack rax
      next

   __syscall_with_2:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      syscall
      push_argument_stack rax
      next

   __syscall_with_3:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      syscall
      push_argument_stack rax
      next

   __syscall_with_4:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      syscall
      push_argument_stack rax
      next

   __syscall_with_5:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      pop_argument_stack linux64_sys_5_r9
      syscall
      push_argument_stack rax
      next

   __syscall_with_6:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      pop_argument_stack linux64_sys_5_r9
      pop_argument_stack linux64_sys_6_r8
      syscall
      push_argument_stack rax
      next

   __syscall_with_too_many:
      call __exit_with_six

   }
   #+end_src
** syscall                            :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "syscall", CICADA__syscall
      ;; << ..., argument2, argument1,
      ;;    syscall-number,
      ;;    number-of-arguments
      ;;    -- return-value >>
      pop_argument_stack rax
      cmp rax, 0
      je __syscall_with_0
      cmp rax, 1
      je __syscall_with_1
      cmp rax, 2
      je __syscall_with_2
      cmp rax, 3
      je __syscall_with_3
      cmp rax, 4
      je __syscall_with_4
      cmp rax, 5
      je __syscall_with_5
      jmp __syscall_with_too_many

   __syscall_with_0:
      pop_argument_stack linux32_sys_n_eax
      syscall
      push_argument_stack rax
      next

   __syscall_with_1:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      syscall
      push_argument_stack rax
      next

   __syscall_with_2:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      syscall
      push_argument_stack rax
      next

   __syscall_with_3:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      syscall
      push_argument_stack rax
      next

   __syscall_with_4:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_4_esi
      syscall
      push_argument_stack rax
      next

   __syscall_with_5:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_4_esi
      pop_argument_stack linux32_sys_5_edi
      syscall
      push_argument_stack rax
      next

   __syscall_with_too_many:
      call __exit_with_six

   }
   #+end_src
* -----------------------------------
* initialization
** initialization
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "initialization", initialization
      ;; << -- >>
      xx init_system
      xx init__rule_set__make_jojo
      xx end
   #+end_src
** initialize-system                  :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   define_function "init-system", init_system
      ;; << -- >>
      xx init_operating_system_environment
      xx init_path__home_directory
      xx init_path__user_core_file
      xx init_path__working_directory
      xx end

   }
   #+end_src
* -----------------------------------
* char
** space-char?
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-char?", space_char?
      ;; << char -- bool >>
      xx literal, 32
      xx less_or_equal?
      xx end
   #+end_src
** bar-ket-char?
   * () [] {}
     but not <>
   * double-quote is viewed as special bar-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "bar-ket-char?", bar_ket_char?
      ;; << char -- bool >>
      xx dup, literal, '(', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ')', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '[', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ']', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '{', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '}', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '"', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** digit-char?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-char?", digit_char?
      ;; << char -- bool >>
      xx dup, literal, '0', less_than?, false?branch, 4
      xx   drop, false
      xx   end
      xx dup, literal, '9', less_or_equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** digit-char->number & number->char-digit
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-char->number", digit_char_to_number
      ;; << char -- decimal-digit >>
      xx literal, '0'
      xx subtraction
      xx end

   define_function "number->char-digit", number_to_digit_char
      ;; << decimal-digit -- char >>
      xx literal, '0'
      xx addition
      xx end
   #+end_src
* buffer
** note
   * a buffer is a large vector
     and some functions do not care about how large it is
** compare-buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; return false when length == 0
   define_primitive_function "compare-buffer", compare_buffer
      ;; << address, address, length -- bool >>
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** cursor->next-matching-byte
   * note that
     it is the NEXT matching-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "cursor->next-matching-byte", cursor_to_next_matching_byte
      ;; << cursor, byte -- cursor new address >>
      xx over, add1, fetch_byte
      xx over, equal?, false?branch, 4
      xx   drop, add1
      xx   end
      xx swap
      xx add1, swap
      xx taca, cursor_to_next_matching_byte
   #+end_src
* string
** ----------------------------------
** note io about string
** write-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-string", write_string
      ;; << string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end
      xx sub1, swap
      xx dup, fetch_byte, write_byte
      xx add1, swap
      xx taca, write_string

   define_function ".s", ALIAS__write_string
      ;; << integer -- >>
      xx write_string
      xx end
   #+end_src
** pretty_write_string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pretty-write-string", pretty_write_string
      ;; << integer -- >>
      xx write_string
      xx literal, 10
      xx write_byte
      xx end
   #+end_src
** ----------------------------------
** string-equal?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-equal?", string_equal?
      ;; << string[address, length], string[address, length] -- bool >>
      xx xoverxx, equal?, false?branch, 4
      xx   swap
      xx   compare_buffer
      xx   end
      xx drop, drop2
      xx false
      xx end
   #+end_src
** string-[head|tail],char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,char", string_head__char
      ;; << string[address, length] -- char >>
      xx drop, fetch_byte
      xx end

   define_function "string-tail,char", string_tail__char
      ;; << string[address, length] -- [address + 1, length + 1] >>
      xx sub1, swap
      xx add1
      xx swap
      xx end
   #+end_src
** string->buffer!
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "string->buffer!", string_to_buffer!
      ;; ( string[address, length], buffer[address] -- )
      pop_argument_stack rdi ;; destination
      pop_argument_stack rcx ;; counter
      pop_argument_stack rsi ;; source
      rep movsb
      next
   #+end_src
** string-reverse!                    :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rdi, buffer$string_reverse!
      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
      rep movsb

      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** string-reverse!                    :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rbx, [pointer$argument_stack]
      mov rdi, buffer$string_reverse!
      mov rcx, [rbx - (1 * jo_size)]
      mov rsi, [rbx - (2 * jo_size)]
      rep movsb

      mov rcx, [rbx - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [rbx - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** char-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char-string?", char_string?
      ;; << string[address, length], char -- bool >>
      xx xxswapx
      xx dup, one?, false?, false?branch, 5
      xx   drop2, drop
      xx   false
      xx   end
      xx string_head__char, equal?, false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
** zero-string?
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "end"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero-string?", zero_string?
      ;; << string[address, length] -- bool >>
      xx dup2, literal, '0', char_string?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2
      xx string_head__char, literal, '-', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char, literal, '0', char_string?
      xx end
   #+end_src
** digit-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-string?", digit_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx over, fetch_byte, digit_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, digit_string?
      xx drop2, false
      xx end
   #+end_src
** integer-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "integer-string?", integer_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, literal, '-', char_string?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
      xx   string_tail__char
      xx   digit_string?
      xx   end
      xx digit_string?
      xx end
   #+end_src
** digit-string->nature-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   sum$digit_string_to_nature_number:
      xx 0

   counter$digit_string_to_nature_number:
      xx 0

   define_function "digit-string->nature-number", digit_string_to_nature_number
      ;; << string[address, length] -- integer >>
      xx zero, literal, sum$digit_string_to_nature_number, save
      xx zero, literal, counter$digit_string_to_nature_number, save

      xx dup2, string_reverse!
      xx   help__digit_string_to_nature_number
      xx string_reverse!, drop2

      xx literal, sum$digit_string_to_nature_number
      xx fetch
      xx end

   define_function "help,digit-string->nature-number", help__digit_string_to_nature_number
      ;; << reversed-string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end

      xx dup2, string_head__char, digit_char_to_number
      xx   literal, 10
      xx   literal, counter$digit_string_to_nature_number, fetch
      xx     one
      xx     literal, counter$digit_string_to_nature_number
      xx     add_save
      xx   power
      xx multiple

      xx literal, sum$digit_string_to_nature_number
      xx add_save

      xx string_tail__char
      xx taca, help__digit_string_to_nature_number
   #+end_src
** string->integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->integer", string_to_integer
      ;; << string[address, length] -- integer >>
      xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
      xx   digit_string_to_nature_number
      xx   end
      xx string_tail__char
      xx digit_string_to_nature_number
      xx negate
      xx end
   #+end_src
** ----------------------------------
** find-char,string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "find-char,string", find_char__string
     ;; << string[address, length], char
     ;;    -- address, true
     ;;    -- false >>
     xx over, zero?, false?branch, 5
     xx   drop, drop2
     xx   false
     xx   end
     xx xoverxx, fetch_byte
     xx over, equal?, false?branch, 4
     xx   drop2
     xx   true
     xx   end
     xx xxswapx
     xx string_tail__char
     xx xswapxx
     xx taca, find_char__string
   #+end_src
** test
   #+begin_src cicada-nymph
   : XIE Yuheng ;
   32 find-char,string . << 1 >>
   fetch-byte . << 32 >>
   #+end_src
** ----------------------------------
* io about number
** write-nature-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; 2 ^ 64 = 18446744073709551616
   ;; which is of length 20
   ;; so
   ;; I use 32 to align to 16

   buffer$write_nature_number labeling
      preserve 32

   counter$write_nature_number:
      xx 0

   define_function "write-nature-number", write_nature_number
      ;; << nature-number -- >>
      xx write_nature_number__fill_buffer
      xx write_string
      xx end

   define_function "write-nature-number,fill-buffer", write_nature_number__fill_buffer
      ;; << nature-number -- >>
      xx zero
      xx literal, counter$write_nature_number, save

      xx write_nature_number__loop

      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx string_reverse!
      xx end


   define_function "write-nature-number,loop", write_nature_number__loop
      ;; << rest-number -- >>
      xx literal, 10, divmod

      xx number_to_digit_char
      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx addition
      xx save_byte

      xx one
      xx literal, counter$write_nature_number
      xx add_save

      xx dup, zero?, false?branch, 3
      xx   drop
      xx   end
      xx taca, write_nature_number__loop
   #+end_src
** write-integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-integer", write_integer
      ;; << integer -- >>
      xx dup, negative?, false?, false?branch, 3
      xx   write_nature_number
      xx   end
      xx literal, '-', write_byte
      xx negate
      xx write_nature_number
      xx end
   #+end_src
** pretty_write_integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pretty-write-integer", pretty_write_integer
      ;; << integer -- >>
      xx write_integer
      xx literal, 32
      xx write_byte
      xx end

   define_function ".", ALIAS__pretty_write_integer
      ;; << integer -- >>
      xx pretty_write_integer
      xx end
   #+end_src
* word
** ----------------------------------
** note io about word
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_word_length = 1024

   buffer$read_word labeling
      preserve max_word_length

   buffer$read_word_for_REPL labeling
      preserve max_word_length
   #+end_src
** read-word-begin-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-begin-char", read_word_begin_char
      ;; << -- non-blank-char >>
      xx read_byte
      xx dup, literal, 32 ;; ascii.space
      xx greater_than?, false?branch, 2
      xx   end
      xx drop
      xx taca, read_word_begin_char
   #+end_src
** read-word->buffer
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word->buffer", read_word_to_buffer
      ;; << buffer -- word[address, length] >>
      xx read_word_begin_char
      ;; no metter what the begin char is
      ;; save it into buffer
      xx dup2, swap, save_byte
      xx swap, add1, swap
      xx one, swap ;; leave length counter
      ;; << cursor[address in buffer], counter, begin char >>
      xx dup, bar_ket_char?, false?branch, 4
      xx   drop
      xx   help__read_word_to_buffer__bar_ket
      xx   end
      ;; maybe add other type of chars
      xx drop
      xx help__read_word_to_buffer__regular
      xx end

   define_function "help,read-word->buffer,bar-ket", help__read_word_to_buffer__bar_ket
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx tuck, subtraction
      xx swap
      xx end


   define_function "help,read-word->buffer,regular", help__read_word_to_buffer__regular
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx read_byte
      xx dup, bar_ket_char?, false?branch, 6
      xx   unread_ket_char
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx dup, space_char?, false?branch, 6
      xx   drop
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx xoverxx, save_byte
      xx add1
      xx swap, add1, swap
      xx taca, help__read_word_to_buffer__regular
   #+end_src
** read-word
   * read-word will override the word readed before
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word", read_word
      ;; << -- word[address of buffer$read_word, length] >>
      xx literal, buffer$read_word, read_word_to_buffer
      xx end
   #+end_src
** read-word-for-REPL
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-for-REPL", read_word_for_REPL
      ;; << -- word[address of buffer$read_word_for_REPL, length] >>
      xx literal, buffer$read_word_for_REPL, read_word_to_buffer
      xx end
   #+end_src
** ----------------------------------
** note
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
** space-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-string?", space_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2, string_head__char, space_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, space_string?
      xx drop2, false
      xx end
   #+end_src
** string->word-[begin|end]
   * the error is not handled
     so
     before calling (string->word-begin)
     one should make sure that
     the argument is not a space-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->word-begin", string_to_word_begin
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, string_to_word_begin

   define_function "string->word-end", string_to_word_end
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 3
      xx   string_tail__char
      xx   end
      xx help__string_to_word_end
      xx end

   define_function "help,string->word-end", help__string_to_word_end
      ;; << string[address, length] -- address >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?branch, 2
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, help__string_to_word_end
   #+end_src
** string-[head|tail],word
   * note that
     the following functions do not create new strings
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,word", string_head__word
      ;; << string[address, length] -- word[address, length] >>
      xx string_to_word_begin
      xx dup2, string_to_word_end
      xx swap, drop
      xx subtraction
      xx end

   define_function "string-tail,word", string_tail__word
      ;; << string[address, length] -- string[address, length] >>
      xx string_to_word_begin
      xx string_to_word_end
      xx end
   #+end_src
** ----------------------------------
* dictionary
** note
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
** find
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*first-jo-in-dictionary*", V__first_jo_in_dictionary
      xx (last_link + jo_size)

   define_function "find", find
      ;; << word[address, length]
      ;;    -- jo, true
      ;;    -- false >>
      xx V__first_jo_in_dictionary
      xx help__find
      xx end

   define_function "help,find", help__find
      ;; << word[address, length], jo
      ;;    -- jo, true
      ;;    -- false >>
      xx xxtuckx


      xx jo_to_name, xxoverxx

      ;; for debug
      ;; xx jo_to_name
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte
      ;; xx xxoverxx
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte


      xx string_equal?, false?branch, 4
      xx   drop2, true
      xx   end
      xx xswapxx
      xx dup, last_jo__dictionary?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx jo_to_pre_jo
      xx taca, help__find
   #+end_src
** execute-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "execute-word", execute_word
      ;; << word[address, length] -- unknown >>
      xx dup2, integer_string?, false?branch, 3
      xx   string_to_integer
      xx   end
      ;; maybe more

      xx dup2 ;; for to report undefined word

      xx find, false?branch, 5
      xx   xxswapx, drop2
      xx   execute_jo
      xx   end

      xx write_undefined_word_report__for_execute_word
      xx write_string
      xx literal, 10
      xx write_byte
      xx end


   define_function "write-undefined-word-report,for-execute-word", write_undefined_word_report__for_execute_word
      ;; << -- >>
      xx literal, string$undefined_word_report__for_execute_word
      xx literal, length$undefined_word_report__for_execute_word
      xx write_string
      xx end

   string$undefined_word_report__for_execute_word:
      db "* (execute-word) meets undefined word : "
   .end:
   length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)
   #+end_src
* basic-REPL
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "basic-REPL", basic_REPL
     ;; << unknown -- unknown >>
     xx read_word_for_REPL
     xx execute_word
     xx taca, basic_REPL
  #+end_src
* -----------------------------------
* colon semicolon
** note
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first:
     #+begin_src
     define-function factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial *
       end
     end
     #+end_src
   * second:
     #+begin_src cicada-nymph
     : factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial *
       end
     ; define-function
     #+end_src
** [colon|semicolon]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "colon-string?", colon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ':'
      xx char_string?
      xx end

   define_function "semicolon-string?", semicolon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ';'
      xx char_string?
      xx end
   #+end_src
** comment-[begin|end]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$comment_begin:
      db "<<"

   define_function "comment-begin-string?", comment_begin_string?
      ;; << string[address, length] -- bool >>
      xx literal, string$comment_begin
      xx literal, 2
      xx string_equal?
      xx end


   string$comment_end:
      db ">>"

   define_function "comment-end-string?", comment_end_string?
      ;; << -- >>
      xx literal, string$comment_end
      xx literal, 2
      xx string_equal?
      xx end
   #+end_src
** colon & semicolon
   * nested : ; is NOT allow
     and no error check for it
   * nested << >> must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in << >>
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     double-quote is special bar-ket
     but "<" & ">" are not viewed as bar-ket
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$colon labeling
      preserve 1024 * 1024

   cursor$colon:
      xx 0


   define_function ":", colon
      ;; << -- string[address of buffer$colon, length] >>
      xx literal, buffer$colon
      xx literal, cursor$colon, save
      xx help__loop__colon
      ;; address
      xx literal, buffer$colon
      ;; length
      xx literal, cursor$colon, fetch
      xx literal, buffer$colon
      xx subtraction
      xx end


   define_function "", help__loop__colon
      ;; << -- >>
      xx read_byte
      xx help__save_byte__colon
      xx help__meet_end__colon?, false?branch, 7
      xx   literal, 3 ;; for the string " ; "
      xx   literal, cursor$colon
      xx   sub_save
      xx   end
      xx help__meet_comment__colon?, false?branch, 9
      xx   literal, 4 ;; for the string " << "
      xx   literal, cursor$colon
      xx   sub_save
      xx   ignore_comment
      xx   taca, help__loop__colon
      xx taca, help__loop__colon


   define_function "", help__save_byte__colon
      ;; << byte -- >>
      xx literal, cursor$colon, fetch
      xx save_byte
      xx one
      xx literal, cursor$colon
      xx add_save
      xx end


   define_function "", help__meet_end__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, ';', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end

   define_function "", help__meet_comment__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 4, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end
   #+end_src
** ignore-comment
   * this function is for basic-REPL
     but it is reused by colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "<<", ignore_comment
      ;; << -- >>
      xx read_word
      xx dup2, comment_begin_string?, false?branch, 5
      xx   drop2
      xx     ignore_comment ;; for the new nested-comment
      xx   taca, ignore_comment ;; for the rest-comment
      xx dup2, comment_end_string?, false?branch, 3
      xx   drop2
      xx   end
      xx drop2
      xx taca, ignore_comment
   #+end_src
** test
   #+begin_src cicada-nymph
   1 << 989 >> 64 add .
   << 65 >>

   : kkk << 989 << 989 >> >> ; .s
   << kkk >>
   #+end_src
* jojo-heap
** note
   * you can see how the naming convention is used
     for functions that create structured data into memory
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$jo_heap = 1024 * 1024 * jo_size

   define_variable "*jo-heap*", V__jo_heap
     xx address$jo_heap

   define_variable "*size,jo-heap*", V__size__jo_heap
     xx size$jo_heap


   address$jo_heap labeling
      preserve size$jo_heap

   define_variable "*current-free-address,jo-heap*", V__current_free_address__jo_heap
      xx address$jo_heap
   #+end_src
** save-into,primitive-string-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,primitive-string-heap", save_into__primitive_string_heap
      ;; << string[address, length] -- >>
      xx dup, V__current_free_address__primitive_string
      xx save_two_bytes

      xx literal, 2
      xx address, V__current_free_address__primitive_string
      xx add_save

      xx tuck
      xx V__current_free_address__primitive_string
      xx string_to_buffer!

      xx address, V__current_free_address__primitive_string
      xx add_save
      xx end
   #+end_src
** save-into,jo-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,jo-heap", save_into__jo_heap
      ;; << number -- >>
      xx V__current_free_address__jo_heap
      xx save

      xx literal, jo_size
      xx address, V__current_free_address__jo_heap
      xx add_save
      xx end
   #+end_src
* syntax-stack
** 記
   * 用 *syntax-stack* 來進行語境轉換
   * 用 *syntax-set,...* 來進行動態添加
** memory allocate
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve jo_size * 64
   address$syntax_stack labeling
      preserve jo_size * 1024

   define_variable "*pointer-syntax-stack*", V__pointer_syntax_stack
      xx address$syntax_stack
   #+end_src
** push-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "push-syntax-stack", push_syntax_stack
      ;; << syntax-set[address] -- >>
      xx V__pointer_syntax_stack
      xx save
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx add_save
      xx end
   #+end_src
** pop-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pop-syntax-stack", pop_syntax_stack
      ;; << -- syntax-set[address] >>
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx sub_save
      xx V__pointer_syntax_stack, fetch
      xx end
   #+end_src
** tos-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "tos-syntax-stack", tos_syntax_stack
      ;; << -- syntax-set[address] >>
      xx V__pointer_syntax_stack
      xx V__jo_size
      xx subtraction
      xx fetch
      xx end
   #+end_src
** drop-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "drop-syntax-stack", drop_syntax_stack
      ;; << -- >>
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx sub_save
      xx end
   #+end_src
** syntax-stack-empty?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax-stack-empty?", syntax_stack_empty?
      ;; << -- bool >>
      xx V__pointer_syntax_stack
      xx literal, address$syntax_stack
      xx equal?
      xx end
   #+end_src
** find-syntax
   * only search the first rule-set in syntax-stack
     thus a switch of syntax will get you a clean syntax
    #+begin_src fasm :tangle cicada-nymph.fasm
    define_function "find-syntax", find_syntax
       ;; << word[address, length]
       ;;    -- function, true
       ;;    -- false >>
       xx syntax_stack_empty?, false?branch, 4
       xx   drop2
       xx   false
       xx   end
       xx tos_syntax_stack
       xx find_rule
       xx end
   #+end_src
* rule-set
** 記 接口
   * 在 rule-set 中 一個 rule 的存在是
     | function | predicate |
   * 在棧中 一個 rule 的存在是
     << rule[predicate, function] >>
   * set is an ordered set
     its interface is as the following
     1. (add-rule)
        add a rule into rule-set
     2. (sub-rule)
        try to sub a rule from rule-set
        once a time
        if can not find the rule in the rule-set
        do nothing
     3. (find-rule)
        find a function from a word
     4. (list-rule)
        [implemented in cicada-nymph]
** 記 使用
   * rule-set,make-jojo 是
     語法謂詞 還有 語法函數 這種對子
     所形成的有序集合
   * 這樣就可以形成簡單的語境概念了
     這種簡單的語境概念也很有趣
     但是
     它與我爲蟬語所構想的
     利用姓名來實現的語境機制是不同的
   * 每個語境都有責任
     在進入和退出時
     維護好 rule-set,make-jojo
   * 以 rule 爲前綴的 macro 的類型常常是
     1. 以 make-jojo 爲後綴時
        << string[address, length], word[address, length]
        -- string[address, length] >>
     2. 在 REPL 中使用時又可以是
        << word[address, length] -- integer >>
     所以在使用時
     一定要注意維護棧中的值的良好性
** rule-set,fetch-cursor
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "rule-set,fetch-cursor", rule_set__fetch_cursor
      ;; << rule-set -- address >>
      xx V__jo_size, subtraction
      xx fetch
      xx end
   #+end_src
** rule-set,save-cursor
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "rule-set,save-cursor", rule_set__save_cursor
      ;; << address, rule-set -- >>
      xx V__jo_size, subtraction
      xx save
      xx end
   #+end_src
** add-rule                           :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "add-rule", add_rule
      ;; << rule[predicate, function], rule-set -- >>
      pop_argument_stack rdx
      sub rdx, jo_size ;; cursor$rule_set
      pop_argument_stack rax
      mov rbx, [rdx]
      mov [rbx], rax
      add qword [rdx], jo_size
      pop_argument_stack rax
      mov rbx, [rdx]
      mov [rbx], rax
      add qword [rdx], jo_size
      next

   }
   #+end_src
** add-rule                           :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "add-rule", add_rule
      ;; << rule[predicate, function], rule-set -- >>
      pop_argument_stack rdx
      sub rdx, jo_size ;; cursor$rule_set
      pop_argument_stack rax
      mov rbx, [rdx]
      mov [rbx], rax
      add dword [rdx], jo_size
      pop_argument_stack rax
      mov rbx, [rdx]
      mov [rbx], rax
      add dword [rdx], jo_size
      next

   }
   #+end_src
** cursor->[rule|function|predicate]
   * note that here needs two subtractions
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "cursor->rule", cursor_to_rule
      ;; << cursor -- rule[predicate, function] >>
      xx V__jo_size, subtraction
      xx dup, fetch, swap
      xx V__jo_size, subtraction
      xx fetch
      xx end

   define_function "cursor->predicate", cursor_to_predicate
      ;; << cursor -- predicate >>
      xx V__jo_size, subtraction
      xx fetch
      xx end

   define_function "cursor->function", cursor_to_function
      ;; << cursor -- function >>
      xx V__jo_size, subtraction
      xx V__jo_size, subtraction
      xx fetch
      xx end
   #+end_src
** sub-rule
   #+begin_src fasm :tangle cicada-nymph.fasm
   cursor$sub_rule:
      xx 0

   define_function "sub-rule", sub_rule
      ;; << rule[predicate, function], rule-set -- >>
      xx dup, rule_set__fetch_cursor
      xx literal, cursor$sub_rule, save
      xx sub_rule__loop
      xx end

   define_function "sub-rule,loop", sub_rule__loop
      ;; << rule[predicate, function], rule-set -- >>
      xx literal, cursor$sub_rule, fetch
      xx over, equal?, false?branch, 4
      xx   drop, drop2
      xx   end
      xx xxoverx
      ;; << predicate, function, rule-set
      ;;    predicate, function >>
      xx literal, cursor$sub_rule, fetch
      xx cursor_to_rule
      ;; << predicate, function, rule-set
      ;;    predicate, function, predicate, function >>
      xx equal?, false?, false?branch, 9
      xx   V__jo_size
      xx   V__jo_size, addition
      xx   literal, cursor$sub_rule, sub_save
      xx   taca, sub_rule__loop
      xx dup
      xx literal, cursor$sub_rule, fetch
      xx sub_rule__move
      xx end

   define_function "sub-rule,move", sub_rule__move
      ;; << rule-set, cursor -- >>
      xx dup2
      xx equal?, false?branch, (.more_to_move-$)/jo_size
      xx   drop
      xx   dup, rule_set__fetch_cursor
      xx   V__jo_size, subtraction
      xx   V__jo_size, subtraction
      xx   swap
      xx   rule_set__save_cursor
      xx   end
   .more_to_move:
      xx sub_rule__move_one
      xx taca, sub_rule__move

   define_function "sub-rule,move_one", sub_rule__move_one
      ;; << cursor -- cursor + element-size >>
      xx dup
      xx fetch
      xx over, V__jo_size, subtraction, V__jo_size, subtraction
      xx save

      xx dup
      xx V__jo_size, addition, fetch
      xx over, V__jo_size, subtraction
      xx save

      xx V__jo_size, addition
      xx V__jo_size, addition
      xx end
   #+end_src
** find-rule
   #+begin_src fasm :tangle cicada-nymph.fasm
   cursor$find_rule:
      xx 0

   define_function "find-rule", find_rule
      ;; << word[address, length], rule-set
      ;;    -- function, true
      ;;    -- false >>
      xx dup, rule_set__fetch_cursor
      xx literal, cursor$find_rule, save
      xx find_rule__loop
      xx end

   define_function "find-rule,loop", find_rule__loop
      ;; << word[address, length], rule-set
      ;;    -- function, true
      ;;    -- false >>
      xx literal, cursor$find_rule, fetch
      xx over, equal?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx xxoverx
      xx literal, cursor$find_rule, fetch
      xx cursor_to_predicate
      xx execute_jo, false?branch, (.not_found-$)/jo_size
      xx   drop, drop2
      xx   literal, cursor$find_rule, fetch
      xx   cursor_to_function
      xx   true
      xx   end
   .not_found:
      xx literal, cursor$find_rule, fetch
      xx V__jo_size, subtraction
      xx V__jo_size, subtraction
      xx literal, cursor$find_rule, save
      xx taca, find_rule__loop
   #+end_src
* rule-set,make-jojo
** ----------------------------------
** note
   * a syntax is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$rule_set__make_jojo = 1024 * jo_size

   cursor$rule_set__make_jojo:
      xx address$rule_set__make_jojo
   address$rule_set__make_jojo:
      times size$rule_set__make_jojo db 0
   #+end_src
** *rule-set,make-jojo*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*rule-set,make-jojo*", V__rule_set__make_jojo
      xx address$rule_set__make_jojo
   #+end_src
** init,rule-set,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "init,rule-set,make-jojo", init__rule_set__make_jojo
      ;; << -- >>
      xx literal, integer_string?
      xx literal, syntax__integer_string__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_address?
      xx literal, syntax__address__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_jo?
      xx literal, syntax__jo__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_branch?
      xx literal, syntax__branch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_false?branch?
      xx literal, syntax__false?branch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_double_quote?
      xx literal, syntax__double_quote__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, local_variable_save_string?
      xx literal, syntax__local_variable_save__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, local_variable_fetch_string?
      xx literal, syntax__local_variable_fetch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx end
   #+end_src
** ----------------------------------
** syntax,integer-string,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,integer-string,make-jojo", syntax__integer_string__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx literal, literal
      xx   save_into__jo_heap
      xx string_to_integer
      xx   save_into__jo_heap
      xx end
   #+end_src
** ----------------------------------
** word:address?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_address?:
      db "address"
   .end:
   length$word_is_address? = (.end - string$word_is_address?)

   define_function "word:address?", word_is_address?
      ;; << word[address, length] -- bool >>
      xx literal, string$word_is_address?
      xx literal, length$word_is_address?
      xx string_equal?
      xx end
   #+end_src
** syntax,address,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,address,make-jojo", syntax__address__make_jojo
      ;; << string[address, length], word:address --
      ;;    string[address, length] >>
      xx drop2

      xx literal, address
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx find, false?branch, 4
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_undefined_word_report__for_address
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-undefined-word-report,for-address", write_undefined_word_report__for_address
      ;; << -- >>
      xx literal, string$undefined_word_report__for_address
      xx literal, length$undefined_word_report__for_address
      xx write_string
      xx end

   string$undefined_word_report__for_address:
      db "* (make-jojo (address)) the word follows (address) is undefined : "
   .end:
   length$undefined_word_report__for_address = (.end - string$undefined_word_report__for_address)
   #+end_src
** ----------------------------------
** word:jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_jo?:
      db "jo"
   .end:
   length$word_is_jo? = (.end - string$word_is_jo?)

   define_function "word:jo?", word_is_jo?
      ;; << word[address, length] -- bool >>
      xx literal, string$word_is_jo?
      xx literal, length$word_is_jo?
      xx string_equal?
      xx end
   #+end_src
** syntax,jo,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,jo,make-jojo", syntax__jo__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, literal
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx find, false?branch, 4
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_undefined_word_report__for_jo
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-undefined-word-report,for-jo", write_undefined_word_report__for_jo
      ;; << -- >>
      xx literal, string$undefined_word_report__for_jo
      xx literal, length$undefined_word_report__for_jo
      xx write_string
      xx end

   string$undefined_word_report__for_jo:
      db "* (syntax,jo,make-jojo) the word follows (jo) is undefined : "
   .end:
   length$undefined_word_report__for_jo = (.end - string$undefined_word_report__for_jo)
   #+end_src
** ----------------------------------
** word:branch?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_branch?:
      db "branch"
   .end:
   length$word_is_branch? = (.end - string$word_is_branch?)

   define_function "word:branch?", word_is_branch?
      ;; << word[branch, length] -- bool >>
      xx literal, string$word_is_branch?
      xx literal, length$word_is_branch?
      xx string_equal?
      xx end
   #+end_src
** syntax,branch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,branch,make-jojo", syntax__branch__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, branch
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-branch", write_not_integer_string_report__for_branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_branch
      xx literal, length$not_integer_string_report__for_branch
      xx write_string
      xx end

   string$not_integer_string_report__for_branch:
      db "* (syntax,branch,make-jojo) the word follows (branch) must be a integer string : "
   .end:
   length$not_integer_string_report__for_branch = (.end - string$not_integer_string_report__for_branch)
   #+end_src
** ----------------------------------
** word:false?branch?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_false?branch?:
      db "false?branch"
   .end:
   length$word_is_false?branch? = (.end - string$word_is_false?branch?)

   define_function "word:false?branch?", word_is_false?branch?
      ;; << word[false?branch, length] -- bool >>
      xx literal, string$word_is_false?branch?
      xx literal, length$word_is_false?branch?
      xx string_equal?
      xx end
   #+end_src
** syntax,false?branch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,false?branch,make-jojo", syntax__false?branch__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, false?branch
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_false?branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-false?branch", write_not_integer_string_report__for_false?branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_false?branch
      xx literal, length$not_integer_string_report__for_false?branch
      xx write_string
      xx end

   string$not_integer_string_report__for_false?branch:
      db "* (syntax,false?branch,make-jojo) the word follows (false?branch) must be a integer string : "
   .end:
   length$not_integer_string_report__for_false?branch = (.end - string$not_integer_string_report__for_false?branch)
   #+end_src
** ----------------------------------
** word:double-quote?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_double_quote?:
      db '"'
   .end:
   length$word_is_double_quote? = (.end - string$word_is_double_quote?)

   define_function "word:double-quote?", word_is_double_quote?
      ;; << word[double-quote, length] -- bool >>
      xx literal, string$word_is_double_quote?
      xx literal, length$word_is_double_quote?
      xx string_equal?
      xx end
   #+end_src
** syntax,double-quote,make-jojo
   * primitive-string-heap is used
     to allocate string literal in function body
   * in ASCII encode double-quote is 34
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,double-quote,make-jojo", syntax__double_quote__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx dup2
      xx literal, '"', find_char__string
      xx false?branch, (.not_found-$)/jo_size
      xx   xoverxx, subtraction
      ;;   << string[address, length], length >>

      ;; address
      xx   literal, literal
      xx     save_into__jo_heap
      xx   V__current_free_address__primitive_string, add2
      xx     save_into__jo_heap
      xx   xoverxx, over
      xx     save_into__primitive_string_heap

      ;; length
      xx   literal, literal
      xx     save_into__jo_heap
      xx   dup
      xx     save_into__jo_heap

      xx   tuck, subtraction
      xx   xxswapx
      xx   addition
      xx   swap

      xx   string_tail__char ;; over the ending double-quote
      xx   end

      .not_found:
      xx write_not_integer_string_report__for_double_quote
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-double-quote", write_not_integer_string_report__for_double_quote
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_double_quote
      xx literal, length$not_integer_string_report__for_double_quote
      xx write_string
      xx end

   string$not_integer_string_report__for_double_quote:
      db "* (syntax,double-quote,make-jojo) can not find the ending double-quote"
   .end:
   length$not_integer_string_report__for_double_quote = (.end - string$not_integer_string_report__for_double_quote)
   #+end_src
** ----------------------------------
* make-jojo
** note
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
** make-jojo
   * 這裏又產生了特殊的一類珠
     它雖然以 "M__" 爲前綴
     但是沒有作爲字符串的名字
     每個這種珠都與一個謂詞相對
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo", make_jojo
      ;; << string[address, length] -- >>
      xx local_variable_table__clear
      xx V__rule_set__make_jojo, push_syntax_stack
      xx make_jojo__loop
      xx drop_syntax_stack
      xx end

   define_function "make-jojo,loop", make_jojo__loop
      ;; << string[address, length] -- >>
      xx dup2, space_string?, false?branch, 3
      xx   drop2
      xx   end
      xx dup2
      xx string_tail__word
      xx xxswapxx
      xx string_head__word
      ;; << tail[address, length], head[address, length] >>
      xx make_jojo__dispatch_syntax_word
      xx taca, make_jojo__loop
   #+end_src
** make-jojo,dispatch-syntax-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo,dispatch-syntax-word", make_jojo__dispatch_syntax_word
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2
      xx find_syntax, false?branch, 3
      xx   execute_jo
      xx   end
      xx dup2
      xx find, false?branch, 5
      xx   xxswapx, drop2 ;; drop word
      xx   save_into__jo_heap
      xx   end
      xx write_undefined_word_report__for_make_jojo
      xx write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo

   define_function "write-undefined-word-report,for-make-jojo", write_undefined_word_report__for_make_jojo
      ;; << -- >>
      xx literal, string$undefined_word_report__for_make_jojo
      xx literal, length$undefined_word_report__for_make_jojo
      xx write_string
      xx end

   string$undefined_word_report__for_make_jojo:
      db "* (make-jojo) meets undefined word : "
   .end:
   length$undefined_word_report__for_make_jojo = (.end - string$undefined_word_report__for_make_jojo)
   #+end_src
* define-[function|exception|variable]
** note
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
** !undo-make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_exception "!undo-make-jojo", !undo_make_jojo
      ;; << old V__current_free_address__primitive_string
      ;;    old V__current_free_address__jo_heap
      ;;    old V__first_jo_in_dictionary
      ;;    string[address, length]
      ;;    -- >>
      xx drop_syntax_stack

      xx literal, string$undo_make_jojo_report
      xx literal, length$undo_make_jojo_report
      xx write_string

      xx write_string
      xx literal, 10, write_byte
      xx literal, ';', write_byte
      xx literal, 10, write_byte

      xx address, V__first_jo_in_dictionary, save
      xx address, V__current_free_address__jo_heap, save
      xx address, V__current_free_address__primitive_string
      xx save
      xx end

   string$undo_make_jojo_report:
      db "  the following jojo is not made :"
      db 10
      db ": "
   .end:
   length$undo_make_jojo_report = (.end - string$undo_make_jojo_report)
   #+end_src
** define-function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-function", CICADA__define_function
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string, xxswapx
      xx V__current_free_address__jo_heap, xxswapx
      xx V__first_jo_in_dictionary, xxswapx
      ;; << old V__current_free_address__primitive_string
      ;;    old V__current_free_address__jo_heap
      ;;    old V__first_jo_in_dictionary
      ;;    string[address, length] >>

      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end

      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$function
      xx   save_into__jo_heap

      xx dup2
      xx string_tail__word
      xx make_jojo
      xx drop2
      xx drop, drop, drop
      xx end
   #+end_src
** define-exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-exception", CICADA__define_exception
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string, xxswapx
      xx V__current_free_address__jo_heap, xxswapx
      xx V__first_jo_in_dictionary, xxswapx
      ;; << old V__current_free_address__primitive_string
      ;;    old V__current_free_address__jo_heap
      ;;    old V__first_jo_in_dictionary
      ;;    string[address, length] >>

      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end

      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$exception
      xx   save_into__jo_heap

      xx dup2
      xx string_tail__word
      xx make_jojo
      xx drop2
      xx drop, drop, drop
      xx end
   #+end_src
** define-variable
   * not undo is needed for define-variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-variable", CICADA__define_variable
      ;; << variable, string[address, length] -- >>
      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$variable
      xx   save_into__jo_heap

      ;; when debugging
      ;; instead of drop2
      ;; one may wish to do some thing to the string
      xx drop2
      xx save_into__jo_heap
      xx end
   #+end_src
** test define-function
   #+begin_src cicada-nymph
   : addadd add add end ; define-function
   1 2 3 addadd . << 6 >>

   : add1 1 add end ; define-function
   1 add1 . << 2 >>

   : negate 0 swap sub end ; define-function
   1 negate . << -1 >>
   #+end_src
** test define-variable
   #+begin_src cicada-nymph
   233 : *three* ; define-variable
   : add-three *three* add end ; define-function
   1 add-three . << 234 >>

   << you get the address of the variable *three*
      by add "address" in front of it >>
   : fix-*three* 3 address *three* save end ; define-function
   fix-*three*
   1 add-three . << 4 >>
   #+end_src
* -----------------------------------
* 記 有名字的局部變量 與 變長的局部數據
  * local-data-vector
    用來實現 有名字的局部變量
    在編譯時計算 offset
    到這個 local-data-vector 中的 offset 做爲變量的值
    有 *local-variable-table* 這個數據結構
    幫助計算 offset
  * local-data-heap
    用來分配 變長的局部數據
    在運行時計算 offset
  * 兩個機制配合使用
* note *to compare readability*
** example code without local-variable
   #+begin_src cicada-nymph
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     xx|tuck|xx name-hash-table,hash
     xx|tuck|x
     << number, counter, name, string[address, length], name >>
     name,used? false? if
       x|over|xx name,save-string
         xx|tuck|x << name as return value >>
       << name, number, counter, name >>
       x|over|xx 0 name-hash-table,hash
       swap name,save-orbiton
       << name, number, counter >>
       swap 0 name-hash-table,hash
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       true
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-string
     xx|over|xx string-equal? if
       drop2 xx|swap|x drop2
       true
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xxx *name-hash-table,size* equal? if
       drop2 xx|swap|x drop2
       false
       end
     then
     << number, counter, name, string[address, length] >>
     x|swap|xx drop
     xx|swap|xx add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** example code with local-variable
   #+begin_src cicada-nymph
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       ::string :name
       name,save-string
       :orbit :name
       name,save-orbiton
       :counter :orbit
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       :name true
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :counter *name-hash-table,size* equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
* 記 再增加局部變元支持之後 需要重寫的部分
** 詮釋者 與 收尾詞
   * 在進行時
     每次進入一個函數體的執行
     即 每次將一串珠珠入棧時
     同時在這串珠子底部加上
     current_free_address$local_data_vector
     即 在 explain$function 中需要做特殊處理
     注意
     explain$exception
     等等
     和 explain$function 並沒有區別
     只是名字不一樣而已
     所以也需要做特殊處理
   * 這個值在函數退出時
     [即 在 end 這個函數中]
     用以重置 current_free_address$local_data_vector
     也就是 釋放在這次函數作用過程中所分配的內存
   * 每次 >:name 的時候
     都更新 current_free_address$local_data_vector
     以分配內存就行了
   * 也就是說
     return-stack 中的大多數有效值
     都是以兩個值一對的方式存在的
   * 兩個結尾詞是 end 和 <>
     對於 <>
     即 對於明顯的尾遞歸調用
     需要利用棧中的值重置 current_free_address$local_data_vector
     但是並不入棧新值
** 語法擴展方面的支持
   * 這裏需要識別 >:name 還有 :name 等等
     並對它們做特殊處理
     這些東西應該藉助設計良好的語法擴展機制來實現
   * 我將使用一個 語法謂詞 的棧
     可以發現
     這樣的話
     我就能很容易地臨時改變語法了
** 注意
   * 需要重寫的部分還有 exception-handling
     這包括
     1. explain$exception
     2. prepare_for
     3. exception_head
* 記 總結
** interface
   * 首先要滿足最基本的
     長度爲 *jo-size* 的倍數的
     局部變量的需求
     其次
     還要能夠在所申請的局部空間裏使用字符串
     這兩種長度的數據結構需要共存
     使用 offset 就行了
   * 底層
     local-data-allocate,jo
     這個只讓 current_free_address$local_data_vector 前進
     而不後退
   * 注意
     最爲重要的特點是
     所有的對 局部數據堆 的使用
     都必須在編譯時期被靜態地算出來
     所以必須設計語法幫助編譯器作計算
     >:name :name 用以 分配 和 使用
     *jo-size* 倍數大小的內存
   * 語義方面
     >:name 的重複出現有兩種語義
     1. 更新這個局部變元的值
     2. 覆蓋上一個局部變元綁定
     我選擇第一種
     因爲這樣
     我就不必設計額外的語法來更新局部變元的值了
     比較簡潔
** 語義特點總結
   * 所有有名局部變元的名字與值的對應
     都由編譯器處理
   * 每個函數體就是一個非常線性的東西
     函數體中不能嵌套別的函數體
** 語用特點總結
   * 所有的函數都是全局的
     包括輔助函數
   * 所以設計輔助函數的時候
     應該格外小心
     儘量使得輔助函數能夠被重用
   * 改代碼並調整對輔助函數的使用
     就被稱作是 "re-factoring"
     即 函數的因子的重新分解
* local-data-vector
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_data_vector = 1024 * 1024 * jo_size

   address$local_data_vector labeling
      preserve size$local_data_vector

   current_free_address$local_data_vector:
      xx address$local_data_vector
   #+end_src
** 記 注意結尾詞會初始化局部變量指針
   * 下面的接口函數必須是 primitive-function
     因爲 否則 遇到 end 和 taca 的時候
     current_free_address$local_data_vector 就又被初始化了
** local_data_allocate__jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "local-data-allocate,jo", local_data_allocate__jo
      ;; << number -- >>
      pop_argument_stack rax
      imul rax, jo_size
      add [current_free_address$local_data_vector], rax
      next
   #+end_src
** note many fetch & save
   * in memory
     | 1 : value-1 |
     | 1 : value-2 |
     | 1 : value-3 |
   * on stack
     << value-1, value-2, value-3, ... >>
** n-fetch & n-save                   :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "n-fetch,local-data-vector", n_fetch__local_data_vector
      ;; << offset, n -- value-1, ..., value-n >>
      mov rbx, [pointer$return_stack - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
   .loop:
      mov rax, [rbx]
      push_argument_stack rax
      add rbx, jo_size
      loop .loop
      next

   define_primitive_function "n-save,local-data-vector", n_save__local_data_vector
      ;; << value-n, ..., value-1, offset, n -- >>
      mov rbx, [pointer$return_stack - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
        mov rax, jo_size
        imul rax, rcx
        add rbx, rax
        ;; for address is based on 0
        ;; but n is based on 1
        sub rbx, jo_size
   .loop:
      pop_argument_stack rax
      mov [rbx], rax
      sub rbx, jo_size
      loop .loop
      next

   }
   #+end_src
** n-fetch & n-save                   :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "n-fetch,local-data-vector", n_fetch__local_data_vector
      ;; << offset, n -- value-1, ..., value-n >>
      mov rax, [pointer$return_stack]
      mov rbx, [rax - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
   .loop:
      mov rax, [rbx]
      push_argument_stack rax
      add rbx, jo_size
      loop .loop
      next

   define_primitive_function "n-save,local-data-vector", n_save__local_data_vector
      ;; << value-n, ..., value-1, offset, n -- >>
      mov rax, [pointer$return_stack]
      mov rbx, [rax - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
        mov rax, jo_size
        imul rax, rcx
        add rbx, rax
        ;; for address is based on 0
        ;; but n is based on 1
        sub rbx, jo_size
   .loop:
      pop_argument_stack rax
      mov [rbx], rax
      sub rbx, jo_size
      loop .loop
      next

   }
   #+end_src
** note example result
   * with >::name
     #+begin_src cicada-nymph
     : example
       << number1, number2, number3, number4
          -- number1, number2 >>
       >::var2
       >::var2
       ::var2
       end
     ; define-function
     #+end_src
     ----------------
     #+begin_src fasm
     define_function "example", example

        ;; >::var2
        xx literal, 2, local_data_allocate__jo
        xx literal, 0, literal, 2, n_save__local_data_vector

        ;; >::var2
        xx literal, 0, literal, 2, n_save__local_data_vector

        ;; ::var2
        xx literal, 0, literal, 2, n_fetch__local_data_vector

        xx end
     #+end_src
** test
   #+begin_src cicada-nymph
   : local-variable,test
     << number1, number2, number3 -- number1 + number2 >>
     >:var2
     >:var2
     >:var1
     :var1
     :var2
     add
     end
   ; define-function
   1 2 4 local-variable,test << 3 >> .


   : local-variable,test,2
     << number1, number2 -- number2 + number3 >>
     >::var2
     ::var2
     end
   ; define-function
   1 2 local-variable,test,2 << 1 2 >> . .


   : local-variable,test,3
     << number1, number2, number3 -- number2 + number3 >>
     >::var2
     >:var1
     ::var2
     add
     end
   ; define-function
   1 2 4 local-variable,test,3 << 6 >> .
   #+end_src
** test nested
   #+begin_src cicada-nymph
   : k1
     9 >:k
     :k .
     end
   ; define-function
   k1 << 9 >>

   : k2
     10 >:k
     k1
     :k .
     end
   ; define-function
   k2 << 9 10 >>
   #+end_src
* local-variable-table
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_variable_table = 100 * 1024

   address$local_variable_table labeling
      preserve size$local_variable_table
   #+end_src
** clear
   #+begin_src fasm :tangle cicada-nymph.fasm
   border$local_variable_table:
      xx address$local_variable_table

   offset$local_variable_table:
      xx 0

   define_function "local-variable-table,clear", local_variable_table__clear
      ;; << -- >>
      xx literal, address$local_variable_table
      xx literal, border$local_variable_table, save
      xx literal, 0
      xx literal, offset$local_variable_table, save
      xx end
   #+end_src
** insert
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-table,insert", local_variable_table__insert
      ;; << string[address, length] -- offset >>

      ;; leave offset
      xx literal, offset$local_variable_table, fetch
      xx   xxtuckx ;; return value
      xx literal, border$local_variable_table, fetch, save
      xx V__jo_size
      xx literal, border$local_variable_table, add_save

      ;; update offset$local_variable_table
      xx dup2
      xx   count_front_colon
      xx   V__jo_size, multiple
      xx   literal, offset$local_variable_table, add_save

      ;; leave length
      xx dup
      xx literal, border$local_variable_table, fetch, save
      xx V__jo_size
      xx literal, border$local_variable_table, add_save

      xx tuck ;; for to update border$local_variable_table

      ;; leave string
      xx literal, border$local_variable_table, fetch
      xx string_to_buffer!

      ;; update border$local_variable_table
      xx literal, border$local_variable_table, add_save

      xx end
   #+end_src
** find
   #+begin_src fasm :tangle cicada-nymph.fasm
   cursor$local_variable_table:
      xx address$local_variable_table

   define_function "local-variable-table,find", local_variable_table__find
      ;; << string[address, length]
      ;;    -- offset, true
      ;;    -- false >>
      xx literal, address$local_variable_table
      xx literal, cursor$local_variable_table, save
      xx local_variable_table__find__loop
      xx end

   define_function "local-variable-table,find,loop", local_variable_table__find__loop
      ;; << string[address, length]
      ;;    -- offset, true
      ;;    -- false >>
      xx literal, cursor$local_variable_table, fetch
      xx literal, border$local_variable_table, fetch
      xx greater_or_equal?, false?branch, 4
      xx   drop2
      xx   false
      xx   end
      xx dup2
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   V__jo_size, addition ;; address of string
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   fetch ;; length of string
      xx string_equal?, false?branch, 8
      xx   drop2
      xx   literal, cursor$local_variable_table, fetch
      xx     fetch ;; offset
      xx   true
      xx   end
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   fetch ;; length of string
      xx V__jo_size, addition
      xx V__jo_size, addition
      xx literal, cursor$local_variable_table, add_save
      xx taca, local_variable_table__find__loop
   #+end_src
** count-front-colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "count-front-colon", count_front_colon
      ;; << string[address, length] -- number >>
      xx literal, 0 ;; counter
      xx count_front_colon__loop
      xx end

   define_function "count-front-colon,loop", count_front_colon__loop
      ;; << string[address, length], counter -- number >>
      xx over, zero?, false?branch, 4
      xx   xxswapx, drop2
      xx   end
      xx xxoverx, string_head__char
      xx literal, ':', equal?, false?, false?branch, 4
      xx   xxswapx, drop2
      xx   end
      xx add1, xxswapx
      xx string_tail__char, xswapxx
      xx taca, count_front_colon__loop
   #+end_src
* two syntaxes
** ----------------------------------
** local-variable-fetch-string?
   * :name
     ::name
   * but not
     :name:
     ::name:
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-fetch-string?", local_variable_fetch_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, addition, sub1
      xx fetch_byte, literal, ':'
      xx equal?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, count_front_colon
      xx dup, literal, 0, greater_than?, false?, false?branch, 5
      xx   drop, drop2, false
      xx   end
      xx subtraction
      xx swap, drop
      xx literal, 0, greater_than?
      xx end
   #+end_src
** syntax,local-variable-fetch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,local-variable-fetch,make-jojo", syntax__local_variable_fetch__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2
      xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
      ;;   literal, <offese>, literal, n, n_fetch__local_data_vector
      xx     literal, literal
      xx       save_into__jo_heap
      ;;     offset
      xx       save_into__jo_heap
      xx     literal, literal
      xx       save_into__jo_heap
      ;;     n
      xx     count_front_colon
      xx       save_into__jo_heap
      xx     literal, n_fetch__local_data_vector
      xx       save_into__jo_heap
      xx   end
   .not_found:
      xx write_local_variable_not_bound_report
      xx write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo

   define_function "write-local-variable-not-bound-report", write_local_variable_not_bound_report
      xx literal, string$local_variable_not_bound_report
      xx literal, length$local_variable_not_bound_report
      xx write_string
      xx end

   string$local_variable_not_bound_report:
      db "* local-variable not bound : "
   .end:
   length$local_variable_not_bound_report = (.end - string$local_variable_not_bound_report)
   #+end_src
** ----------------------------------
** local-variable-save-string?
   * >:name
     >::name
   * but not
     >:name:
     >::name:
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-save-string?", local_variable_save_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, addition, sub1
      xx fetch_byte, literal, ':'
      xx equal?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char
      xx literal, '>', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char
      xx dup2, count_front_colon
      xx dup, literal, 0, greater_than?, false?, false?branch, 5
      xx   drop, drop2, false
      xx   end
      xx subtraction
      xx swap, drop
      xx literal, 0, greater_than?
      xx end
   #+end_src
** syntax,local-variable-save,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,local-variable-save,make-jojo", syntax__local_variable_save__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx string_tail__char
      xx dup2
      xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
      ;;   literal, <offese>, literal, n, n_save__local_data_vector
      xx     literal, literal
      xx       save_into__jo_heap
      ;;     offset
      xx       save_into__jo_heap
      xx     literal, literal
      xx       save_into__jo_heap
      ;;     n
      xx     count_front_colon
      xx       save_into__jo_heap
      xx     literal, n_save__local_data_vector
      xx       save_into__jo_heap
      xx   end
   .not_found:
      xx dup2
      xx local_variable_table__insert
      xx xxswapx
      xx count_front_colon
      ;; literal, <number>, local_data_allocate__jo
      xx   literal, literal
      xx     save_into__jo_heap
      ;;   number of jo
      xx     dup, save_into__jo_heap
      xx   literal, local_data_allocate__jo
      xx     save_into__jo_heap
      ;; literal, <offese>, literal, n, save_local_data
      xx   literal, literal
      xx     save_into__jo_heap
      ;;   offset
      xx   swap
      xx     save_into__jo_heap
      xx   literal, literal
      xx     save_into__jo_heap
      ;;   n
      xx     save_into__jo_heap
      xx   literal, n_save__local_data_vector
      xx     save_into__jo_heap
      xx end
   #+end_src
** ----------------------------------
* local-data-heap
** 記
   * 並不需要給這裏的接口設計特殊的語法擴展
     直接使用函數就可以了
   * 但是接口必須是 primitive-function
     因爲 否則 遇到 end 和 taca 的時候
     current_free_address$local_data_heap 就又被初始化了
** 記 使用
   * 在一個函數內
     用 allocate-local-memory 所申請的局部數據空間
     是可以被這個函數內所調用的函數所使用的
     但是當函數退出的時候
     其所申請的空間就被結尾珠 (end) 收回了
     而沒法重用了
     而用 (taca) 來實現循環的時候
     下一次函數的執行過程中
     所申請的 allocate-local-memory
     和上一次函數執行過程中
     所申請的 allocate-local-memory 是相同的
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_data_heap = 1024 * 1024 * jo_size

   address$local_data_heap labeling
      preserve size$local_data_heap

   current_free_address$local_data_heap:
      xx address$local_data_heap
   #+end_src
** allocate-local-memory
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "allocate-local-memory", allocate_local_memory
      ;; << size -- address >>
      pop_argument_stack rbx
      mov rax, [current_free_address$local_data_heap]
      push_argument_stack rax
      add [current_free_address$local_data_heap], rbx
      next
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,allocate-local-memory
     << -- address, address >>
     16 allocate-local-memory
     16 allocate-local-memory
     end
   ; define-function
   test,allocate-local-memory

   <<
   40218513
   40218529
   >>

   : test,allocate-local-memory,2
     << -- address, address >>
     16 allocate-local-memory
     test,allocate-local-memory
     16 allocate-local-memory
     test,allocate-local-memory
     16 allocate-local-memory
     end
   ; define-function
   test,allocate-local-memory,2

   <<
   40218513
     40218529
     40218545
   40218529
     40218545
     40218561
   40218545
   >>
   #+end_src
* -----------------------------------
* epilog
** ----------------------------------
** platform
   * this word is implemented as a function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "platform", the_platform
      xx literal, string$platform
      xx literal, length$platform
      xx end

   string$platform:

   match =linux, platform {
      db "linux"
   }

   .end:
   length$platform = (.end - string$platform)
   #+end_src
** ----------------------------------
** *un-initialized-memory*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*un-initialized-memory*", V__un_initialized_memory
     xx address$un_initialized_memory

   define_variable "*size,un-initialized-memory*", V__size__un_initialized_memory
     xx size$un_initialized_memory

   define_variable "*current-free-address,un-initialized-memory*", V__current_free_address__un_initialized_memory
     xx current_free_address$un_initialized_memory
   #+end_src
** ----------------------------------
** *current-free-address,primitive-string-heap*
   * the last_primitive_string_in_assembly
     is just "*current-free-address,primitive-string-heap*"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*current-free-address,primitive-string-heap*", V__current_free_address__primitive_string
      xx current_free_address$primitive_string_heap
   #+end_src
** ----------------------------------
** last_link
   * this word helps to initialize V__first_jo_in_dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   last_link = link
   #+end_src
** ----------------------------------
** un_initialized_memory              :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   match =linux, platform {

   segment readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory

   }
   #+end_src
** ----------------------------------
* ===================================
