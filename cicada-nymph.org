#+TITLE:  小蟬語 / cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** find a better way to protect reading-stack
   * now
     "1 2 3 add add . jo" eval-string
     will crush the interpreter
** protect on the overloading of a variety of memories
** better naming of headings
** add more notes about the limitations of the program
** add more notes about exception handling on io functions
** optimize local-variable by new instruction
   * too many literal is too waste of memory
** make instruction a type of jo      :maybe:
   this is needed when doing report of the jotionary
* ===================================
* note
** notation
   * "nature number" is just called "number"
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
** naming convention
   * a predicate of a type
     which denotes a subtype of that type
     uses that type as postfix
     such as
     "space-char?"
   * a function of a type
     uses that type as prefix
     such as
     "string-reverse"
     "string-equal?"
   * side-effect of structured data is postfixed by "!"
** convention in assembly code
   * using underline to compose big word from small words
   * using "$" as prefix and postfix separator
   * indentation level = 3
   * naming convention of jo
     | convention   | jo type  |
     |--------------+----------|
     | prefix "V__" | variable |
   * but I use
     1. "zero" instead of "V__zero"
     2. "true" instead of "V__true"
** convention in cicada-nymph code
   * using dash to compose big word from small words
   * using "," as prefix and postfix separator
   * indentation style = free
   * words are separated by space
     except for bar-ket
     every bar-ket is viewed as a word
** syntax of cicada-nymph
   * syntax &  semantic
     | syntax          | semantic                  |
     |-----------------+---------------------------|
     | borderfix "* *" | variable                  |
     | borderfix "+ +" | [maybe use]               |
     | bar-ket ( )     | not use                   |
     | bar-ket [ ]     | not use                   |
     | bar-ket { }     | macro call                |
     |                 | (for macros of which      |
     |                 | the number of             |
     |                 | arguments is not fix)     |
     | double-quote    | viewed as special bar-ket |
     |                 | (bar is the same as ket)  |
     |                 | to support string literal |
     | prefix "!"      | exception                 |
     | postfix "!"     | some of the side-effect   |
     | postfix "?"     | predicate                 |
   * but I use
     1. "true" instead of "*true*"
     2. "false" instead of "*false*"
** unique id
   * if one wish to get a named unique id
     a jo maybe used
     for a jo is an address in memory
     it is unique as a memory address
   * but there is not effort made
     to distinguish address and fixnum
     as different type of things
     thus
     this kind of unique id is not fit
     for some tasks
** different from the re-designed cicada-language
    * simplifications are for teaching purpose only
    * first and foremost
      function programming will NOT be supported in this implementation
    * a helper function must be defined before it is used
    * no mixfix-notation
      * function call is "function" instead of "(function)"
      * no such thing like
        1 2 (add) = 1 (add 2) = (add 1 2)
    * no named local argument
      * thus no inited local argument
    * no title-name-table
      * thus in this implementation
        we only use single name space
      * thus in this implementation
        we do NOT have the concept of "context"
        so
        the syntax is not as flexible as it will be in cicada-language
    * no type
      * no type inference
      * no dynamic type tag
      * no static type declaration
    * global linked-list for naming
      * not hash-table
      * by the way
        in classical forth
        the linked-list of jo is called jotionary
    * no dynamic-memory-management
      * no garbage-collector
    * about comment
      * the comment of the argument & return value of function
        is allowed to be written in free style normal comment
* note instar
** 1st-instar
   * indirect-threaded-code interpreter
     1. macro about argument_stack & return_stack
     2. macro about jo & jojo
     3. macro about next
     4. the way to do memory allocation
     5. begin_to_interpret_threaded_code
     6. little_test
** 2ed-instar
   * instruction as special primitive function
     1. literal
     2. address
   * and primitive functions about
     1. the stack
     2. bool
     3. fixnum
     4. memory
   * and taca for explicit tail-call
   * false?branch and taca are needed for "power"
** 3rd-instar
   * primitive function about io
     1. write_byte
     2. read_byte
** 4th-instar
   * more function about io
     1. about word
     2. about string
     3. about number
   * more function
     1. jo
     2. char
     3. buffer
   * more in epilog
     1. last_link
   * function about jotionary
     1. find
     2. execute-word
   * basic-REPL as postfix-notation function executer
     1. basic-REPL
** 5th-instar
   * type of jo
   * more in epilog
     1. *current-free-address,primitive-string-area*
   * colon semicolon
     1. ":" and ";" are used to read a string of words for compiler
        [looks like bar-ket but special]
     2. comment is handled here
        "<< >>" as the only way to do comment
   * compiler
     * make-jojo
       and macro for make-jojo
       1. macro system
       2. exception handling system
     * function about definition
       which leave data into memory
** 6th-instar
   * local-variable
* 記 數據結構與口總結
** jojo
   * jo 的數組
     每個數組外加一些元數據
** jotionary of jojo
   * 單項鏈接的鏈表
** primitive-string
** argument-stack
** return-stack
   * jo 的詮釋者
     決定了 如何入這個棧
   * 結尾詞
     決定了 如何出這個棧
** syntax-stack
** reading-stack
** local-variable-table
   * 只有一個 local-variable-table
     用以在編譯時期解決局部變元的名與值的對應
     這個數據結構被 syntax__local_variable_save__make_jojo
     和 syntax__local_variable_fetch__make_jojo 所使用
   * 其中保存
     * offset-in-local-jo
     * length-of-string
     * address-of-string
   * 並且每次在定義一個新的函數體的時候
     這個 local-variable-table 會被初始化
   * 基本的接口是
     * clear
       清空 offset 和 border
     * insert
       插入字符串 和 offset-in-local-jo
     * find
       通過字符串尋找 offset-in-local-jo
     有兩個全局變量幫助實現這些接口
     * cursor
       每次 find 的時候使用一個新的 cursor 來做循環
     * border
       insert 會擴大 border
       find 以 border 爲邊界
     另外 還有一個全局變量
     * offset
       用以計算 offset-in-local-jo
* 記 性狀總結
** 自動管理加載文件時所使用的搜索路徑列表
   * 原理如下
     * 在 cicada-nymph 中 load 一個 file 的時候
       需要指定出這個 被 load 的 file 的路徑
     * 維護一個需要被搜索的路徑的列表
       以使得 load 的 file 的時候
       不必使用完整的路徑
     * 提供自動管理搜索路徑的機制
   * 維護搜索路徑的列表的方式是
     利用文件系統中的一個某個固定路徑
     也就是說 只有唯一的一個需要被找到的路徑
     而其他的路徑都是被自動管理的
     這個路徑將有一個默認值
     並且可以被環境變量覆蓋
   * 限制加載文件的方式
     使得只能使用所提供的動態管理機制來加載文件
     這樣就可以減輕理解這個系統的困難
** >< 局部變元
* note problem
** about div                          :bug:
   * div can not handle the following
     -8 2 div .
** about inline comment               :bug:
   * inline comment such as
     add1 << dup . >> swap
     will be viewed as
     add1swap
** about comment in string            :bug:
   * << >> can not be in ""
** about stack                        :limit:
   * there are 64 positions below the all those stacks
     when you are belowing-stack so much
     bad things happen
** string-reverse! can not apply on empty-string :bug:
* ===================================
* prolog
** ----------------------------------
** note conditional preprocessing
   * flower bar-ket can not be nested in fasm's "match"
     so
     1. when defining macro conditionally
        one should use "if eq" & "finish if"
     2. when doing "define" or "equ"
        one should use "match { }"
** platform configuration
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;;;; before you compile the code
   ;;;; do not forget to choose your platform
   ;;;; in the following code

   include "platform-configuration.inc"
   #+end_src
** misc
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; in fasm, "end" is a reserved word
   finish equ end
   end equ exit
   #+end_src
** ----------------------------------
** jo_size                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   jo_size = 8 ;; (byte)
   xx equ dq

   }
   #+end_src
** jo_size                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   jo_size = 4 ;; (byte)
   xx equ dd

   rax equ eax
   rbx equ ebx
   rcx equ ecx
   rdx equ edx
   rsp equ esp
   rbp equ ebp
   rsi equ esi
   rdi equ edi

   syscall equ int 80h

   }
   #+end_src
** ----------------------------------
** header                             :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define linux64_sys_6_r8  r8
   define linux64_sys_5_r9  r9
   define linux64_sys_4_r10 r10
   define linux64_sys_3_rdx rdx
   define linux64_sys_2_rsi rsi
   define linux64_sys_1_rdi rdi
   define linux64_sys_n_rax rax

   define linux64_syscall_read   0
   define linux64_syscall_write  1
   define linux64_syscall_open   2
   define linux64_syscall_close  3
   define linux64_syscall_exit   60
   ;; about open & read & write

   }
   #+end_src
** format                             :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   format ELF64 executable 3

   }
   #+end_src
** entry                              :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   entry begin_to_interpret_threaded_code
   segment readable executable writeable

   }
   #+end_src
** ----------------------------------
** header                             :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define linux32_sys_6_ebp ebp
   define linux32_sys_5_edi edi
   define linux32_sys_4_esi esi
   define linux32_sys_3_edx edx
   define linux32_sys_2_ecx ecx
   define linux32_sys_1_ebx ebx
   define linux32_sys_n_eax eax

   define linux32_syscall_exit    1
   define linux32_syscall_read    3
   define linux32_syscall_write   4
   define linux32_syscall_open    5
   define linux32_syscall_close   6

   }
   #+end_src
** format                             :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   format ELF executable 3

   }
   #+end_src
** entry                              :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   entry begin_to_interpret_threaded_code
   segment readable executable writeable

   }
   #+end_src
** ----------------------------------
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle cicada-nymph.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** ----------------------------------
* -----------------------------------
* note stack
  * when doing "push"
    a stack-pointer moves to lower address
  * note that another style is that
    when doing "push"
    a stack-pointer moves to higher address
  * the stack-pointer
    always stores the address of current-free-address of the stack
  * note that another style is that
    under the stack-pointer
    there always stores the value of the-top-of-the-stack
* argument_stack
** ----------------------------------
** memory allocation
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$argument_stack = 1024 * 1024 * jo_size

      preserve 64 * jo_size
   address$argument_stack labeling
      preserve size$argument_stack
   #+end_src
** ----------------------------------
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$argument_stack r15

   }
   #+end_src
** push & pop                         :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_argument_stack register \{
      mov [pointer$argument_stack], register
      add pointer$argument_stack, jo_size
   \}

   macro pop_argument_stack register \{
      sub pointer$argument_stack, jo_size
      mov register, [pointer$argument_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$argument_stack:
      xx address$argument_stack

   }
   #+end_src
** push & pop                         :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   macro pop_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* return_stack
** ----------------------------------
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$return_stack = 1024 * 1024 * jo_size

      preserve 64 * jo_size
   address$return_stack labeling
      preserve size$return_stack
   #+end_src
** ----------------------------------
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$return_stack r14

   }
   #+end_src
** push & pop                         :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_return_stack register \{
      mov [pointer$return_stack], register
      add pointer$return_stack, jo_size
   \}

   macro pop_return_stack register \{
      sub pointer$return_stack, jo_size
      mov register, [pointer$return_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$return_stack:
      xx address$return_stack

   }
   #+end_src
** push & pop                         :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_return_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$return_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$return_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$return_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$return_stack], eax
      pop eax
      finish if
   \}

   macro pop_return_stack register \{
      if register in <eax>
      mov ebx, [pointer$return_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$return_stack], ebx
      else
      mov eax, [pointer$return_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$return_stack], eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* -----------------------------------
* next
  #+begin_src fasm :tangle cicada-nymph.fasm
  match =64bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp qword [rax]
  \}

  }


  match =32bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp dword [rax]
  \}

  }
  #+end_src
* note play with jo & jojo
  1. at the beginning
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
       - [@][@][ (square) ]
                 (square)
                 (end)
       #+end_src
  2. next
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
                 (square)
       - [@][@][ (square) ] - [@][@][ (dup) ]
                 (end)                (mul)
                                      (end)
       #+end_src
  3. next
     * argument-stack
       << 2, 2 >>
     * return-stack
       #+begin_src return-stack
                 (square)             (dup)
       - [@][@][ (square) ] - [@][@][ (mul) ]
                 (end)                (end)
       #+end_src
  4. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
                                      (dup)
                 (square)             (mul)
       - [@][@][ (square) ] - [@][@][ (end) ]
                 (end)
       #+end_src
  5. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)
       - [@][@][ (end) ] - [@][@][ (dup) ]
                                   (mul)
                                   (end)
       #+end_src
  6. next
     * argument-stack
       << 4, 4 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)          (dup)
       - [@][@][ (end) ] - [@][@][ (mul) ]
                                   (end)
       #+end_src
  7. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
                 (square)          (dup)
                 (square)          (mul)
       - [@][@][ (end) ] - [@][@][ (end) ]
       #+end_src
  8. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
                 (square)
                 (square)
       - [@][@][ (end) ]
       #+end_src
  9. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
       - [  ]
       #+end_src
  10. it is really simple
      ^-^
      is it not ?
* -----------------------------------
* link
  #+begin_src fasm :tangle cicada-nymph.fasm
  ;; initial link to point to 0 (as null)
  link = 0
  #+end_src
* primitive_string_area
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   address$primitive_string_area:
      times 64 * 1024 db 0

   address$core_file:
      file "core/core.cn"
   end$core_file:

   end$primitive_string_area:

   current_free_address$primitive_string_area = address$primitive_string_area
   #+end_src
** make_primitive_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro make_primitive_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dw (.end$string - .start$string)
      load .length word from (.end$string)
   finish virtual
   store word .length at (current_free_address$primitive_string_area)

   current_free_address$primitive_string_area = current_free_address$primitive_string_area + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      finish virtual
      store byte .char at (current_free_address$primitive_string_area)
      current_free_address$primitive_string_area = current_free_address$primitive_string_area + 1
   finish repeat

   }
   #+end_src
* function-jo
** note
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
** define_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_area

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; here follows a jojo as function-body

   }
   #+end_src
** explain$function
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$function:
      mov rbx, [current_free_address$local_byte]
      push_return_stack rbx
      mov rbx, [current_free_address$local_jo]
      push_return_stack rbx
      add rax, jo_size
      push_return_stack rax
      next
   #+end_src
* primitive-function-jo
** note
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
** define_primitive_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_area

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:

      ;; here follows assembly code
      ;; as primitive function body

   }
   #+end_src
* variable-jo
** note
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
** define_variable
   * length__#jo = [jo - jo_size * 3]
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   length__#jo:
      xx 1

   name__#jo:
      xx current_free_address$primitive_string_area

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; here follows a value of jo_size
      ;; only one value is allowed

   }
   #+end_src
** explain$variable                   :64bit:
   * in memory
      | value-1 |
      | ...     |
      | value-n |
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   explain$variable:
      mov rcx, [rax - (jo_size * 3)]
      add rax, jo_size
   .loop:
      mov rdx, qword [rax]
      push_argument_stack rdx
      add rax, jo_size
      loop .loop
      next

   }
   #+end_src
** explain$variable                   :32bit:
   * in memory
      | value-1 |
      | ...     |
      | value-n |
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   explain$variable:
      mov rcx, [rax - (jo_size * 3)]
      add rax, jo_size
   .loop:
      mov rdx, dword [rax]
      push_argument_stack rdx
      add rax, jo_size
      loop .loop
      next

   }
   #+end_src
* exception-jo
** 記
   * (prepare-for) 展開
   * (exception_head) 無爲
   * (!exception)
     其 jo 本身用以搜索到位置
     而 定義其 jo 的 jojo 被植入到所搜索到的位置
   * 設計的不足之處在於
     在調用 (!exception) 的時候
     調用它的函數不能傳遞給 (!exception) 一些參數
** note
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
** define_exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_exception string, jo {

   define_exception__#jo:

   name__#jo:
      xx current_free_address$primitive_string_area

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$exception

      ;; here follows a jojo as function-body

   }
   #+end_src
** note return-stack in action
   1. when "explain$exception" is called
      jojo by jojo
      it searchs the jo stored in "rax" in the return-stack
      of course
      only jojo with "exception_head" as head needs to be searched
   2. for example
      we have
      #+begin_src fasm
      define_exception "!exception-1", !exception_1
         xx fun1
         xx fun2
         xx end
      #+end_src
   3. return-stack
      #+begin_src return-stack
                                          (prepare_for)
                                            (exception_head)
                                            (!exception_1)
                                            (!exception_2)
                                            (end)
           (prepare_for)                  (function_1)
      - [@][ (exception_head) ] - [@][@][ (function_2) ] - ... - [@][@][ (!exception_1) ]
             (!exception_1)               (end)                          (end)
             (!exception_2)
             (end)
           (function_1)
           (function_2)
           (end)
      #+end_src
   4. next
      * pointer$argument_stack
        should be set to the above [@]
      * and
        to call "next" again
        the return-stack should be change to
        #+begin_src return-stack
        - [@][@][ (fun1) ]
                  (fun2)
                  (end)
        #+end_src
** note the plan
   * so
     we need a two-level loop
   * note that
     although
     we have to use assembly code
     to write primitive functions
     but
     we still can use argument-stack
     to pass arguments
** explain$exception                  :64bit:
   * no error handling for now
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   explain$exception:
      mov rsi, rax

   .next_jojo:
      pop_return_stack rbx
      mov rax, qword [rbx]
      cmp rax, exception_head
      je .next_jo
      cmp pointer$return_stack, address$return_stack
      je .not_found
      jmp .next_jojo


   .next_jo:
      ;; expecting
      ;;   rbx jojo
      ;;   rsi jo (to cmp)
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, rsi
      je .found
      test rax, rax
      jz .next_jojo
      jmp .next_jo


   .found:
      ;; expecting
      ;;   pointer$return_stack
      ;;   rsi jo
      pop_return_stack rax
      mov pointer$argument_stack, rax

      mov rbx, [current_free_address$local_jo]
      push_return_stack rbx

      mov rbx, [current_free_address$local_byte]
      push_return_stack rbx

      add rsi, jo_size
      push_return_stack rsi
      next

   .not_found:
      call __exit_with_six

   }
   #+end_src
** explain$exception                  :32bit:
   * no error handling for now
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   explain$exception:
      mov rsi, rax

   .next_jojo:
      pop_return_stack rbx
      mov rax, dword [rbx]
      cmp rax, exception_head
      je .next_jo
      mov rdx, [pointer$return_stack]
      cmp rdx, address$return_stack
      je .not_found
      jmp .next_jojo


   .next_jo:
      ;; expecting
      ;;   rbx jojo
      ;;   rsi jo (to cmp)
      add rbx, jo_size
      mov rax, dword [rbx]
      cmp rax, rsi
      je .found
      test rax, rax
      jz .next_jojo
      jmp .next_jo


   .found:
      ;; expecting
      ;;   pointer$return_stack
      ;;   rsi jo
      pop_return_stack rax
      mov [pointer$argument_stack], rax

      mov rbx, [current_free_address$local_jo]
      push_return_stack rbx

      mov rbx, [current_free_address$local_byte]
      push_return_stack rbx

      add rsi, jo_size
      push_return_stack rsi
      next

   .not_found:
      call __exit_with_six

      }
   #+end_src
* -----------------------------------
* execute-jo & structure of jo
** ----------------------------------
** execute-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack rax
      jmp qword [rax]

   }


   match =32bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack eax
      jmp dword [eax]

   }
   #+end_src
** ----------------------------------
** *jo-size*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*jo-size*", V__jo_size
      xx jo_size
   #+end_src
** jo->name
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->name", jo_to_name
      ;; << jo -- string[address, length] >>
      xx literal, jo_size, subtraction
      xx literal, jo_size, subtraction
      xx fetch
      xx address_to_primitive_string
      xx end
   #+end_src
** jo->link
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->link", jo_to_link
      ;; << jo -- link >>
      xx literal, jo_size
      xx subtraction
      xx end
   #+end_src
** last-jo,jotionary?
   * first jo in assembly code
     is the last jo in jotionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "last-jo,jotionary?", last_jo__jotionary?
      ;; << jo -- bool >>
      xx jo_to_link
      xx fetch
      xx zero?
      xx end
   #+end_src
** jo->pre-jo
   * treat last-jo,jotionary specially
     i.e. return zero on that case
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->pre-jo", jo_to_pre_jo
      ;; << jo -- pre-jo >>
      xx jo_to_link
      xx fetch
      xx dup, zero?, false?branch, 2
      xx   end
      xx literal, jo_size
      xx addition
      xx end
   #+end_src
** jo->type
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->type", jo_to_type
      ;; << jo -- type >>
      xx dup

      xx dup, fetch
      xx swap, subtraction, literal, jo_size, equal?, false?branch, 4
      xx   drop, zero
      xx   end

      xx fetch
      xx end
   #+end_src
** ----------------------------------
* primitive-string-area
** *primitive-string-area*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*primitive-string-area*", V__primitive_string_area
      xx address$primitive_string_area

   define_variable "*size,primitive-string-area*", V__size__primitive_string_area
      xx (end$primitive_string_area - address$primitive_string_area)

   ;; *current-free-address,primitive-string-area*
   ;; is at epilog
   #+end_src
** address->primitive-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "address->primitive-string", address_to_primitive_string
      ;; << address -- string[address, length] >>
      xx dup
      xx literal, 2, addition  ;; address
      xx swap, fetch_two_bytes ;; length
      xx end
   #+end_src
* type of jo
** primitive-function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "primitive-function-jo?", primitive_function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx zero?
      xx end
   #+end_src
** function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "function-jo?", function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$function
      xx equal?
      xx end
   #+end_src
** exception-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "exception-jo?", exception_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$exception
      xx equal?
      xx end
   #+end_src
** variable-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "variable-jo?", variable_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$variable
      xx equal?
      xx end
   #+end_src
* -----------------------------------
* end & taca
** 記 結尾珠
   * end 和 taca 這兩個結尾珠代表將執行退出操作
     在退出時
     它們將會從返回棧頂取出三個值
     從棧頂開始數 這三個值分別是
     1. 結束執行的一串珠珠本身
        這個值是被捨棄的
     2. local_jo 中的一個地址
        用於重置
        [current_free_address$local_jo]
     3. local_byte 中的一個地址
        用於重置
        [current_free_address$local_byte]
   * end 和 taca 的區別在於
     * end
       入返回棧一串新的珠珠
       [三個值一組的存在]
     * taca
       用一串新的珠珠
       代替返回棧頂的一串珠珠
       [三個值一組的存在]
** end
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "end", end
      pop_return_stack rbx
      pop_return_stack rax
      mov [current_free_address$local_jo], rax
      pop_return_stack rax
      mov [current_free_address$local_byte], rax
      next
   #+end_src
** taca
   * tail-call
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      pop_return_stack rax
      mov [current_free_address$local_jo], rax
      pop_return_stack rax
      mov [current_free_address$local_byte], rax
      mov rax, [rbx]
      jmp qword [rax]
   }


   match =32bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      pop_return_stack rcx
      mov [current_free_address$local_jo], rcx
      pop_return_stack rcx
      mov [current_free_address$local_byte], rcx
      mov rax, [rbx]
      jmp dword [rax]

   ;;;; old note
   ;; ><><>< can not be the following
   ;; maybe still something wrong with pop_return_stack
   ;; but I care less about this now
   ;; define_primitive_function "<>", taca
   ;;    pop_return_stack ebx
   ;;    pop_return_stack eax
   ;;    mov [current_free_address$local_jo], eax
   ;;    mov eax, [ebx]
   ;;    jmp dword [eax]

   }
   #+end_src
** note explicit tail call in action
   1. the tail position of a function body must be recognized
      explicit tail call is used to achieve this
   2. thus
      tail-recursive-call can be use to do loop
      without pushing too many address into return-stack
   3. for example if we have a function
      which is called "example"
      #+begin_src fasm
      define_function "example", example
         xx fun1
         xx fun2
         xx taca, example
      #+end_src
   4. and we have the following jojo in return-stack
      #+begin_src return-stack
      - [@][@][ (example) ]
                (end)
      #+end_src
   5. next
      #+begin_src return-stack
                (example)
      - [@][@][ (end) ] - [@][@][ (fun1) ]
                                  (fun2)
                                  (taca)
                                  (example)
      #+end_src
   6. next
      #+begin_src return-stack
                (example)         (fun1)
      - [@][@][ (end) ] - [@][@][ (fun2) ]
                                  (taca)
                                  (example)
      #+end_src
   7. next
      #+begin_src return-stack
                                  (fun1)
                (example)         (fun2)
      - [@][@][ (end) ] - [@][@][ (taca) ]
                                  (example)
      #+end_src
   8. next
      by the definition of taca
      #+begin_src return-stack
                (example)
      - [@][@][ (end) ] - [@][@][ (fun1) ]
                                  (fun2)
                                  (taca)
                                  (example)
      #+end_src
   9. you can see return-stack of (8.)
      is the same as (5.)
      it is clear how the example function
      is actually a loop now
* -----------------------------------
* helper function in assembly
** ----------------------------------
** __exit_with_TOS                    :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_TOS:
      pop_argument_stack linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_zero                   :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_zero:
      xor linux64_sys_1_rdi, linux64_sys_1_rdi
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_six                    :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __exit_with_six:
      mov linux64_sys_1_rdi, 6
      mov linux64_sys_n_rax, linux64_syscall_exit
      syscall

   }
   #+end_src
** __print_string                     :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __print_string:
      ;; << address, length -- >>
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      pop_argument_stack linux64_sys_3_rdx     ;; max length to be write
      pop_argument_stack linux64_sys_2_rsi     ;; address
      mov linux64_sys_1_rdi, 1                 ;; stdout
      mov linux64_sys_n_rax, linux64_syscall_write
      syscall
      ret

   }
   #+end_src
** __reset_argument_stack             :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __reset_argument_stack:
      mov pointer$argument_stack,  address$argument_stack
      ret

   }
   #+end_src
** __reset_return_stack               :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   __reset_return_stack:
      mov pointer$return_stack,    address$return_stack
      ret

   }
   #+end_src
** ----------------------------------
** __exit_with_TOS                    :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_TOS:
      pop_argument_stack linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_zero                   :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_zero:
      xor linux32_sys_1_ebx, linux32_sys_1_ebx
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __exit_with_six                    :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __exit_with_six:
      mov linux32_sys_1_ebx, 6
      mov linux32_sys_n_eax, linux32_syscall_exit
      syscall

   }
   #+end_src
** __print_string                     :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __print_string:
      ;; << address, length -- >>
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      pop_argument_stack linux32_sys_3_edx     ;; max length to be write
      pop_argument_stack linux32_sys_2_ecx     ;; address
      mov linux32_sys_1_ebx, 1                 ;; stdout
      mov linux32_sys_n_eax, linux32_syscall_write
      syscall
      ret

   }
   #+end_src
** __reset_argument_stack             :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __reset_argument_stack:
      mov rax, address$argument_stack
      mov [pointer$argument_stack], rax
      ret

   }
   #+end_src
** __reset_return_stack               :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   __reset_return_stack:
      mov rax, address$return_stack
      mov [pointer$return_stack], rax
      ret

   }
   #+end_src
** ----------------------------------
** __reset_local_jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   __reset_local_jo:
      mov rax, address$local_jo
      mov [current_free_address$local_jo], rax
      ret
   #+end_src
** __reset_local_byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   __reset_local_byte:
      mov rax, address$local_byte
      mov [current_free_address$local_byte], rax
      ret
   #+end_src
** ----------------------------------
* -----------------------------------
* *the-story-begin*
** ----------------------------------
** 記 匯編代碼中的初始化
   * 注意
     所入返回棧的應該是 jojo 而不是 jo
** begin_to_interpret_threaded_code   :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux, platform {

   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented

      call __reset_argument_stack
      call __reset_return_stack

      pop_return_stack rax
      mov rax, jojo_for__report_return_stack_is_empty_and_exit
      push_return_stack rax

      mov rax, address$local_byte
      push_return_stack rax

      mov rax, address$local_jo
      push_return_stack rax

      mov rax, first_jojo
      push_return_stack rax
      next

   first_jojo:
      ;; xx little_test
      xx initialization
      xx load_core_file
      xx taca, basic_REPL

   }
   #+end_src
** initialization
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "initialization", initialization
      ;; << -- >>
      xx init__rule_set__make_jojo
      xx end
   #+end_src
** ----------------------------------
** note top-level-REPL
   * a top-level-REPL always lives at the bottom of return-stack
     #+begin_src return-stack
               (function)
               (function)
     - [@][@][ (taca) ]
               (top-level-REPL)
     #+end_src
   * right below the return-stack
     there is a (report-return-stack-is-empty-and-exit)
     so actually
     #+begin_src return-stack
                                                             (function)
                                                             (function)
     - [ (report-return-stack-is-empty-and-exit) ] - [@][@][ (taca) ]
                                                             (top-level-REPL)
     #+end_src
   * when you say bye to a top-level-REPL
     (report-return-stack-is-empty-and-exit) will be executed
** report-return-stack-is-empty-and-exit
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$report_return_stack_is_empty_and_exit:
      db "* the return-stack is empty now", 10
      db "  good bye ^-^/", 10
   .end:
   length$report_return_stack_is_empty_and_exit = (.end - string$report_return_stack_is_empty_and_exit)

   define_primitive_function "report-return-stack-is-empty-and-exit", report_return_stack_is_empty_and_exit
      ;; << -- >>
      mov rax, string$report_return_stack_is_empty_and_exit
      mov rcx, length$report_return_stack_is_empty_and_exit
      push_argument_stack rax
      push_argument_stack rcx
      call __print_string
      call __exit_with_zero

   jojo_for__report_return_stack_is_empty_and_exit:
      xx report_return_stack_is_empty_and_exit
   #+end_src
** reset-top-level-REPL
   * local_jo & local_byte
     will get reseted in by this function
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
      ;; << top_level_REPL [jo] -- >>
      call __reset_return_stack
      call __reset_local_jo
      call __reset_local_byte
      pop_argument_stack rax
      jmp qword [rax]

   }

   match =32bit, machine {

   define_primitive_function "reset-top-level-REPL", reset_top_level_REPL
      ;; << top_level_REPL [jo] -- >>
      call __reset_return_stack
      call __reset_local_jo
      call __reset_local_byte
      pop_argument_stack rax
      jmp dword [rax]

   }
   #+end_src
** ----------------------------------
** exit_with_TOS a.k.a. bye
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bye", exit_with_TOS
      call __exit_with_TOS
   #+end_src
** ----------------------------------
** little_test
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", V__little_test_number
      xx 3

   define_function "little_test", little_test

      ;;;; variable
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 3

      ;;;; literal
      ;; xx literal, 4
      ;; xx exit_with_TOS
      ;;;; exit ocde : 4

      ;;;; address
      ;; xx address, V__little_test_number, fetch, add2
      ;; xx address, V__little_test_number, save
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 5

      ;;;; end
      ;; xx literal, 2, negate
      ;; xx literal, 8
      ;; xx addition
      ;; xx exit_with_TOS
      ;;;; 6

      ;;;; taca
      ;; xx literal, 2
      ;; xx literal, 4
      ;; xx power
      ;; xx exit_with_TOS
      ;;;; exit ocde : 16

      ;;;; write_byte
      ;; xx literal, 64, write_byte
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; @

      ;;;; read_byte
      ;; xx read_byte, write_byte
      ;; xx exit_with_TOS
      ;;;;

      ;;;; branch
      ;; xx read_byte, write_byte
      ;; xx branch, -3
      ;;;; read a string that ended by <return>
      ;;;; write the readed string
      ;;;; or we can say
      ;;;; read line and write line
      ;;;; or we can say
      ;;;; echo line

      ;;;; false?branch
      ;; xx false, false?branch, 9
      ;; xx   literal, 64, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx true, false?branch, 9
      ;; xx   literal, 65, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; A

      ;;;; read_word & write_string
      ;; xx read_word, write_string
      ;; xx literal, 10, write_byte
      ;; xx read_word_for_REPL, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; read line
      ;;;; write first two words of the line

      ;;;; string->integer
      ;; xx read_word, string_to_integer
      ;; xx exit_with_TOS
      ;;;; type 123
      ;;;; exit code 123

      ;;;; use jo_to_name to test the macro make_primitive_string
      ;; xx literal, jo_to_name, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx literal, addition, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; print "jo->name"
      ;;;; print "add"

      ;;;; xxoverxx
      ;; xx literal, 1
      ;; xx literal, 2
      ;; xx literal, 3
      ;; xx literal, 4
      ;; xx xxoverxx
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 2 1 4 3 2 1

      ;;;; find_jo__through_jo_link
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, find_jo__through_jo_link ;; add
      ;; xx drop ;; true
      ;; xx execute_jo
      ;; xx write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 1 2 add
      ;;;; print "3"

      ;;;; basic-REPL (without the ability to define function)
      ;;;; after this test
      ;;;; we will use basic-REPL to do further tests
      ;; xx basic_REPL
      ;;;; 1 2 add .
   #+end_src
** ----------------------------------
* -----------------------------------
* instruction
** ----------------------------------
** note side-effect
   * an instruction
     is a special primitive function
     which does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
** note naming
   * the naming convention in assembly code
     of instruction
     is the same as it of jo
   * the name of an instruction
     might not be exported to cicada-language as a function
     but as a variable
** ----------------------------------
** literal
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; << -- fixnum >>
      pop_return_stack rbx
        mov rax, [rbx]
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address
      ;; << -- address >>
      pop_return_stack rbx
        mov rax, [rbx]
        add rax, jo_size
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*branch*", V__branch
      xx branch

   define_primitive_function "", branch
      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*false?branch*", V__false?branch
      xx false?branch

   define_primitive_function "", false?branch
      ;; << true of false -- >>
      pop_argument_stack rax
      test rax, rax
      jnz help__false?branch__not_to_branch

      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next

   help__false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** note action of prepare_for
   1. proper exception handling
      is implemented by doing side-effect on return-stack
   2. when executing the following code block
      #+begin_src fasm
      xx prepare_for
      xx exception_head
      xx   !exception_1
      xx   !exception_2
      xx   end
      xx function_1
      xx function_2
      xx end
      #+end_src
   3. note that
      for (prepare_for)
      (end) is used as an unique id
      but not a ending-jo
   3. return-stack
      #+begin_src return-stack
      - [@][@][ (prepare_for) ]
                  (exception_head)
                  (!exception_1)
                  (!exception_2)
                  (end)
                (function_1)
                (function_2)
                (end)
      #+end_src
   4. next
      * this is how the return-stack looks
        right before exception_head is executed
        #+begin_src return-stack
                (prepare_for)
        - [@][@][ (exception_head) ]
                  (!exception_1)
                  (!exception_2)
                  (end)
                (function_1)
                (function_2)
                (end)
        #+end_src
      * after exception_head is executed
        #+begin_src return-stack
                                            (prepare_for)
                                              (exception_head)
                                              (!exception_1)
                                              (!exception_2)
             (prepare_for)                    (end)
        - [@][ (exception_head) ] - [@][@][ (function_1) ]
               (!exception_1)               (function_2)
               (!exception_2)               (end)
               (end)
             (function_1)
             (function_2)
             (end)
        #+end_src
** prepare_for                        :64bit:
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "", prepare_for
      ;; << -- >>
      pop_return_stack rbx

      pop_return_stack rcx
      pop_return_stack rdx

      push_return_stack pointer$argument_stack
      push_return_stack rbx

      push_return_stack rdx
      push_return_stack rcx

   .next:
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, end
      je .then
      jmp .next
   .then:
      add rbx, jo_size
      push_return_stack rbx
      next

   }
   #+end_src
** prepare_for                        :32bit:
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "", prepare_for
      ;; << -- >>
      pop_return_stack ebx

      pop_return_stack ecx
      pop_return_stack edx

      mov eax, [pointer$argument_stack]
      push_return_stack eax
      push_return_stack ebx

      push_return_stack edx
      push_return_stack ecx

   .next:
      add ebx, jo_size
      mov eax, dword [ebx]
      cmp eax, end
      je .then
      jmp .next
   .then:
      add ebx, jo_size
      push_return_stack ebx
      next

   }
   #+end_src
** *prepare-for*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*prepare-for*", V__prepare_for
      xx prepare_for
   #+end_src
** note action of exception_head
   * return-stack
     #+begin_src return-stack
          (prepare_for)
     - [@][ (exception_head) ]
            (!exception_1)
            (!exception_2)
            (end)
          (function_1)
          (function_2)
          (end)
     #+end_src
   * next
     * this is how the return-stack looks
       right before exception_head is executed
       #+begin_src return-stack
            (prepare_for)
              (exception_head)
       - [@][ (!exception_1) ]
              (!exception_2)
              (end)
            (function_1)
            (function_2)
            (end)
       #+end_src
     * after exception_head is executed
       the above two value in return-stack is removed
       note that
       only two value (not three)
       #+begin_src return-stack
       - [ ]
       #+end_src
** exception_head
   * this jo is served as a label in return-stack
     when explained
     it pops the jojo itself in
     and
     it pops the argument-stack pointer after it
   * and "explain$exception" will search for them
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", exception_head
      ;; << -- >>
      pop_return_stack rax
      pop_return_stack rax
      next
   #+end_src
** *exception-head*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*exception-head*", V__exception_head
      xx exception_head
   #+end_src
** ----------------------------------
* -----------------------------------
* the stack
** ----------------------------------
** note
   * the stack is the argument-stack
** ----------------------------------
** drop
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "drop", drop
      ;; << a -- >>
      pop_argument_stack rax
      next

   define_primitive_function "drop2", drop2
      ;; << a b -- >>
      pop_argument_stack rax
      pop_argument_stack rax
      next
   #+end_src
** dup                                :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "dup", dup
      ;; << a -- a, a >>
      mov  rax, [pointer$argument_stack - (1 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      mov  rbx, [pointer$argument_stack - (1 * jo_size)]
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      push_argument_stack rbx
      next

   }
   #+end_src
** dup                                :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "dup", dup
      ;; << a -- a a >>
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   }
   #+end_src
** over                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxxx", xoverxxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (5 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      next

   }
   #+end_src
** over                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxxx", xoverxxxx
      ;; << a | b c d -- a | b c d | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (5 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (6 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (5 * jo_size)]
      push_argument_stack rax
      next

   }
   #+end_src
** tuck
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tuck", tuck
      ;; << a b -- b | a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|tuck|xx", xtuckxx
      ;; << a | b c -- b c | a | b c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|x", xxtuckx
      ;; << a b | c -- c | a b | c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|xx", xxtuckxx
      ;; << a b | c d -- c d | a b | c d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   define_primitive_function "xxx|tuck|x", xxxtuckx
      ;; << a b c | d -- d | a b c | d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
** swap                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack rax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   }
   #+end_src
** swap                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack eax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack eax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next

   }
   #+end_src
** ----------------------------------
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*the-stack*", V__the_stack
      xx address$argument_stack
   #+end_src
** pointer                            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
      xx address$argument_stack

   define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
      ;; << -- >>
      mov [V__the_stack_pointer_snapshot + jo_size], pointer$argument_stack
      next

   }
   #+end_src
** pointer                            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_variable "*the-stack-pointer-snapshot*", V__the_stack_pointer_snapshot
      xx address$argument_stack

   define_primitive_function "snapshot-the-stack-pointer", snapshot_the_stack_pointer
      ;; << -- >>
      mov eax, [pointer$argument_stack]
      mov [V__the_stack_pointer_snapshot + jo_size], eax
      next

   }
   #+end_src
** ----------------------------------
* bool
** false & true
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "false", false
      ;; << -- false >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "true", true
      ;; << -- true >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** false? & true?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "false?", false?
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "true?", true?
      ;; << bool -- bool >>
      xx true, equal?
      xx end
   #+end_src
** and & or & not & xor
   * the following two functions are for bool value
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "not", CICADA__not
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "and", CICADA__and
      ;; << bool, bool -- bool >>
      xx false?, false?branch, (.true-$)/jo_size
      xx   drop
      xx   false
      xx   end
   .true:
      xx false?branch, 3
      xx   true
      xx   end
      xx false
      xx end

   define_function "or", CICADA__or
      ;; << bool, bool -- bool >>
      xx false?branch, (.false-$)/jo_size
      xx   drop
      xx   true
      xx   end
   .false:
      xx false?branch, 3
      xx   true
      xx   end
      xx false
      xx end

   define_function "xor", CICADA__xor
      ;; << bool, bool -- bool >>
      xx false?branch, (.false-$)/jo_size
      xx   CICADA__not
      xx   end
   .false:
      xx end
   #+end_src
* fixnum
** ----------------------------------
** zero & one
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "zero", zero
      ;; << -- 0 >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "one", one
      ;; << -- 1 >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** zero? & one?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero?", zero?
      ;; << bool -- bool >>
      xx zero, equal?
      xx end

   define_function "one?", one?
      ;; << bool -- bool >>
      xx one, equal?
      xx end
   #+end_src
** ----------------------------------
** add & sub                          :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      inc qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      dec qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rax
      add qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rax
      sub qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   }
   #+end_src
** add & sub                          :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      pop_argument_stack rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      pop_argument_stack rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      pop_argument_stack rax
      add rax, 8
      push_argument_stack rax
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      pop_argument_stack rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      pop_argument_stack rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      pop_argument_stack rax
      sub rax, 8
      push_argument_stack rax
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      add rax, rbx
      push_argument_stack rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      sub rax, rbx
      push_argument_stack rax
      next

   }
   #+end_src
** mul
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "mul", multiple
      ;; << a b -- a*b >>
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next
   #+end_src
** negate
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negate", negate
      ;; << n --  -n >>
      xx zero
      xx swap, subtraction
      xx end
   #+end_src
** power
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "power", power
      ;; n must be nature number for now
      ;; << a, n -- a^n >>
      ;; 1. when a = 0, n =/= 0
      ;;    the power__loop returns 0
      ;; 2. when a = 0, n = 0
      ;;    the power__loop returns 1
      ;;    but I need it to return 0
      xx over, zero?, false?branch, 3
      xx   drop
      xx   end
      xx literal, 1, swap ;; leave product
      xx power__loop
      xx end

   define_function "power,loop", power__loop
      ;; << a, product, n -- a^n >>
      xx dup, zero?, false?branch, 5
      xx   drop, swap, drop
      xx   end
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx taca, power__loop
   #+end_src
** div & mod
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "moddiv", moddiv
      ;; << a, b -- a mod b, quotient >>
      ;; << dividend, divisor -- remainder, quotient >>
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   define_function "divmod", divmod
      ;; << a, b -- quotient, a mod b >>
      xx moddiv, swap
      xx end

   define_function "div", division
      ;; << a, b -- quotient >>
      xx divmod, drop
      xx end

   define_function "mod", modulo
      ;; << a, b -- a mod b >>
      xx moddiv, drop
      xx end
   #+end_src
** ----------------------------------
** equal? & greater-than? & less-than?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "equal?", equal?
      ;; << a, b -- bool >>
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "less-than?", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-than?", greater_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   define_primitive_function "less-or-equal?", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-or-equal?", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** equal2?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "equal2?", equal2?
      ;; << a1, b1, a2, b2 -- bool >>
      xx xswapxx
      xx equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx equal?
      xx end
   #+end_src
** negative? & positive?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negative?", negative?
      ;; << integer -- bool >>
      xx zero, less_than?
      xx end

   define_function "positive?", positive?
      ;; << integer -- bool >>
      xx zero, greater_than?
      xx end
   #+end_src
** ----------------------------------
* memory
** note fetch & save
   * although the following functions are all side-effect
     but I use "save" instead of "save!"
   * (fetch) and (save) default to a jo_size
** note endianness of n-fetch & n-save
   * big-endian is used
     in memory
     | value-1 |
     | value-2 |
     | value-3 |
     on stack
     << value-1, value-2, value-3 >>
   * thus
     what saved into the address
     will re-occur when fetching through the address
   * thus
     I do not implement n-fetch-byte & n-save-byte
     for the endianness of machine
     might not be big-endian
** fetch                              :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword [rbx]
      push_argument_stack rax
      next

   define_primitive_function "n-fetch", n_fetch
      ;; << address, n -- value-1, ..., value-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, qword [rdx]
      push_argument_stack rax
      add rdx, jo_size
      loop .loop
      next

   }
   #+end_src
** save                               :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov [rbx], rax
      next

   define_primitive_function "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   define_primitive_function "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   define_primitive_function "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   define_primitive_function "n-save", n_save
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, jo_size
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, jo_size
   .loop:
      pop_argument_stack rax
      mov qword [rdx], rax
      sub rdx, jo_size
      loop .loop
      next

   define_primitive_function "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add qword [rbx], rax
      next

   define_primitive_function "sub-save", sub_save
      ;; ( number to sub, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub qword [rbx], rax
      next

   }
   #+end_src
** fetch                              :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword [rbx]
      push_argument_stack rax
      next

   define_primitive_function "n-fetch", n_fetch
      ;; << address, n -- value-1, ..., value-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, dword [rdx]
      push_argument_stack rax
      add rdx, jo_size
      loop .loop
      next

   }
   #+end_src
** save                               :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov [rbx], rax
      next

   define_primitive_function "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   define_primitive_function "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   define_primitive_function "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   define_primitive_function "n-save", n_save
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, jo_size
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, jo_size
   .loop:
      pop_argument_stack rax
      mov dword [rdx], rax
      sub rdx, jo_size
      loop .loop
      next

   define_primitive_function "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add dword [rbx], rax
      next

   define_primitive_function "sub-save", sub_save
      ;; ( number to sub, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub dword [rbx], rax
      next

   }
   #+end_src
** clear
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "clear-memory", clear_memory
      ;; << size, address -- >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      xor rax, rax
   .loop:
      mov byte [rdx], al
      inc rdx
      dec rcx
      loop .loop
      next
   #+end_src
* bit
** note
   * xor a.k.a. diff
** or & and & xor & invert            :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "bit-and", bit_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      and [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-or", bit_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      or  [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-xor", bit_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      xor [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-invert", bit_invert
      ;; << a -- invert a >>
      not qword [pointer$argument_stack - (1 * jo_size)]
      next

   }
   #+end_src
** or & and & xor & invert            :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "bit-and", bit_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      and [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-or", bit_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      or  [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-xor", bit_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      xor [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bit-invert", bit_invert
      ;; << a -- invert a >>
      mov rax, [pointer$argument_stack]
      not dword [rax - (1 * jo_size)]
      next

   }
   #+end_src
** left & right[,sign]
   * "shl"
     shifts the destination operand left
     by the number of bits specified in the second operand
     The destination operand can be general register or memory
     The second operand can be an immediate value or the CL register
     as bits exit from the left, zeros in from the right
     The last bit that exited is stored in CF
     "sal" is a synonym for "shl"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bit-left", bit_left
      ;; ( fixnum, step -- fixnum * 2^step )
      pop_argument_stack rcx
      pop_argument_stack rax
      shl rax, cl
      push_argument_stack rax
      next

   define_primitive_function "bit-right", bit_right
      ;; ( fixnum, step -- fixnum / 2^step )
      pop_argument_stack rcx
      pop_argument_stack rax
      shr rax, cl
      push_argument_stack rax
      next

   define_primitive_function "bit-right,sign", bit_right__sign
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      pop_argument_stack rax
      sar rax, cl
      push_argument_stack rax
      next
   #+end_src
** get & set & clear & invert
   1. offset is of LSB
   2. offset in [0, ..., 63]
   3. step   in [1, ..., 64]
   4. >< need error handling on them
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; BT copies a bit from a given register to the carry flag
   define_primitive_function "get-bit", get_bit
      ;; ( fixnum, offset -- bit )
      pop_argument_stack rbx
      pop_argument_stack rax
      bt rax, rbx
      setc al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "set-bit", set_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      bts rax, rbx
      push_argument_stack rax
      next

   define_primitive_function "clear-bit", clear_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btr rax, rbx
      push_argument_stack rax
      next

   define_primitive_function "invert-bit", invert_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btc rax, rbx
      push_argument_stack rax
      next
   #+end_src
** find-[lowest|highest]-set-bit
   * "bsf" "bsr"
     instructions scan a word or double word for first set bit
     and store the index of this bit into destination operand
     which must be general register
     The bit string being scanned is specified by source operand
     it may be either general register or memory
     The ZF flag is set if the entire string is zero (no set bits are found)
     otherwise it is cleared
   * If no set bit is found
     the value of the destination register is undefined
     "bsf" scans from low order to high order (starting from bit index zero)
     "bsr" scans from high order to low order
   * note that
     if can not find set-bit
     the following functions will return -1
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "find-lowest-set-bit", find_lowest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsf rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next

   define_primitive_function "find-highest-set-bit", find_highest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsr rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next
   #+end_src
** test
   * test is written in cicada-nymph
     for these primitive-functions are added lately
   #+begin_src cicada-nymph
   2#10011001 2#01100110 bit-or  .#2
   2#10011001 2#01100110 bit-and .#2
   2#10011001 2#11111111 bit-xor .#2
   2#10011001 2#10011001 bit-xor .#2

   2#10011001 4 bit-left  .#2
   2#10011001 4 bit-right .#2
   2#-10011001 4 bit-right,sign .#2

   2#10011001 0 get-bit .
   2#10011001 1 get-bit .
   2#10011001 2 get-bit .
   2#10011001 3 get-bit .

   2#10011001 0 clear-bit .#2
   2#10011001 1 set-bit   .#2
   2#10011001 2 set-bit   .#2
   2#10011001 3 clear-bit .#2

   2#10011001 0 invert-bit .#2
   2#10011001 1 invert-bit .#2
   2#10011001 2 invert-bit .#2
   2#10011001 3 invert-bit .#2

   2#10011000 find-lowest-set-bit
   2#10011000 find-highest-set-bit

   2#00000000 find-lowest-set-bit
   2#00000000 find-highest-set-bit
   #+end_src
* -----------------------------------
* write-byte
** write-byte                         :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al
      mov linux64_sys_3_rdx, 1                 ;; max length to be write
      mov linux64_sys_2_rsi, buffer$write_byte ;; address
      mov linux64_sys_1_rdi, 1                 ;; stdout
      mov linux64_sys_n_rax, linux64_syscall_write
      syscall
      next

   }
   #+end_src
** write-byte                         :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al
      mov linux32_sys_3_edx, 1                 ;; max length to be write
      mov linux32_sys_2_ecx, buffer$write_byte ;; address
      mov linux32_sys_1_ebx, 1                 ;; stdout
      mov linux32_sys_n_eax, linux32_syscall_write
      syscall
      next

   }
   #+end_src
* reading-stack
** note
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   * (read-byte) only sees the tos of reading-stack
   * reading-stack helps to implement (eval-string)
     push and pop of reading-stack happens in the function (eval-string)
   * the interface action on string
     i.e. two values
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$reading_stack = 1024 * jo_size

      preserve 64 * jo_size
   address$reading_stack labeling
      preserve size$reading_stack

   pointer$reading_stack:
      xx address$reading_stack
   #+end_src
** push & pop & drop                  :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "push-reading-stack", push_reading_stack
      ;; << string[address, length] -- >>
      pop_argument_stack rax
      mov rbx, [pointer$reading_stack]
      mov [rbx], rax
      add qword [pointer$reading_stack], jo_size
      pop_argument_stack rax
      mov rbx, [pointer$reading_stack]
      mov [rbx], rax
      add qword [pointer$reading_stack], jo_size
      next

   define_primitive_function "pop-reading-stack", pop_reading_stack
      ;; << -- string[address, length] >>
      sub qword [pointer$reading_stack], jo_size
      mov rbx, [pointer$reading_stack]
      mov rax, [rbx]
      push_argument_stack rax
      sub qword [pointer$reading_stack], jo_size
      mov rbx, [pointer$reading_stack]
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "drop-reading-stack", drop_reading_stack
      ;; << -- >>
      sub qword [pointer$reading_stack], (jo_size * 2)
      next

   }
   #+end_src
** push & pop & drop                  :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "push-reading-stack", push_reading_stack
      ;; << string[address, length] -- >>
      pop_argument_stack rax
      mov rsi, [pointer$reading_stack]
      mov [rsi], rax
      add dword [pointer$reading_stack], jo_size
      pop_argument_stack rax
      mov rsi, [pointer$reading_stack]
      mov [rsi], rax
      add dword [pointer$reading_stack], jo_size
      next

   define_primitive_function "pop-reading-stack", pop_reading_stack
      ;; << -- string[address, length] >>
      sub dword [pointer$reading_stack], jo_size
      mov rsi, [pointer$reading_stack]
      mov rax, [rsi]
      push_argument_stack rax
      sub dword [pointer$reading_stack], jo_size
      mov rsi, [pointer$reading_stack]
      mov rax, [rsi]
      push_argument_stack rax
      next

   define_primitive_function "drop-reading-stack", drop_reading_stack
      ;; << -- >>
      sub dword [pointer$reading_stack], (jo_size * 2)
      next

   }
   #+end_src
** tos
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tos-reading-stack", tos_reading_stack
      ;; << -- string[address, length] >>
      mov rbx, [pointer$reading_stack]
      sub rbx, jo_size
      mov rax, [rbx]
      push_argument_stack rax
      mov rbx, [pointer$reading_stack]
      sub rbx, jo_size
      sub rbx, jo_size
      mov rax, [rbx]
      push_argument_stack rax
      next
   #+end_src
** reading-stack-empty?
   * only one string is in reading-stack and it length is zero
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "reading-stack-empty?", reading_stack_empty?
      ;; << -- bool >>
      xx literal, pointer$reading_stack, fetch
      xx literal, address$reading_stack
      xx equal?
      xx end
   #+end_src
* read-byte
** note end of file
   * do not exit the program
     when meeting <end-of-file>
     so
     when you hit <C-d>
     some you will not exit the interpreter
** note factoring
   * reading from file of stdin is slow
     thus
     1. when reading from file
        a whole file is readed at a time
        and saved to a buffer
     2. when reading from stdin
        a whole line is readed at a time
     3. note that
        reading line instead of keyboard-code
        will limit the design of the user interface
   * by factoring out the low-level calls
     that read a line from stdin
     we are able to implement eval-string easily
** read-line-from-stdin               :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "read-line-from-stdin", read_line_from_stdin
      ;; << buffer address, max length -- counter >>
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      xor linux64_sys_1_rdi, linux64_sys_1_rdi ;; stdin
      mov linux64_sys_n_rax, linux64_syscall_read
      syscall
      ;; the return value
      ;; is a count of the number of bytes transferred
      push_argument_stack rax
      next

   }
   #+end_src
** read-line-from-stdin               :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "read-line-from-stdin", read_line_from_stdin
      ;; << buffer address, max length -- counter >>
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_2_ecx
      xor linux32_sys_1_ebx, linux32_sys_1_ebx ;; stdin
      mov linux32_sys_n_eax, linux32_syscall_read
      syscall
      ;; the return value
      ;; is a count of the number of bytes transferred
      push_argument_stack rax
      next

   }
   #+end_src
** test read-line-from-stdin
   #+begin_src fasm
   define_function "", test__read_line_from_stdin
      xx literal, buffer$reading
      xx literal, max_input_length
      xx read_line_from_stdin
      xx pretty_write_integer
      xx literal, buffer$reading
      xx literal, 10
      xx write_string
      xx exit_with_TOS
      xx end
   #+end_src
** read-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_input_length = 64 * 1024

   buffer$reading labeling
      preserve max_input_length

   replace$reading labeling
      preserve 1024

   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx pop_reading_stack
      xx dup2, empty_string?, CICADA__not, false?branch, (.bad_tos-$)/jo_size
      xx   sub1, swap
      xx   tuck
      xx   add1, swap
      xx   push_reading_stack
      xx   fetch_byte
      xx   end
   .bad_tos:
      xx reading_stack_empty?, false?branch, (.not_empty-$)/jo_size
      xx   drop2
      xx   literal, buffer$reading
      xx   literal, max_input_length
      xx   read_line_from_stdin
      xx   dup, positive?, false?branch, (.read_error-$)/jo_size
      xx     literal, buffer$reading
      xx     swap
      xx     push_reading_stack
      xx     taca, read_byte
   .read_error:
      ;;   ignore <end-of-file>
      ;;   ignore reading error
      xx   drop
      xx   literal, buffer$reading
      xx   literal, 0
      xx   push_reading_stack
      xx   taca, read_byte
   .not_empty:
      xx   literal, error$read_byte
      xx   literal, length$read_byte
      xx   write_string
      xx   literal, replace$reading
      xx   literal, 1024
      xx   read_line_from_stdin
      xx   literal, replace$reading
      xx   swap
      xx   push_reading_stack
      xx   taca, read_byte

   error$read_byte:
      db "* (read-byte) meets empty-string in reading-stack", 10
      db "  and this empty-stack is not at the bottom of the reading-stack", 10
      db "  you can type a line to replace this empty string", 10
   .end:
   length$read_byte = (.end - error$read_byte)
   #+end_src
* load-core-file
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "load-core-file", load_core_file
     ;; << unknown -- unknown >>
     xx literal, address$core_file
     xx literal, (end$core_file - address$core_file)
     xx push_reading_stack
     xx end
  #+end_src
* -----------------------------------
* char
** space-char?
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-char?", space_char?
      ;; << char -- bool >>
      xx literal, 32
      xx less_or_equal?
      xx end
   #+end_src
** bar-ket-char?
   * () [] {}
     but not <>
   * double-quote is viewed as special bar-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "bar-ket-char?", bar_ket_char?
      ;; << char -- bool >>
      xx dup, literal, '(', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ')', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '[', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ']', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '{', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '}', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '"', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** digit-char?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-char?", digit_char?
      ;; << char -- bool >>
      xx dup, literal, '0', less_than?, false?branch, 4
      xx   drop, false
      xx   end
      xx dup, literal, '9', less_or_equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** digit-char->number & number->digit-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-char->number", digit_char_to_number
      ;; << char -- decimal-digit >>
      xx literal, '0'
      xx subtraction
      xx end

   define_function "number->digit-char", number_to_digit_char
      ;; << decimal-digit -- char >>
      xx literal, '0'
      xx addition
      xx end
   #+end_src
* buffer
** note
   * a buffer is a large vector
     and some functions do not care about how large it is
** compare-buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; return false when length == 0
   define_primitive_function "compare-buffer", compare_buffer
      ;; << address, address, length -- bool >>
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** cursor->next-matching-byte
   * note that
     it is the NEXT matching-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "cursor->next-matching-byte", cursor_to_next_matching_byte
      ;; << cursor, byte -- cursor new address >>
      xx over, add1, fetch_byte
      xx over, equal?, false?branch, 4
      xx   drop, add1
      xx   end
      xx swap
      xx add1, swap
      xx taca, cursor_to_next_matching_byte
   #+end_src
* string
** ----------------------------------
** note io about string
** write-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-string", write_string
      ;; << string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end
      xx sub1, swap
      xx dup, fetch_byte, write_byte
      xx add1, swap
      xx taca, write_string

   define_function ".s", ALIAS__write_string
      ;; << integer -- >>
      xx write_string
      xx end
   #+end_src
** pretty_write_string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pretty-write-string", pretty_write_string
      ;; << integer -- >>
      xx write_string
      xx literal, 10
      xx write_byte
      xx end
   #+end_src
** ----------------------------------
** empty-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "empty-string?", empty_string?
     ;; << string[address, length] -- bool >>
     xx swap, drop
     xx zero?
     xx end
   #+end_src
** string-equal?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-equal?", string_equal?
      ;; << string[address, length], string[address, length] -- bool >>
      xx xoverxx, equal?, false?branch, 4
      xx   swap
      xx   compare_buffer
      xx   end
      xx drop, drop2
      xx false
      xx end
   #+end_src
** string-[head|tail],char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,char", string_head__char
      ;; << string[address, length] -- char >>
      xx drop, fetch_byte
      xx end

   define_function "string-tail,char", string_tail__char
      ;; << string[address, length] -- [address + 1, length + 1] >>
      xx sub1, swap
      xx add1
      xx swap
      xx end
   #+end_src
** string->buffer!
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "string->buffer!", string_to_buffer!
      ;; ( string[address, length], buffer[address] -- )
      pop_argument_stack rdi ;; destination
      pop_argument_stack rcx ;; counter
      pop_argument_stack rsi ;; source
      rep movsb
      next
   #+end_src
** string-reverse!                    :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rdi, buffer$string_reverse!
      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
      rep movsb

      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** string-reverse!                    :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rbx, [pointer$argument_stack]
      mov rdi, buffer$string_reverse!
      mov rcx, [rbx - (1 * jo_size)]
      mov rsi, [rbx - (2 * jo_size)]
      rep movsb

      mov rcx, [rbx - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [rbx - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** char-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char-string?", char_string?
      ;; << string[address, length], char -- bool >>
      xx xxswapx
      xx dup, one?, false?, false?branch, 5
      xx   drop2, drop
      xx   false
      xx   end
      xx string_head__char, equal?, false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
** zero-string?
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "end"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero-string?", zero_string?
      ;; << string[address, length] -- bool >>
      xx dup2, literal, '0', char_string?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2
      xx string_head__char, literal, '-', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char, literal, '0', char_string?
      xx end
   #+end_src
** digit-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digit-string?", digit_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx over, fetch_byte, digit_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, digit_string?
      xx drop2, false
      xx end
   #+end_src
** integer-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "integer-string?", integer_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, literal, '-', char_string?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
      xx   string_tail__char
      xx   digit_string?
      xx   end
      xx digit_string?
      xx end
   #+end_src
** digit-string->number
   #+begin_src fasm :tangle cicada-nymph.fasm
   sum$digit_string_to_number:
      xx 0

   counter$digit_string_to_number:
      xx 0

   define_function "digit-string->number", digit_string_to_number
      ;; << string[address, length] -- integer >>
      xx zero, literal, sum$digit_string_to_number, save
      xx zero, literal, counter$digit_string_to_number, save

      xx dup2, string_reverse!
      xx   help__digit_string_to_number
      xx string_reverse!, drop2

      xx literal, sum$digit_string_to_number
      xx fetch
      xx end

   define_function "help,digit-string->number", help__digit_string_to_number
      ;; << reversed-string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end

      xx dup2, string_head__char, digit_char_to_number
      xx   literal, 10
      xx   literal, counter$digit_string_to_number, fetch
      xx     one
      xx     literal, counter$digit_string_to_number
      xx     add_save
      xx   power
      xx multiple

      xx literal, sum$digit_string_to_number
      xx add_save

      xx string_tail__char
      xx taca, help__digit_string_to_number
   #+end_src
** string->integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->integer", string_to_integer
      ;; << string[address, length] -- integer >>
      xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
      xx   digit_string_to_number
      xx   end
      xx string_tail__char
      xx digit_string_to_number
      xx negate
      xx end
   #+end_src
** ----------------------------------
** string,find-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string,find-char", string__find_char
     ;; << string[address, length], char
     ;;    -- address, true
     ;;    -- false >>
     xx over, zero?, false?branch, 5
     xx   drop, drop2
     xx   false
     xx   end
     xx xoverxx, fetch_byte
     xx over, equal?, false?branch, 4
     xx   drop2
     xx   true
     xx   end
     xx xxswapx
     xx string_tail__char
     xx xswapxx
     xx taca, string__find_char
   #+end_src
** test
   #+begin_src cicada-nymph
   : XIE Yuheng ;
   32 string,find-char . << 1 >>
   fetch-byte . << 32 >>
   #+end_src
** ----------------------------------
* write number
** write-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; 2 ^ 64 = 18446744073709551616
   ;; which is of length 20
   ;; so
   ;; I use 32 to align to 16

   buffer$write_number labeling
      preserve 32

   counter$write_number:
      xx 0

   define_function "write-number", write_number
      ;; << number -- >>
      xx write_number__fill_buffer
      xx write_string
      xx end

   define_function "write-number,fill-buffer", write_number__fill_buffer
      ;; << number -- string[address, length] >>
      xx zero
      xx literal, counter$write_number, save

      xx write_number__loop

      xx literal, buffer$write_number
      xx literal, counter$write_number, fetch
      xx string_reverse!
      xx end


   define_function "write-number,loop", write_number__loop
      ;; << rest-number -- >>
      xx literal, 10, divmod

      xx number_to_digit_char
      xx literal, buffer$write_number
      xx literal, counter$write_number, fetch
      xx addition
      xx save_byte

      xx one
      xx literal, counter$write_number
      xx add_save

      xx dup, zero?, false?branch, 3
      xx   drop
      xx   end
      xx taca, write_number__loop
   #+end_src
** write-integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-integer", write_integer
      ;; << integer -- >>
      xx dup, negative?, false?, false?branch, 3
      xx   write_number
      xx   end
      xx literal, '-', write_byte
      xx negate
      xx write_number
      xx end
   #+end_src
** pretty_write_integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pretty-write-integer", pretty_write_integer
      ;; << integer -- >>
      xx write_integer
      xx literal, 32
      xx write_byte
      xx end

   define_function ".", ALIAS__pretty_write_integer
      ;; << integer -- >>
      xx pretty_write_integer
      xx end
   #+end_src
* note word
** io about word
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
** bar-ket
   * (read-word) is not implemented by (read-byte)
     instead it is implemented directly by side-effect on reading-stack
     [just like (read-byte)]
     thus
     we can implement bar-ket as word easily
     and nothing like un-read is needed
     and
     it is (string-head,word) and (string-tail,word)
     these two functions are maintaining the "bar-ket as word" feature
   * otherwise
     the implementation of (eval-string) will meet problems
* read-word->buffer & read-word & read-word-for-REPL
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_word_length = 512

   buffer$read_word labeling
      preserve max_word_length

   buffer$read_word_for_REPL labeling
      preserve max_word_length
   #+end_src
** read-word-begin-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-begin-char", read_word_begin_char
      ;; << -- non-blank-char >>
      xx read_byte
      xx dup, literal, 32 ;; ascii.space
      xx greater_than?, false?branch, 2
      xx   end
      xx drop
      xx taca, read_word_begin_char
   #+end_src
** read-word->buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word->buffer", read_word_to_buffer
      ;; << buffer -- word[address, length] >>
      xx pop_reading_stack
      xx dup2, space_string?, CICADA__not, false?branch, (.bad_tos-$)/jo_size
      xx   dup2, string_tail__word, push_reading_stack
      xx   string_head__word
      xx   xoverxx, xxoverx
      xx   xswapxx
      xx   string_to_buffer!
      xx   swap, drop
      xx   end
   .bad_tos:
      xx reading_stack_empty?, false?branch, (.not_empty-$)/jo_size
      xx   drop2
      xx   literal, buffer$reading
      xx   literal, max_input_length
      xx   read_line_from_stdin
      xx   dup, positive?, false?branch, (.read_error-$)/jo_size
      xx     literal, buffer$reading
      xx     swap
      xx     push_reading_stack
      xx     taca, read_word_to_buffer
   .read_error:
      ;;   ignore <end-of-file>
      ;;   ignore reading error
      xx   drop
      xx   literal, buffer$reading
      xx   literal, 0
      xx   push_reading_stack
      xx   taca, read_word_to_buffer
   .not_empty:
      xx   literal, error$read_word_to_buffer
      xx   literal, length$read_word_to_buffer
      xx   write_string
      xx   literal, replace$reading
      xx   literal, 1024
      xx   read_line_from_stdin
      xx   literal, replace$reading
      xx   swap
      xx   push_reading_stack
      xx   taca, read_word_to_buffer

   error$read_word_to_buffer:
      db "* (read-word->buffer) meets empty-string in reading-stack", 10
      db "  and this empty-stack is not at the bottom of the reading-stack", 10
      db "  you can type a line to replace this empty string", 10
   .end:
   length$read_word_to_buffer = (.end - error$read_word_to_buffer)
   #+end_src
** read-word
   * read-word will override the word readed before
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word", read_word
      ;; << -- word[address of buffer$read_word, length] >>
      xx literal, buffer$read_word, read_word_to_buffer
      xx end
   #+end_src
** read-word-for-REPL
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-for-REPL", read_word_for_REPL
      ;; << -- word[address of buffer$read_word_for_REPL, length] >>
      xx literal, buffer$read_word_for_REPL, read_word_to_buffer
      xx end
   #+end_src
* string-[head|tail],word
** note
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
** space-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-string?", space_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2, string_head__char, space_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, space_string?
      xx drop2, false
      xx end
   #+end_src
** string->word-[begin|end]
   * the error is not handled
     so
     before calling (string->word-begin)
     one should make sure that
     the argument is not a space-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->word-begin", string_to_word_begin
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, string_to_word_begin

   define_function "string->word-end", string_to_word_end
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 3
      xx   string_tail__char
      xx   end
      xx help__string_to_word_end
      xx end

   define_function "help,string->word-end", help__string_to_word_end
      ;; << string[address, length] -- address >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?branch, 2
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, help__string_to_word_end
   #+end_src
** string-[head|tail],word
   * note that
     the following functions do not create new strings
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,word", string_head__word
      ;; << string[address, length] -- word[address, length] >>
      xx string_to_word_begin
      xx dup2, string_to_word_end
      xx swap, drop
      xx subtraction
      xx end

   define_function "string-tail,word", string_tail__word
      ;; << string[address, length] -- string[address, length] >>
      xx string_to_word_begin
      xx string_to_word_end
      xx end
   #+end_src
* jotionary
** note
   * the jotionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into jotionary
     by creating new structured data into memory
** note about find
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
** 記 遍歷鏈表的方式
   * 循環進行的方式是
     1. 保證循環開始時 所得到的 jo 不是最後一個
     2. 處理這個 jo
     3. 看看這個 jo 是否是最後一個
        * 如果是
          退出
        * 如果不是
          取下一個 jo 以循環
** find-jo,through-jo-link
   * find jo in jotionary by word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*first-jo-in-jotionary*", V__first_jo_in_jotionary
      xx (last_link + jo_size)

   define_function "find-jo,through-jo-link", find_jo__through_jo_link
      ;; << word[address, length]
      ;;    -- jo, true
      ;;    -- false >>
      xx V__first_jo_in_jotionary
      xx find_jo__through_jo_link__loop
      xx end

   define_function "find-jo,through-jo-link,loop", find_jo__through_jo_link__loop
      ;; << word[address, length], jo
      ;;    -- jo, true
      ;;    -- false >>
      xx xxtuckx

      xx jo_to_name, xxoverxx

      ;; for debug
      ;; xx jo_to_name
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte
      ;; xx xxoverxx
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte

      xx string_equal?, false?branch, 4
      xx   drop2, true
      xx   end
      xx xswapxx
      xx dup, last_jo__jotionary?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx jo_to_pre_jo
      xx taca, find_jo__through_jo_link__loop
   #+end_src
** execute-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "execute-word", execute_word
      ;; << word[address, length] -- unknown >>
      xx dup2, integer_string?, false?branch, 3
      xx   string_to_integer
      xx   end
      ;; maybe more

      xx dup2 ;; for to report undefined word

      xx find_jo__through_jo_link, false?branch, 5
      xx   xxswapx, drop2
      xx   execute_jo
      xx   end

      xx write_undefined_word_report__for_execute_word
      xx write_string
      xx literal, 10
      xx write_byte
      xx end


   define_function "write-undefined-word-report,for-execute-word", write_undefined_word_report__for_execute_word
      ;; << -- >>
      xx literal, string$undefined_word_report__for_execute_word
      xx literal, length$undefined_word_report__for_execute_word
      xx write_string
      xx end

   string$undefined_word_report__for_execute_word:
      db "* (execute-word) meets undefined word : "
   .end:
   length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)
   #+end_src
* basic-REPL
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "basic-REPL", basic_REPL
     ;; << unknown -- unknown >>
     xx read_word_for_REPL
     xx execute_word
     xx taca, basic_REPL
  #+end_src
* -----------------------------------
* colon semicolon
** note
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first
     #+begin_src
     define-function factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial mul
       end
     end
     #+end_src
   * second
     #+begin_src cicada-nymph
     : factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial mul
       end
     ; define-function
     #+end_src
** [colon|semicolon]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "colon-string?", colon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ':'
      xx char_string?
      xx end

   define_function "semicolon-string?", semicolon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ';'
      xx char_string?
      xx end
   #+end_src
** comment-[begin|end]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$comment_begin:
      db "<<"

   define_function "comment-begin-string?", comment_begin_string?
      ;; << string[address, length] -- bool >>
      xx literal, string$comment_begin
      xx literal, 2
      xx string_equal?
      xx end


   string$comment_end:
      db ">>"

   define_function "comment-end-string?", comment_end_string?
      ;; << -- >>
      xx literal, string$comment_end
      xx literal, 2
      xx string_equal?
      xx end
   #+end_src
** colon & semicolon
   * nested : ; is NOT allow
     and no error check for it
   * nested << >> must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in << >>
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     double-quote is special bar-ket
     but "<" & ">" are not viewed as bar-ket
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$colon labeling
      preserve 1024 * 1024

   cursor$colon:
      xx 0


   define_function ":", colon
      ;; << -- string[address of buffer$colon, length] >>
      xx literal, buffer$colon
      xx literal, cursor$colon, save
      xx help__loop__colon
      ;; address
      xx literal, buffer$colon
      ;; length
      xx literal, cursor$colon, fetch
      xx literal, buffer$colon
      xx subtraction
      xx end


   define_function "", help__loop__colon
      ;; << -- >>
      xx read_byte
      xx help__save_byte__colon
      xx help__meet_end__colon?, false?branch, 7
      xx   literal, 3 ;; for the string " ; "
      xx   literal, cursor$colon
      xx   sub_save
      xx   end
      xx help__meet_comment__colon?, false?branch, 9
      xx   literal, 4 ;; for the string " << "
      xx   literal, cursor$colon
      xx   sub_save
      xx   ignore_comment
      xx   taca, help__loop__colon
      xx taca, help__loop__colon


   define_function "", help__save_byte__colon
      ;; << byte -- >>
      xx literal, cursor$colon, fetch
      xx save_byte
      xx one
      xx literal, cursor$colon
      xx add_save
      xx end


   define_function "", help__meet_end__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, ';', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end

   define_function "", help__meet_comment__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 4, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end
   #+end_src
** ignore-comment
   * this function is for basic-REPL
     but it is reused by colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "<<", ignore_comment
      ;; << -- >>
      xx read_word_for_REPL
      xx dup2, comment_begin_string?, false?branch, 5
      xx   drop2
      xx     ignore_comment ;; for the new nested-comment
      xx   taca, ignore_comment ;; for the rest-comment
      xx dup2, comment_end_string?, false?branch, 3
      xx   drop2
      xx   end
      xx drop2
      xx taca, ignore_comment
   #+end_src
** test
   #+begin_src cicada-nymph
   1 << 989 >> 64 add .
   << 65 >>

   : kkk << 989 << 989 >> >> ; .s
   << kkk >>
   #+end_src
* jo-area
** note
   * you can see how the naming convention is used
     for functions that create structured data into memory
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$jo_area = 1024 * 1024 * jo_size

   define_variable "*jo-area*", V__jo_area
     xx address$jo_area

   define_variable "*size,jo-area*", V__size__jo_area
     xx size$jo_area


   address$jo_area labeling
      preserve size$jo_area

   define_variable "*current-free-address,jo-area*", V__current_free_address__jo_area
      xx address$jo_area
   #+end_src
** save-into,primitive-string-area
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,primitive-string-area", save_into__primitive_string_area
      ;; << string[address, length] -- >>
      xx dup, V__current_free_address__primitive_string_area
      xx save_two_bytes

      xx literal, 2
      xx address, V__current_free_address__primitive_string_area
      xx add_save

      xx tuck
      xx V__current_free_address__primitive_string_area
      xx string_to_buffer!

      xx address, V__current_free_address__primitive_string_area
      xx add_save
      xx end
   #+end_src
** save-into,jo-area
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,jo-area", save_into__jo_area
      ;; << number -- >>
      xx V__current_free_address__jo_area
      xx save

      xx literal, jo_size
      xx address, V__current_free_address__jo_area
      xx add_save
      xx end
   #+end_src
* syntax-stack
** 記
   * 用 *syntax-stack* 來進行語境轉換
   * 用 *syntax-set,...* 來進行動態添加
** memory allocate
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve jo_size * 64
   address$syntax_stack labeling
      preserve jo_size * 1024

   define_variable "*pointer-syntax-stack*", V__pointer_syntax_stack
      xx address$syntax_stack
   #+end_src
** push-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "push-syntax-stack", push_syntax_stack
      ;; << syntax-set[address] -- >>
      xx V__pointer_syntax_stack
      xx save
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx add_save
      xx end
   #+end_src
** pop-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "pop-syntax-stack", pop_syntax_stack
      ;; << -- syntax-set[address] >>
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx sub_save
      xx V__pointer_syntax_stack, fetch
      xx end
   #+end_src
** tos-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "tos-syntax-stack", tos_syntax_stack
      ;; << -- syntax-set[address] >>
      xx V__pointer_syntax_stack
      xx V__jo_size
      xx subtraction
      xx fetch
      xx end
   #+end_src
** drop-syntax-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "drop-syntax-stack", drop_syntax_stack
      ;; << -- >>
      xx V__jo_size
      xx address, V__pointer_syntax_stack
      xx sub_save
      xx end
   #+end_src
** syntax-stack-empty?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax-stack-empty?", syntax_stack_empty?
      ;; << -- bool >>
      xx V__pointer_syntax_stack
      xx literal, address$syntax_stack
      xx equal?
      xx end
   #+end_src
** find-syntax
   * only search the first rule-set in syntax-stack
     thus a switch of syntax will get you a clean syntax
    #+begin_src fasm :tangle cicada-nymph.fasm
    define_function "find-syntax", find_syntax
       ;; << word[address, length]
       ;;    -- function, true
       ;;    -- false >>
       xx syntax_stack_empty?, false?branch, 4
       xx   drop2
       xx   false
       xx   end
       xx tos_syntax_stack
       xx find_rule
       xx end
   #+end_src
* rule-set
** 記 接口
   * 在 rule-set 中 一個 rule 的存在是
     | predicate |
     | function  |
   * 在棧中 一個 rule 的存在是
     << rule[predicate, function] >>
   * set is an ordered set
     its interface is as the following
     1. (add-rule)
        add a rule into rule-set
     2. (sub-rule)
        try to sub a rule from rule-set
        once a time
        if can not find the rule in the rule-set
        do nothing
     3. (find-rule)
        find a function from a word
     4. (list-rule)
** 記 使用
   * rule-set,make-jojo 是
     語法謂詞 還有 語法函數 這種對子
     所形成的有序集合
   * 這樣就可以形成簡單的語境概念了
     這種簡單的語境概念也很有趣
     但是
     它與我爲蟬語所構想的
     利用姓名來實現的語境機制是不同的
   * 每個語境都有責任
     在進入和退出時
     維護好 rule-set,make-jojo
   * 以 rule 爲前綴的 macro 的類型常常是
     1. 以 make-jojo 爲後綴時
        << string[address, length], word[address, length]
        -- string[address, length] >>
     2. 在 REPL 中使用時又可以是
        << word[address, length] -- integer >>
     所以在使用時
     一定要注意維護棧中的值的良好性
** note border
   * border is current-free-address of rule-set
** rule-set,fetch-border
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "rule-set,fetch-border", rule_set__fetch_border
      ;; << rule-set -- border >>
      xx V__jo_size, subtraction
      xx fetch
      xx end
   #+end_src
** rule-set,save-border
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "rule-set,save-border", rule_set__save_border
      ;; << border, rule-set -- >>
      xx V__jo_size, subtraction
      xx save
      xx end
   #+end_src
** cursor->[rule|function|predicate]
   * note that here needs two subtractions
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "cursor->rule", cursor_to_rule
      ;; << cursor -- rule[predicate, function] >>
      xx V__jo_size, subtraction
      xx V__jo_size, subtraction
      xx literal, 2
      xx n_fetch
      xx end

   define_function "cursor->predicate", cursor_to_predicate
      ;; << cursor -- predicate >>
      xx V__jo_size, subtraction
      xx V__jo_size, subtraction
      xx fetch
      xx end

   define_function "cursor->function", cursor_to_function
      ;; << cursor -- function >>
      xx V__jo_size, subtraction
      xx fetch
      xx end
   #+end_src
** add-rule
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "add-rule", add_rule
      ;; << rule[predicate, function], rule-set -- >>
      xx xxtuckx
      xx rule_set__fetch_border
      xx literal, 2
      xx n_save
      xx dup
      xx rule_set__fetch_border
      xx V__jo_size, addition
      xx V__jo_size, addition
      xx swap
      xx rule_set__save_border
      xx end
   #+end_src
** find-rule
   #+begin_src fasm :tangle cicada-nymph.fasm
   cursor$find_rule:
      xx 0

   define_function "find-rule", find_rule
      ;; << word[address, length], rule-set
      ;;    -- function, true
      ;;    -- false >>
      xx dup, rule_set__fetch_border
      xx literal, cursor$find_rule, save
      xx find_rule__loop
      xx end

   define_function "find-rule,loop", find_rule__loop
      ;; << word[address, length], rule-set
      ;;    -- function, true
      ;;    -- false >>
      xx literal, cursor$find_rule, fetch
      xx over, equal?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx xxoverx
      xx literal, cursor$find_rule, fetch
      xx cursor_to_predicate
      xx execute_jo, false?branch, (.not_found-$)/jo_size
      xx   drop, drop2
      xx   literal, cursor$find_rule, fetch
      xx   cursor_to_function
      xx   true
      xx   end
   .not_found:
      xx literal, cursor$find_rule, fetch
      xx V__jo_size, subtraction
      xx V__jo_size, subtraction
      xx literal, cursor$find_rule, save
      xx taca, find_rule__loop
   #+end_src
* rule-set,make-jojo
** ----------------------------------
** note
   * a syntax is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$rule_set__make_jojo = 1024 * jo_size

   cursor$rule_set__make_jojo:
      xx address$rule_set__make_jojo
   address$rule_set__make_jojo:
      times size$rule_set__make_jojo db 0
   #+end_src
** *rule-set,make-jojo*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*rule-set,make-jojo*", V__rule_set__make_jojo
      xx address$rule_set__make_jojo
   #+end_src
** init,rule-set,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "init,rule-set,make-jojo", init__rule_set__make_jojo
      ;; << -- >>
      xx literal, integer_string?
      xx literal, syntax__integer_string__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_address?
      xx literal, syntax__address__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_jo?
      xx literal, syntax__jo__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_branch?
      xx literal, syntax__branch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_false?branch?
      xx literal, syntax__false?branch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, word_is_double_quote?
      xx literal, syntax__double_quote__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, local_variable_save_string?
      xx literal, syntax__local_variable_save__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx literal, local_variable_fetch_string?
      xx literal, syntax__local_variable_fetch__make_jojo
      xx V__rule_set__make_jojo, add_rule

      xx end
   #+end_src
** ----------------------------------
** syntax,integer-string,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,integer-string,make-jojo", syntax__integer_string__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx literal, literal
      xx   save_into__jo_area
      xx string_to_integer
      xx   save_into__jo_area
      xx end
   #+end_src
** ----------------------------------
** word:address?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_address?:
      db "address"
   .end:
   length$word_is_address? = (.end - string$word_is_address?)

   define_function "word:address?", word_is_address?
      ;; << word[address, length] -- bool >>
      xx literal, string$word_is_address?
      xx literal, length$word_is_address?
      xx string_equal?
      xx end
   #+end_src
** syntax,address,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,address,make-jojo", syntax__address__make_jojo
      ;; << string[address, length], word:address --
      ;;    string[address, length] >>
      xx drop2

      xx literal, address
      xx save_into__jo_area

      xx dup2
      xx string_head__word
      xx find_jo__through_jo_link, false?branch, 4
      xx   save_into__jo_area
      xx   string_tail__word
      xx   end

      xx write_undefined_word_report__for_address
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-undefined-word-report,for-address", write_undefined_word_report__for_address
      ;; << -- >>
      xx literal, string$undefined_word_report__for_address
      xx literal, length$undefined_word_report__for_address
      xx write_string
      xx end

   string$undefined_word_report__for_address:
      db "* (make-jojo (address)) the word follows (address) is undefined : "
   .end:
   length$undefined_word_report__for_address = (.end - string$undefined_word_report__for_address)
   #+end_src
** ----------------------------------
** word:jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_jo?:
      db "jo"
   .end:
   length$word_is_jo? = (.end - string$word_is_jo?)

   define_function "word:jo?", word_is_jo?
      ;; << word[address, length] -- bool >>
      xx literal, string$word_is_jo?
      xx literal, length$word_is_jo?
      xx string_equal?
      xx end
   #+end_src
** syntax,jo,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,jo,make-jojo", syntax__jo__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, literal
      xx save_into__jo_area

      xx dup2
      xx string_head__word
      xx find_jo__through_jo_link, false?branch, 4
      xx   save_into__jo_area
      xx   string_tail__word
      xx   end

      xx write_undefined_word_report__for_jo
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-undefined-word-report,for-jo", write_undefined_word_report__for_jo
      ;; << -- >>
      xx literal, string$undefined_word_report__for_jo
      xx literal, length$undefined_word_report__for_jo
      xx write_string
      xx end

   string$undefined_word_report__for_jo:
      db "* (syntax,jo,make-jojo) the word follows (jo) is undefined : "
   .end:
   length$undefined_word_report__for_jo = (.end - string$undefined_word_report__for_jo)
   #+end_src
** ----------------------------------
** word:branch?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_branch?:
      db "branch"
   .end:
   length$word_is_branch? = (.end - string$word_is_branch?)

   define_function "word:branch?", word_is_branch?
      ;; << word[branch, length] -- bool >>
      xx literal, string$word_is_branch?
      xx literal, length$word_is_branch?
      xx string_equal?
      xx end
   #+end_src
** syntax,branch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,branch,make-jojo", syntax__branch__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, branch
      xx save_into__jo_area

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_area
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-branch", write_not_integer_string_report__for_branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_branch
      xx literal, length$not_integer_string_report__for_branch
      xx write_string
      xx end

   string$not_integer_string_report__for_branch:
      db "* (syntax,branch,make-jojo) the word follows (branch) must be a integer string : "
   .end:
   length$not_integer_string_report__for_branch = (.end - string$not_integer_string_report__for_branch)
   #+end_src
** ----------------------------------
** word:false?branch?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_false?branch?:
      db "false?branch"
   .end:
   length$word_is_false?branch? = (.end - string$word_is_false?branch?)

   define_function "word:false?branch?", word_is_false?branch?
      ;; << word[false?branch, length] -- bool >>
      xx literal, string$word_is_false?branch?
      xx literal, length$word_is_false?branch?
      xx string_equal?
      xx end
   #+end_src
** syntax,false?branch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,false?branch,make-jojo", syntax__false?branch__make_jojo
      ;; << string[address, length], word:jo --
      ;;    string[address, length] >>
      xx drop2

      xx literal, false?branch
      xx save_into__jo_area

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_area
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_false?branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-false?branch", write_not_integer_string_report__for_false?branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_false?branch
      xx literal, length$not_integer_string_report__for_false?branch
      xx write_string
      xx end

   string$not_integer_string_report__for_false?branch:
      db "* (syntax,false?branch,make-jojo) the word follows (false?branch) must be a integer string : "
   .end:
   length$not_integer_string_report__for_false?branch = (.end - string$not_integer_string_report__for_false?branch)
   #+end_src
** ----------------------------------
** word:double-quote?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$word_is_double_quote?:
      db '"'
   .end:
   length$word_is_double_quote? = (.end - string$word_is_double_quote?)

   define_function "word:double-quote?", word_is_double_quote?
      ;; << word[double-quote, length] -- bool >>
      xx literal, string$word_is_double_quote?
      xx literal, length$word_is_double_quote?
      xx string_equal?
      xx end
   #+end_src
** syntax,double-quote,make-jojo
   * primitive-string-area is used
     to allocate string literal in function body
   * in ASCII encode double-quote is 34
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,double-quote,make-jojo", syntax__double_quote__make_jojo
      ;; << string[address, length], word:double-quote --
      ;;    string[address, length] >>
      xx drop2

      xx dup2
      xx literal, '"', string__find_char
      xx false?branch, (.not_found-$)/jo_size
      xx   xoverxx, subtraction
      ;;   << string[address, length], length >>

      ;; address
      xx   literal, literal
      xx     save_into__jo_area
      xx   V__current_free_address__primitive_string_area, add2
      xx     save_into__jo_area
      xx   xoverxx, over
      xx     save_into__primitive_string_area

      ;; length
      xx   literal, literal
      xx     save_into__jo_area
      xx   dup
      xx     save_into__jo_area

      xx   tuck, subtraction
      xx   xxswapx
      xx   addition
      xx   swap

      xx   string_tail__char ;; over the ending double-quote
      xx   end

      .not_found:
      xx write_not_integer_string_report__for_double_quote
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-double-quote", write_not_integer_string_report__for_double_quote
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_double_quote
      xx literal, length$not_integer_string_report__for_double_quote
      xx write_string
      xx end

   string$not_integer_string_report__for_double_quote:
      db "* (syntax,double-quote,make-jojo) can not find the ending double-quote"
   .end:
   length$not_integer_string_report__for_double_quote = (.end - string$not_integer_string_report__for_double_quote)
   #+end_src
** ----------------------------------
* make-jojo
** note
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
** make-jojo,dispatch-syntax-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo,dispatch-syntax-word", make_jojo__dispatch_syntax_word
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2
      xx find_syntax, false?branch, 3
      xx   execute_jo
      xx   end
      xx dup2
      xx find_jo__through_jo_link, false?branch, 5
      xx   xxswapx, drop2 ;; drop word
      xx   save_into__jo_area
      xx   end
      xx write_undefined_word_report__for_make_jojo
      xx write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo

   define_function "write-undefined-word-report,for-make-jojo", write_undefined_word_report__for_make_jojo
      ;; << -- >>
      xx literal, string$undefined_word_report__for_make_jojo
      xx literal, length$undefined_word_report__for_make_jojo
      xx write_string
      xx end

   string$undefined_word_report__for_make_jojo:
      db "* (make-jojo) meets undefined word : "
   .end:
   length$undefined_word_report__for_make_jojo = (.end - string$undefined_word_report__for_make_jojo)
   #+end_src
** make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo", make_jojo
      ;; << string[address, length] -- >>
      xx local_variable_table__clear
      xx V__rule_set__make_jojo, push_syntax_stack
      xx make_jojo__loop
      xx drop_syntax_stack
      xx end

   define_function "make-jojo,loop", make_jojo__loop
      ;; << string[address, length] -- >>
      xx dup2, space_string?, false?branch, 3
      xx   drop2
      xx   end
      xx dup2
      xx string_tail__word
      xx xxswapxx
      xx string_head__word
      ;; << tail[address, length], head[address, length] >>
      xx make_jojo__dispatch_syntax_word
      xx taca, make_jojo__loop
   #+end_src
* define-[function|exception|variable]
** note
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
** !undo-make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_exception "!undo-make-jojo", !undo_make_jojo
      ;; << old V__current_free_address__primitive_string_area
      ;;    old V__current_free_address__jo_area
      ;;    old V__first_jo_in_jotionary
      ;;    string[address, length]
      ;;    -- >>
      xx drop_syntax_stack

      xx literal, string$undo_make_jojo_report
      xx literal, length$undo_make_jojo_report
      xx write_string

      xx write_string
      xx literal, 10, write_byte
      xx literal, ';', write_byte
      xx literal, 10, write_byte

      xx address, V__first_jo_in_jotionary, save
      xx address, V__current_free_address__jo_area, save
      xx address, V__current_free_address__primitive_string_area
      xx save
      xx end

   string$undo_make_jojo_report:
      db "  the following jojo is not made :"
      db 10
      db ": "
   .end:
   length$undo_make_jojo_report = (.end - string$undo_make_jojo_report)
   #+end_src
** define-function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-function", CICADA__define_function
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string_area, xxswapx
      xx V__current_free_address__jo_area, xxswapx
      xx V__first_jo_in_jotionary, xxswapx
      ;; << old V__current_free_address__primitive_string_area
      ;;    old V__current_free_address__jo_area
      ;;    old V__first_jo_in_jotionary
      ;;    string[address, length] >>

      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end

      xx V__current_free_address__primitive_string_area
      xx   save_into__jo_area
      xx dup2, string_head__word
      xx   save_into__primitive_string_area

      xx V__first_jo_in_jotionary
      xx jo_to_link
      xx   save_into__jo_area

      xx V__current_free_address__jo_area
      xx address, V__first_jo_in_jotionary
      xx save

      xx literal, explain$function
      xx   save_into__jo_area

      xx dup2
      xx string_tail__word
      xx make_jojo

      xx drop2
      xx drop
      xx drop
      xx drop
      xx end
   #+end_src
** define-exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-exception", CICADA__define_exception
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string_area, xxswapx
      xx V__current_free_address__jo_area, xxswapx
      xx V__first_jo_in_jotionary, xxswapx
      ;; << old V__current_free_address__primitive_string_area
      ;;    old V__current_free_address__jo_area
      ;;    old V__first_jo_in_jotionary
      ;;    string[address, length] >>

      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end

      xx V__current_free_address__primitive_string_area
      xx   save_into__jo_area
      xx dup2, string_head__word
      xx   save_into__primitive_string_area

      xx V__first_jo_in_jotionary
      xx jo_to_link
      xx   save_into__jo_area

      xx V__current_free_address__jo_area
      xx address, V__first_jo_in_jotionary
      xx save

      xx literal, explain$exception
      xx   save_into__jo_area

      xx dup2
      xx string_tail__word
      xx make_jojo

      xx drop2
      xx drop
      xx drop
      xx drop
      xx end
   #+end_src
** define-variable,with-tos
   * not undo is needed for define-variable,with-tos
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-variable,with-tos", CICADA__define_variable__with_tos
      ;; << variable, string[address, length] -- >>
      xx literal, 1
      xx   save_into__jo_area

      xx V__current_free_address__primitive_string_area
      xx   save_into__jo_area
      xx dup2, string_head__word
      xx   save_into__primitive_string_area

      xx V__first_jo_in_jotionary
      xx jo_to_link
      xx   save_into__jo_area

      xx V__current_free_address__jo_area
      xx address, V__first_jo_in_jotionary
      xx save

      xx literal, explain$variable
      xx   save_into__jo_area

      xx drop2
      xx save_into__jo_area
      xx end
   #+end_src
** test define-function
   #+begin_src cicada-nymph
   : addadd add add end ; define-function
   1 2 3 addadd . << 6 >>

   : add1 1 add end ; define-function
   1 add1 . << 2 >>

   : negate 0 swap sub end ; define-function
   1 negate . << -1 >>
   #+end_src
** test define-variable,with-tos
   #+begin_src cicada-nymph
   233 : *three* ; define-variable,with-tos
   : add-three *three* add end ; define-function
   1 add-three . << 234 >>

   << you get the address of the variable *three*
      by add "address" in front of it >>
   : fix-*three* 3 address *three* save end ; define-function
   fix-*three*
   1 add-three . << 4 >>
   #+end_src
* -----------------------------------
* 記 有名字的局部變量 與 變長的局部數據
  * local-jo
    用來實現 有名字的局部變量
    在編譯時計算 offset
    到這個 local-jo 中的 offset 做爲變量的值
    有 *local-variable-table* 這個數據結構
    幫助計算 offset
  * local-byte
    用來分配 變長的局部數據
    在運行時計算 offset
  * 兩個機制配合使用
* note *to compare readability*
** example code without local-variable
   #+begin_src cicada-nymph
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     xx|tuck|xx name-hash-table,hash
     xx|tuck|x
     << number, counter, name, string[address, length], name >>
     name,used? false? if
       x|over|xx name,save-string
         xx|tuck|x << name as return value >>
       << name, number, counter, name >>
       x|over|xx 0 name-hash-table,hash
       swap name,save-orbiton
       << name, number, counter >>
       swap 0 name-hash-table,hash
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       true
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xx name,fetch-string
     xx|over|xx string-equal? if
       drop2 xx|swap|x drop2
       true
       end
     then
     << number, counter, name, string[address, length] >>
     x|over|xxx *name-hash-table,size* equal? if
       drop2 xx|swap|x drop2
       false
       end
     then
     << number, counter, name, string[address, length] >>
     x|swap|xx drop
     xx|swap|xx add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** example code with local-variable
   #+begin_src cicada-nymph
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       ::string :name
       name,save-string
       :orbit :name
       name,save-orbiton
       :counter :orbit
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       :name true
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :counter *name-hash-table,size* equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
* 記 再增加局部變元支持之後 需要重寫的部分
** 詮釋者 與 收尾詞
   * 在進行時
     每次進入一個函數體的執行
     即 每次將一串珠珠入棧時
     同時在這串珠子底部加上
     current_free_address$local_jo
     即 在 explain$function 中需要做特殊處理
     注意
     explain$exception
     等等
     和 explain$function 並沒有區別
     只是名字不一樣而已
     所以也需要做特殊處理
   * 這個值在函數退出時
     [即 在 end 這個函數中]
     用以重置 current_free_address$local_jo
     也就是 釋放在這次函數作用過程中所分配的內存
   * 每次 >:name 的時候
     都更新 current_free_address$local_jo
     以分配內存就行了
   * 也就是說
     return-stack 中的大多數有效值
     都是以兩個值一對的方式存在的
   * 兩個結尾詞是 end 和 <>
     對於 <>
     即 對於明顯的尾遞歸調用
     需要利用棧中的值重置 current_free_address$local_jo
     但是並不入棧新值
** 語法擴展方面的支持
   * 這裏需要識別 >:name 還有 :name 等等
     並對它們做特殊處理
     這些東西應該藉助設計良好的語法擴展機制來實現
   * 我將使用一個 語法謂詞 的棧
     可以發現
     這樣的話
     我就能很容易地臨時改變語法了
** 注意
   * 需要重寫的部分還有 exception-handling
     這包括
     1. explain$exception
     2. prepare_for
     3. exception_head
* 記 總結
** interface
   * 首先要滿足最基本的
     長度爲 *jo-size* 的倍數的
     局部變量的需求
     其次
     還要能夠在所申請的局部空間裏使用字符串
     這兩種長度的數據結構需要共存
     使用 offset 就行了
   * 底層
     local-data-allocate,jo
     這個只讓 current_free_address$local_jo 前進
     而不後退
   * 注意
     最爲重要的特點是
     所有的對 局部數據堆 的使用
     都必須在編譯時期被靜態地算出來
     所以必須設計語法幫助編譯器作計算
     >:name :name 用以 分配 和 使用
     *jo-size* 倍數大小的內存
   * 語義方面
     >:name 的重複出現有兩種語義
     1. 更新這個局部變元的值
     2. 覆蓋上一個局部變元綁定
     我選擇第一種
     因爲這樣
     我就不必設計額外的語法來更新局部變元的值了
     比較簡潔
** 語義特點總結
   * 所有有名局部變元的名字與值的對應
     都由編譯器處理
   * 每個函數體就是一個非常線性的東西
     函數體中不能嵌套別的函數體
** 語用特點總結
   * 所有的函數都是全局的
     包括輔助函數
   * 所以設計輔助函數的時候
     應該格外小心
     儘量使得輔助函數能夠被重用
   * 改代碼並調整對輔助函數的使用
     就被稱作是 "re-factoring"
     即 函數的因子的重新分解
* local-jo
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_jo = 1024 * 1024 * jo_size

   address$local_jo labeling
      preserve size$local_jo

   current_free_address$local_jo:
      xx address$local_jo
   #+end_src
** 記 注意結尾詞會初始化局部變量指針
   * 下面的接口函數必須是 primitive-function
     因爲 否則 遇到 end 和 taca 的時候
     current_free_address$local_jo 就又被初始化了
** local_data_allocate__jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "local-data-allocate,jo", local_data_allocate__jo
      ;; << number -- >>
      pop_argument_stack rax
      imul rax, jo_size
      add [current_free_address$local_jo], rax
      next
   #+end_src
** note many fetch & save
   * in memory
     | 1 : value-1 |
     | 1 : value-2 |
     | 1 : value-3 |
   * on stack
     << value-1, value-2, value-3, ... >>
** n-fetch & n-save                   :64bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "n-fetch,local-jo", n_fetch__local_jo
      ;; << offset, n -- value-1, ..., value-n >>
      mov rbx, [pointer$return_stack - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
   .loop:
      mov rax, [rbx]
      push_argument_stack rax
      add rbx, jo_size
      loop .loop
      next

   define_primitive_function "n-save,local-jo", n_save__local_jo
      ;; << value-n, ..., value-1, offset, n -- >>
      mov rbx, [pointer$return_stack - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
        mov rax, jo_size
        imul rax, rcx
        add rbx, rax
        ;; for address is based on 0
        ;; but n is based on 1
        sub rbx, jo_size
   .loop:
      pop_argument_stack rax
      mov [rbx], rax
      sub rbx, jo_size
      loop .loop
      next

   }
   #+end_src
** n-fetch & n-save                   :32bit:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "n-fetch,local-jo", n_fetch__local_jo
      ;; << offset, n -- value-1, ..., value-n >>
      mov rax, [pointer$return_stack]
      mov rbx, [rax - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
   .loop:
      mov rax, [rbx]
      push_argument_stack rax
      add rbx, jo_size
      loop .loop
      next

   define_primitive_function "n-save,local-jo", n_save__local_jo
      ;; << value-n, ..., value-1, offset, n -- >>
      mov rax, [pointer$return_stack]
      mov rbx, [rax - (2 * jo_size)]

      pop_argument_stack rcx
      pop_argument_stack rdx
      add rbx, rdx
        mov rax, jo_size
        imul rax, rcx
        add rbx, rax
        ;; for address is based on 0
        ;; but n is based on 1
        sub rbx, jo_size
   .loop:
      pop_argument_stack rax
      mov [rbx], rax
      sub rbx, jo_size
      loop .loop
      next

   }
   #+end_src
** note example result
   * with >::name
     #+begin_src cicada-nymph
     : example
       << number1, number2, number3, number4
          -- number1, number2 >>
       >::var2
       >::var2
       ::var2
       end
     ; define-function
     #+end_src
     ----------------
     #+begin_src fasm
     define_function "example", example

        ;; >::var2
        xx literal, 2, local_data_allocate__jo
        xx literal, 0, literal, 2, n_save__local_jo

        ;; >::var2
        xx literal, 0, literal, 2, n_save__local_jo

        ;; ::var2
        xx literal, 0, literal, 2, n_fetch__local_jo

        xx end
     #+end_src
** test
   #+begin_src cicada-nymph
   : local-variable,test
     << number1, number2, number3 -- number1 + number2 >>
     >:var2
     >:var2
     >:var1
     :var1
     :var2
     add
     end
   ; define-function
   1 2 4 local-variable,test << 3 >> .


   : local-variable,test,2
     << number1, number2 -- number2 + number3 >>
     >::var2
     ::var2
     end
   ; define-function
   1 2 local-variable,test,2 << 1 2 >> . .


   : local-variable,test,3
     << number1, number2, number3 -- number2 + number3 >>
     >::var2
     >:var1
     ::var2
     add
     end
   ; define-function
   1 2 4 local-variable,test,3 << 6 >> .
   #+end_src
** test nested
   #+begin_src cicada-nymph
   : k1
     9 >:k
     :k .
     end
   ; define-function
   k1 << 9 >>

   : k2
     10 >:k
     k1
     :k .
     end
   ; define-function
   k2 << 9 10 >>
   #+end_src
* local-variable-table
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_variable_table = 100 * 1024

   address$local_variable_table labeling
      preserve size$local_variable_table
   #+end_src
** local-variable-table,clear
   #+begin_src fasm :tangle cicada-nymph.fasm
   border$local_variable_table:
      xx address$local_variable_table

   offset$local_variable_table:
      xx 0

   define_function "local-variable-table,clear", local_variable_table__clear
      ;; << -- >>
      xx literal, address$local_variable_table
      xx literal, border$local_variable_table, save
      xx literal, 0
      xx literal, offset$local_variable_table, save
      xx end
   #+end_src
** local-variable-table,insert
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-table,insert", local_variable_table__insert
      ;; << string[address, length] -- offset >>

      ;; leave offset
      xx literal, offset$local_variable_table, fetch
      xx   xxtuckx ;; return value
      xx literal, border$local_variable_table, fetch, save
      xx V__jo_size
      xx literal, border$local_variable_table, add_save

      ;; update offset$local_variable_table
      xx dup2
      xx   count_front_colon
      xx   V__jo_size, multiple
      xx   literal, offset$local_variable_table, add_save

      ;; leave length
      xx dup
      xx literal, border$local_variable_table, fetch, save
      xx V__jo_size
      xx literal, border$local_variable_table, add_save

      xx tuck ;; for to update border$local_variable_table

      ;; leave string
      xx literal, border$local_variable_table, fetch
      xx string_to_buffer!

      ;; update border$local_variable_table
      xx literal, border$local_variable_table, add_save

      xx end
   #+end_src
** local-variable-table,find
   #+begin_src fasm :tangle cicada-nymph.fasm
   cursor$local_variable_table:
      xx address$local_variable_table

   define_function "local-variable-table,find", local_variable_table__find
      ;; << string[address, length]
      ;;    -- offset, true
      ;;    -- false >>
      xx literal, address$local_variable_table
      xx literal, cursor$local_variable_table, save
      xx local_variable_table__find__loop
      xx end

   define_function "local-variable-table,find,loop", local_variable_table__find__loop
      ;; << string[address, length]
      ;;    -- offset, true
      ;;    -- false >>
      xx literal, cursor$local_variable_table, fetch
      xx literal, border$local_variable_table, fetch
      xx greater_or_equal?, false?branch, 4
      xx   drop2
      xx   false
      xx   end
      xx dup2
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   V__jo_size, addition ;; address of string
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   fetch ;; length of string
      xx string_equal?, false?branch, 8
      xx   drop2
      xx   literal, cursor$local_variable_table, fetch
      xx     fetch ;; offset
      xx   true
      xx   end
      xx literal, cursor$local_variable_table, fetch
      xx   V__jo_size, addition
      xx   fetch ;; length of string
      xx V__jo_size, addition
      xx V__jo_size, addition
      xx literal, cursor$local_variable_table, add_save
      xx taca, local_variable_table__find__loop
   #+end_src
** count-front-colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "count-front-colon", count_front_colon
      ;; << string[address, length] -- number >>
      xx literal, 0 ;; counter
      xx count_front_colon__loop
      xx end

   define_function "count-front-colon,loop", count_front_colon__loop
      ;; << string[address, length], counter -- number >>
      xx over, zero?, false?branch, 4
      xx   xxswapx, drop2
      xx   end
      xx xxoverx, string_head__char
      xx literal, ':', equal?, false?, false?branch, 4
      xx   xxswapx, drop2
      xx   end
      xx add1, xxswapx
      xx string_tail__char, xswapxx
      xx taca, count_front_colon__loop
   #+end_src
* two syntaxes
** ----------------------------------
** local-variable-fetch-string?
   * :name
     ::name
   * but not
     :name:
     ::name:
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-fetch-string?", local_variable_fetch_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, addition, sub1
      xx fetch_byte, literal, ':'
      xx equal?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, count_front_colon
      xx dup, literal, 0, greater_than?, false?, false?branch, 5
      xx   drop, drop2, false
      xx   end
      xx subtraction
      xx swap, drop
      xx literal, 0, greater_than?
      xx end
   #+end_src
** syntax,local-variable-fetch,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,local-variable-fetch,make-jojo", syntax__local_variable_fetch__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2
      xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
      ;;   literal, <offese>, literal, n, n_fetch__local_jo
      xx     literal, literal
      xx       save_into__jo_area
      ;;     offset
      xx       save_into__jo_area
      xx     literal, literal
      xx       save_into__jo_area
      ;;     n
      xx     count_front_colon
      xx       save_into__jo_area
      xx     literal, n_fetch__local_jo
      xx       save_into__jo_area
      xx   end
   .not_found:
      xx write_local_variable_not_bound_report
      xx write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo

   define_function "write-local-variable-not-bound-report", write_local_variable_not_bound_report
      xx literal, string$local_variable_not_bound_report
      xx literal, length$local_variable_not_bound_report
      xx write_string
      xx end

   string$local_variable_not_bound_report:
      db "* local-variable not bound : "
   .end:
   length$local_variable_not_bound_report = (.end - string$local_variable_not_bound_report)
   #+end_src
** ----------------------------------
** local-variable-save-string?
   * >:name
     >::name
   * but not
     >:name:
     >::name:
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "local-variable-save-string?", local_variable_save_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, addition, sub1
      xx fetch_byte, literal, ':'
      xx equal?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char
      xx literal, '>', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char
      xx dup2, count_front_colon
      xx dup, literal, 0, greater_than?, false?, false?branch, 5
      xx   drop, drop2, false
      xx   end
      xx subtraction
      xx swap, drop
      xx literal, 0, greater_than?
      xx end
   #+end_src
** syntax,local-variable-save,make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "syntax,local-variable-save,make-jojo", syntax__local_variable_save__make_jojo
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx string_tail__char
      xx dup2
      xx local_variable_table__find, false?branch, (.not_found-$)/jo_size
      ;;   literal, <offese>, literal, n, n_save__local_jo
      xx     literal, literal
      xx       save_into__jo_area
      ;;     offset
      xx       save_into__jo_area
      xx     literal, literal
      xx       save_into__jo_area
      ;;     n
      xx     count_front_colon
      xx       save_into__jo_area
      xx     literal, n_save__local_jo
      xx       save_into__jo_area
      xx   end
   .not_found:
      xx dup2
      xx local_variable_table__insert
      xx xxswapx
      xx count_front_colon
      ;; literal, <number>, local_data_allocate__jo
      xx   literal, literal
      xx     save_into__jo_area
      ;;   number of jo
      xx     dup, save_into__jo_area
      xx   literal, local_data_allocate__jo
      xx     save_into__jo_area
      ;; literal, <offese>, literal, n, save_local_data
      xx   literal, literal
      xx     save_into__jo_area
      ;;   offset
      xx   swap
      xx     save_into__jo_area
      xx   literal, literal
      xx     save_into__jo_area
      ;;   n
      xx     save_into__jo_area
      xx   literal, n_save__local_jo
      xx     save_into__jo_area
      xx end
   #+end_src
** ----------------------------------
* local-byte
** 記
   * 並不需要給這裏的接口設計特殊的語法擴展
     直接使用函數就可以了
   * 但是接口必須是 primitive-function
     因爲 否則 遇到 end 和 taca 的時候
     current_free_address$local_byte 就又被初始化了
** 記 使用
   * 在一個函數內
     用 allocate-local-memory 所申請的局部數據空間
     是可以被這個函數內所調用的函數所使用的
     但是當函數退出的時候
     其所申請的空間就被結尾珠 (end) 收回了
     而沒法重用了
     而用 (taca) 來實現循環的時候
     下一次函數的執行過程中
     所申請的 allocate-local-memory
     和上一次函數執行過程中
     所申請的 allocate-local-memory 是相同的
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$local_byte = 1024 * 1024 * jo_size

   address$local_byte labeling
      preserve size$local_byte

   current_free_address$local_byte:
      xx address$local_byte
   #+end_src
** allocate-local-memory
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "allocate-local-memory", allocate_local_memory
      ;; << size -- address >>
      pop_argument_stack rbx
      mov rax, [current_free_address$local_byte]
      push_argument_stack rax
      add [current_free_address$local_byte], rbx
      next
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,allocate-local-memory
     << -- address, address >>
     16 allocate-local-memory
     16 allocate-local-memory
     end
   ; define-function
   test,allocate-local-memory

   <<
   40218513
   40218529
   >>

   : test,allocate-local-memory,2
     << -- address, address >>
     16 allocate-local-memory
     test,allocate-local-memory
     16 allocate-local-memory
     test,allocate-local-memory
     16 allocate-local-memory
     end
   ; define-function
   test,allocate-local-memory,2

   <<
   40218513
     40218529
     40218545
   40218529
     40218545
     40218561
   40218545
   >>
   #+end_src
* -----------------------------------
* syscall
** note
   * there are two ways to treat the syscall
     1. syscall is NOT expose to cicada-nymph
        system functions are wraped in assembly code
        thus
        make cicada-nymph code be more clean
     2. syscall is expose to cicada-nymph
        system functions are wraped in cicada-nymph code
        thus
        more easy to wraped more system functions
        and
        make assembly code be more clean
        [only needs some system functions to load core file]
   * I choose the second way for now
** string->syscall-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$string_to_syscall_string:
      times 256 db 0

   define_function "string->syscall-string", string_to_syscall_string
      ;; << string[address, length] -- syscall-string[address] >>
      xx dup
      xx   literal, string$string_to_syscall_string
      xx   addition
      xx   literal, 0
      xx   swap, save_byte
      xx literal, string$string_to_syscall_string
      xx string_to_buffer!
      xx literal, string$string_to_syscall_string
      xx end
   #+end_src
** string->syscall-string-2
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$string_to_syscall_string_2:
      times 256 db 0

   define_function "string->syscall-string-2", string_to_syscall_string_2
      ;; << string[address, length] -- syscall-string[address] >>
      xx dup
      xx   literal, string$string_to_syscall_string_2
      xx   addition
      xx   literal, 0
      xx   swap, save_byte
      xx literal, string$string_to_syscall_string_2
      xx string_to_buffer!
      xx literal, string$string_to_syscall_string_2
      xx end
   #+end_src
** syscall                            :64bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =64bit, platform machine {

   define_primitive_function "syscall", CICADA__syscall
      ;; << ..., argument2, argument1,
      ;;    syscall-number,
      ;;    number-of-arguments
      ;;    -- return-value >>
      pop_argument_stack rax
      cmp rax, 0
      je __syscall_with_0
      cmp rax, 1
      je __syscall_with_1
      cmp rax, 2
      je __syscall_with_2
      cmp rax, 3
      je __syscall_with_3
      cmp rax, 4
      je __syscall_with_4
      cmp rax, 5
      je __syscall_with_5
      cmp rax, 6
      je __syscall_with_6
      jmp __syscall_with_too_many

   __syscall_with_0:
      pop_argument_stack linux64_sys_n_rax
      syscall
      push_argument_stack rax
      next

   __syscall_with_1:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      syscall
      push_argument_stack rax
      next

   __syscall_with_2:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      syscall
      push_argument_stack rax
      next

   __syscall_with_3:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      syscall
      push_argument_stack rax
      next

   __syscall_with_4:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      syscall
      push_argument_stack rax
      next

   __syscall_with_5:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      pop_argument_stack linux64_sys_5_r9
      syscall
      push_argument_stack rax
      next

   __syscall_with_6:
      pop_argument_stack linux64_sys_n_rax
      pop_argument_stack linux64_sys_1_rdi
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_4_r10
      pop_argument_stack linux64_sys_5_r9
      pop_argument_stack linux64_sys_6_r8
      syscall
      push_argument_stack rax
      next

   __syscall_with_too_many:
      call __exit_with_six

   }
   #+end_src
** syscall                            :32bit:linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =linux =32bit, platform machine {

   define_primitive_function "syscall", CICADA__syscall
      ;; << ..., argument2, argument1,
      ;;    syscall-number,
      ;;    number-of-arguments
      ;;    -- return-value >>
      pop_argument_stack rax
      cmp rax, 0
      je __syscall_with_0
      cmp rax, 1
      je __syscall_with_1
      cmp rax, 2
      je __syscall_with_2
      cmp rax, 3
      je __syscall_with_3
      cmp rax, 4
      je __syscall_with_4
      cmp rax, 5
      je __syscall_with_5
      jmp __syscall_with_too_many

   __syscall_with_0:
      pop_argument_stack linux32_sys_n_eax
      syscall
      push_argument_stack rax
      next

   __syscall_with_1:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      syscall
      push_argument_stack rax
      next

   __syscall_with_2:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      syscall
      push_argument_stack rax
      next

   __syscall_with_3:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      syscall
      push_argument_stack rax
      next

   __syscall_with_4:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_4_esi
      syscall
      push_argument_stack rax
      next

   __syscall_with_5:
      pop_argument_stack linux32_sys_n_eax
      pop_argument_stack linux32_sys_1_ebx
      pop_argument_stack linux32_sys_2_ecx
      pop_argument_stack linux32_sys_3_edx
      pop_argument_stack linux32_sys_4_esi
      pop_argument_stack linux32_sys_5_edi
      syscall
      push_argument_stack rax
      next

   __syscall_with_too_many:
      call __exit_with_six

   }
   #+end_src
* -----------------------------------
* epilog
** constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*explainer,function*", CICADA__explain$function
      xx explain$function

   define_variable "*explainer,exception*", CICADA__explain$exception
      xx explain$exception

   define_variable "*explainer,variable*", CICADA__explain$variable
      xx explain$variable
   #+end_src
** platform
   * this word is implemented as a function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "platform", the_platform
      xx literal, string$platform
      xx literal, length$platform
      xx end

   string$platform:

   match =linux, platform {
      db "linux"
   }

   .end:
   length$platform = (.end - string$platform)
   #+end_src
** *un-initialized-memory*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*un-initialized-memory*", V__un_initialized_memory
     xx address$un_initialized_memory

   define_variable "*size,un-initialized-memory*", V__size__un_initialized_memory
     xx size$un_initialized_memory

   define_variable "*current-free-address,un-initialized-memory*", V__current_free_address__un_initialized_memory
     xx current_free_address$un_initialized_memory
   #+end_src
** *current-free-address,primitive-string-area*
   * the last_primitive_string_in_assembly
     is just "*current-free-address,primitive-string-area*"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*current-free-address,primitive-string-area*", V__current_free_address__primitive_string_area
      xx current_free_address$primitive_string_area
   #+end_src
** last_link
   * this word helps to initialize V__first_jo_in_jotionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   last_link = link
   #+end_src
** un_initialized_memory              :linux:
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$un_initialized_memory = 88 * 1024 * 1024 ;; (byte)

   match =linux, platform {

   segment readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory

   }
   #+end_src
* ===================================
