#+TITLE:  小蟬語核 / core of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** 我有點不滿意 address 做爲給變元賦值的語法
   * 也許應該換一個詞
     因爲 address 這個詞 對於 variable-jo 而言 太一般了
   * 也許整個 全局 variable 的機制都應該改變
     比如允許 variable 中存儲 string
** what happens when executing (end) in REPL ? :question:
** only one error-code->string is not enough
** 分析局部變元的良好性               :question:
   * 對 包含 >:name 的函數體的純線性處理
     當遇到 if 所形成的分支的時候
     會不會有問題 ???
** about load-file
   * nested load-file
     a stack of allocate buffers in another local-byte
     the previous local-byte maybe should be called local-jo
   * load-file should maintain a list of loaded files
     what else meta data should be maintained ?
     can them make up a well module system ?
** 更好的錯誤處理機制
   1. 當一個 exception 找不到自己在 return-stack 中的退出點時
      應該有更好地處理方式 而不是不處理這種情況
   2. 目前
      當一個 exception 被執行的時候
      調用這個 exception 的函數是沒法傳遞參數給這個 exception 的
      [除非爲這個 exception 中設置全局變量]
      其原因在於
      當 exception 被執行的時候 參數棧已經被重置了
      所以其實解法很簡單
      只要提供一個函數給 exception
      讓每個 exception 用這個函數來以明顯的方式重置參數棧就行了
      這樣當一個 exception 被執行的時候
      它可以
      1. 先以未被重置時的參數棧中的值爲參數
         這些參數可以是調用這個 exception 的函傳遞給 exception 的
      2. 之後再以重置之後的參數棧中的值爲參數
         這些參數是等待 exception 的函爲 exception 所準備的
** little-tester                      :needed:
** home-path & search-path to load files
   * poi denotes path-organizer
   * 實現 條件性的被解釋的代碼
     這樣就能實現
     1. little-tester
     2. 在不同的平臺下執行不同的代碼
** debug-REPL
** [really needed] error handling for io function
   * write-file 可能遇到磁盤滿載的情況
** fixnum in other base
** more design about the command-line-interface
** re-design the color of cicada-nymph-mode and re-write the emacs-lisp code
** [how] variable must be able to store string
** name-hash-table
   * better factoring
   * better naming
** title-name-table
** data-giver
** big number and 同餘方程
   * 爲了玩 hash-table
* ===================================
* note
** notation
   * use ","
** data section in cicada-nymph
* ===================================
* writers
** note name of writers
   * the use of "." as prefix
     is inherited from Forth
   * table
     | .  | pretty_write_integer | assembly |
     | .i | write_integer        | core     |
     | .s | write_string         | assembly |
     | .l | linefeed             | core     |
** .l .i
   #+begin_src cicada-nymph :tangle core.cn
   : .l
     << -- >>
     10 write-byte
     end
   ; define-function

   : .i
     << -- >>
     write-integer
     end
   ; define-function
   #+end_src
* *rule-set,make-jojo* : if & else & then
** 記 條件轉跳
   * one predicate can make two branchs
     three predicates can make four branchs
     three predicates may only make three branchs
     but indeed there must be an invisible branch
** word:[if|else|then]?
   #+begin_src cicada-nymph :tangle core.cn
   : word:if?
     << word[address, length] -- bool >>
     "if" string-equal?
     end
   ; define-function

   : word:else?
     << word[address, length] -- bool >>
     "else" string-equal?
     end
   ; define-function

   : word:then?
     << word[address, length] -- bool >>
     "then" string-equal?
     end
   ; define-function
   #+end_src
** syntax,[if|else|then],make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,make-jojo
     << string[address, length], word:if --
        address, string[address, length] >>
     drop2
     *false?branch* save-into,jo-area
     *current-free-address,jo-area* xx|swap|x
     0 save-into,jo-area
     end
   ; define-function

   : syntax,else,make-jojo
     << address, string[address, length], word:else --
        address, string[address, length] >>
     drop2
     *branch* save-into,jo-area
     x|swap|xx
     *current-free-address,jo-area* xxx|swap|x
     0 save-into,jo-area
     << address, string[address, length], address >>
     *current-free-address,jo-area*
     over sub *jo-size* div
     swap save
     end
   ; define-function

   : syntax,then,make-jojo
     << address, string[address, length], word:then --
        string[address, length] >>
     drop2
     x|swap|xx
     *current-free-address,jo-area*
     over sub *jo-size* div
     swap save
     end
   ; define-function
   #+end_src
** test if & else & then
   #+begin_src cicada-nymph
   : kkk
     "kkk took my baby away !" .s
     .l
     end
   ; define-function

   kkk

   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 factorial
     mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function

   : .12
     << 1 2 -- >>
     2 equal? if
       "(^-^)" .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     else
       "     " .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     then
     end
   ; define-function

   : .12,test
     .l
     1 2 .12 .l
     6 2 .12 .l
     1 6 .12 .l
     6 6 .12 .l
     end
   ; define-function


   factorial,test
   .12,test
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
     jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
     jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
* *rule-set,make-jojo* : prepare-for
** 記 異常處理
   * 在語言中設計良好的異常處理
     是鼓勵程序員寫出皮實的程序的關鍵
   * 目前的
     利用 prepare-for 來實現的異常處理機制
     可能還遠遠不夠良好
** word:prepare-for?
   #+begin_src cicada-nymph :tangle core.cn
   : word:prepare-for?
     << word[address, length] -- bool >>
     "prepare-for" string-equal?
     end
   ; define-function
   #+end_src
** syntax,prepare-for,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,prepare-for,make-jojo
     << string[address, length], word:prepare-for --
        string[address, length] >>
     drop2
     *prepare-for*    save-into,jo-area
     *exception-head* save-into,jo-area
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:prepare-for?
     jo syntax,prepare-for,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
* number with base
** 記 原理
   * 現在 的 number 就只是 "integer" 而已
     更多的跟數學有關的東西將在 cicada 中設計新的語法來實現
   * 在 "integer" 這個函數中 我將只支持 對四種進位制的 字符串的 閱讀
     * 十進制
       10#1231
       10#-1231
       1231
       -1231
     * 二進制
       2#101001
       2#-101001
       2#-1011_1001
       "-" 和 "_" 的同時存在有點難讀
       此時可以用 2#1011_1001 negate
       也就是說雖然允許用 "-" 來表示負數
       但是不鼓勵這樣做
       之所以允許這樣做
       是因爲在打印負數的時候需要這種表示方式
       不能把 "-123" 打印成 "123 negate"
     * 八進制
       8#712537
       8#-712537
     * 十六進制
       16#f123acb3
       16#-F123ACB3
       大寫小寫字母都可以
   * one can use "_" to separate the number
     to make it more readable
     for example
     2#1111_0101_0001
   * actually, the base can be any 10 based number
     even greater then 36
     but when the base is greater then 36
     not all integer can be represented under this base
     for we only have 36 chars
** remove-char!
   #+begin_src cicada-nymph :tangle core.cn
   : remove-char!,loop
     << cursor, length, char -- cursor >>
     >:char
     >:length
     >:cursor
     :length zero? if
       :cursor
       end
     then
     :cursor fetch-byte :char equal? if
       :cursor add1 :length sub1
       :cursor
       string->buffer!
       :cursor
       :length sub1
       :char
     else
       :cursor add1
       :length sub1
       :char
     then
     <> remove-char!,loop
   ; define-function

   : remove-char!
     << string[address, length], char -- string[address, length] >>
     x|over|xx >:address
     remove-char!,loop >:cursor
     :address
     :cursor :address sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,remove-char!
     << -- >>
     "2#1001_1001"
     "_" string-head,char
     remove-char! .s << 2#1001_1001 >>
     .l
     "___2#1001___1001___"
     "_" string-head,char
     remove-char! .s << 2#1001_1001 >>
     .l
     end
   ; define-function
   test,remove-char!
   #+end_src
** latin-char?
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char?
     << char -- bool >>
     dup "A" string-head,char less-than? false?branch 4
       drop false
       end
     dup "Z" string-head,char less-or-equal? false?branch 4
       drop true
       end
     dup "a" string-head,char less-than? false?branch 4
       drop false
       end
     dup "z" string-head,char less-or-equal? false?branch 4
       drop true
       end
     drop false
     end
   ; define-function
   #+end_src
** latin-char->number
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char->number
     << latin-char -- number >>
     dup "A" string-head,char less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'A' : " .s
       .i .l
       end
     then
     dup "Z" string-head,char less-or-equal? if
       "A" string-head,char
       sub
       10 add
       end
     then
     dup "a" string-head,char less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'a' but greater-then 'Z' : " .s
       .i .l
       end
     then
     dup "z" string-head,char less-or-equal? if
       "a" string-head,char
       sub
       10 add
       end
     then
     "* (latin-char->number) the argument must be a latin-char" .s .l
     "  but the following char is greater-then 'z' : " .s
     .i .l
     end
   ; define-function
   #+end_src
** number->latin-char
   #+begin_src cicada-nymph :tangle core.cn
   : number->latin-char
     << number -- latin-char >>
     10 sub
     "a" string-head,char
     add
     end
   ; define-function
   #+end_src
** wild-digit-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-digit-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 true
       end
     then
     over fetch-byte
     dup digit-char?
     swap latin-char?
     or if
       string-tail,char
       <> wild-digit-string?
     then
     drop2
     false
     end
   ; define-function
   #+end_src
** wild-integer-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 false
       end
     then
     dup2 string-head,char
     "-" string-head,char
     equal? if
       string-tail,char
       wild-digit-string?
       end
     then
     wild-digit-string?
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,wild-integer-string?
     << -- >>
     "" wild-integer-string? . << 1 >>
     .l
     " " wild-integer-string? . << 0 >>
     "_asd" wild-integer-string? . << 0 >>
     " asd" wild-integer-string? . << 0 >>
     .l
     "asd" wild-integer-string? . << 1 >>
     "123" wild-integer-string? . << 1 >>
     "123asd" wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,wild-integer-string?
   #+end_src
** empty-string?
   #+begin_src cicada-nymph :tangle core.cn
   : empty-string?
     << string[address, length] -- bool >>
     swap drop
     zero?
     end
   ; define-function
   #+end_src
** base#wild-integer-string?
   * a string for the following format
     is viewed as a base#digit-string
     <digit-string>#[-]<wild-integer-string-string>
     any "_" in the anywhere of the above string
     will be ignored
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string?
     << string[address, length] -- bool >>
     128 allocate-local-memory
     >:string-address
     tuck
     :string-address
     string->buffer!
     :string-address swap
     "_" string-head,char
     remove-char!
     >:new-string-length
     >:new-string-address
     << dup2 .s .l 0 end >>
     :new-string-address
     :new-string-length
     "#" string-head,char
     string,find-char if
     else
       false
       end
     then
     >:address-of-#
     :new-string-address
     :address-of-# :new-string-address sub
     >::base-string
     :address-of-# add1
     :address-of-# :new-string-address sub add1
     :new-string-length swap sub
     >::wild-integer-string
     ::base-string digit-string?
     ::base-string empty-string? not
     and if
     else
       false
       end
     then
     ::wild-integer-string wild-integer-string?
     ::wild-integer-string empty-string? not
     and if
       true
     else
       false
     then
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string?
     << -- >>
     "#" base#wild-integer-string? . << 0 >>
     "##" base#wild-integer-string? . << 0 >>
     "#___#" base#wild-integer-string? . << 0 >>
     "   " base#wild-integer-string? . << 0 >>
     "______#__1______" base#wild-integer-string? . << 0 >>
     "___2___#__1___c29bf210019___漢字" base#wild-integer-string? . << 0 >>
     .l
     "1#1" base#wild-integer-string? . << 1 >>
     "123#1c29bf219g42" base#wild-integer-string? . << 1 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string?
   #+end_src
** base#wild-integer-string->base-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->base-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,char
     string,find-char if
     else
       "* (base#wild-integer-string->base-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address
     :address-of-# :address sub
     end
   ; define-function
   #+end_src
** base#wild-integer-string->wild-integer-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->wild-integer-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,char
     string,find-char if
     else
       "* (base#wild-integer-string->wild-integer-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address-of-# add1
     :address-of-# :address sub add1
     :length swap sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->base-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->base-string
     .l
     "1#1" base#wild-integer-string->base-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->base-string .s .l << 123 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->base-string .s .l << ___2___ >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->base-string

   : test,base#wild-integer-string->wild-integer-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->wild-integer-string
     .l
     "1#1" base#wild-integer-string->wild-integer-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->wild-integer-string .s .l << 1c29bf219g42 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->wild-integer-string .s .l << __1___c29bf210019___g42 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->wild-integer-string
   #+end_src
** wild-integer-string->integer,with-base
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string->integer,with-base,loop
     << string[address, length], base, sum, counter -- integer >>
     >:counter
     >:sum
     >:base
     >:length
     >:address
     :length zero? if
       :sum
       end
     then
     :address fetch-byte >:char
     :char digit-char? if
       :char digit-char->number
     then
     :char latin-char? if
       :char latin-char->number
     then
     :base :counter power
     mul
     :sum add
     >:sum
     :address add1
     :length sub1
     :base
     :sum
     :counter add1
     <> wild-integer-string->integer,with-base,loop
   ; define-function

   : wild-integer-string->integer,with-base
     << string[address, length], base -- integer >>
     >:base
     dup zero? if
       drop2
       0
       end
     then
     dup2 string-head,char
     "-" string-head,char
     equal? if
       string-tail,char
       -1 >:sign
     else
       1 >:sign
     then
     >::string
     ::string string-reverse!
     :base
     0 0 wild-integer-string->integer,with-base,loop
     :sign mul
     ::string string-reverse!
     drop2
     end
   ; define-function
   #+end_src
** base#wild-integer-string->integer
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->integer
     << string[address, length] -- integer >>
     128 allocate-local-memory
       >:address
     tuck :address string->buffer!
       >:length
     :address :length
     "_" string-head,char remove-char!
       >::string
     ::string
     base#wild-integer-string->base-string
       >::base-string
     ::string
     base#wild-integer-string->wild-integer-string
       >::wild-integer-string
     ::base-string
     digit-string->number
       >:base
     ::wild-integer-string
     :base
     wild-integer-string->integer,with-base
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->integer
     << -- >>
     "0#111" base#wild-integer-string->integer .
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add .
     .l
     "1#111" base#wild-integer-string->integer .
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add .
     .l
     "10#123" base#wild-integer-string->integer .
     "_1_0__#_1__2_3_" base#wild-integer-string->integer .
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add .
     .l
     "2#1000" base#wild-integer-string->integer .
     "2#_1000_" base#wild-integer-string->integer .
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add .
     .l
     "2#1111_1111" base#wild-integer-string->integer .
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add .
     "16#f_f" base#wild-integer-string->integer .
     16 0 power 15 mul
     16 1 power 15 mul add .
     .l
     "100#111" base#wild-integer-string->integer .
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add .
     .l
     "64#zzz" base#wild-integer-string->integer .
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add .
     .l
     "36#zzzz" base#wild-integer-string->integer .
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add .
     .l
     end
   ; define-function
   test,base#wild-integer-string->integer
   #+end_src
** note writers
   * a general function
     and three special ones
   * they all writer integer
   * I will implemented them by syntax when needed
** .#
   #+begin_src cicada-nymph :tangle core.cn
   : .#,loop
     << number, base, cursor -- cursor >>
     >:cursor
     >:base
     >:number
     :number zero? if
       :cursor
       end
     then
     :number
     :base
     divmod >:mod >:div
     :mod 10 less-than? if
       :mod number->digit-char
     else
       :mod number->latin-char
     then
     :cursor
     save-byte
     :div
     :base
     :cursor add1
     <> .#,loop
   ; define-function

   : .#
     << integer, base -- >>
     over zero? if
       drop .i
       end
     then
     dup 36 greater-than?
     over 2 less-than?
     or if
       "* (.#) the base " .s .i " is not valid to write a number" .s .l
       "  a base should in between 2 and 36 includingly" .s .l
       "  the integer to be written is " .s .i .l
       end
     then
     dup .i
     "#" .s
     over negative? if
       swap negate swap
       "-" .s
     then
     128 allocate-local-memory >:buffer
     :buffer
     .#,loop >:cursor
     :buffer
     :cursor :buffer sub
     string-reverse! .s
     end
   ; define-function
   #+end_src
** .#2 .#8 .#16
   #+begin_src cicada-nymph :tangle core.cn
   : .#2  2  .# " " .s end ; define-function
   : .#8  8  .# " " .s end ; define-function
   : .#16 16 .# " " .s end ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111        0  .#
   1#111        1  .#
   10#123       10 .#
   10#0         10 .#
   2#1000       2  .#
   2#1111_1111  2  .#
   16#f_f       16 .#
   36#zzzz      36 .#

   2#1111_1111  .#2
   8#123        .#8
   16#fff       .#16
   #+end_src
** 記 bit-xor
   * 對 bit-xor 的解釋
     1. 對稱地看
        diff
     2. 非對稱地看
        後者是 1 則 求 invert
     結構上 對於同樣的抽象函數
     認識上 可以有不同的理解方式
** 記 gamber
   * gray code 很有趣
     尤其是其生成方式
     即 先取對稱 再加前綴
     是利用 對稱性 和 不變量[不變性] 的典型例子
   * 同樣的一個 0 1 字符串
     比如 "100"
     把它做爲自然編碼的二進制數 其值爲 4 這個是 number
     把它做爲 gray code 編碼的二進制數 其值爲 7 這個我稱之爲 gamber
   * 這樣 我們就有如下兩個函數
     string->number
     string->gamber
     同時這兩個函數還引出了下面兩個函數
     number->gamber
     gamber->number
   * 下面的的算法是通過把數字列表之後
     逐 bit 觀察每列的接連 bit 值的規則而得來的
     比如
     以生成規則爲定義
     然後總結一下所發現的每一列的規律
     就可以得到對下面的算法的有效性的嚴格證明
   * 注意
     兩個方向的運算迥然不同
     還是要以生成方式爲核心來理解這一點
     只要把生成過程中
     每次在做完對稱後
     所添加的 一串前綴 1 看成是一個整體
     就能理解了
     可以把每次的 一串前綴 1 看成是一根棍子
     一根棍子 一根棍子 地 來觀察所生成的列表 就行了
     可以發現
     棍子 其實就是 自然編碼時
     逐 bit 觀察列表時的 接連 bit 值
     那麼就能理解到
     爲什麼 number->gamber 比 gamber->number 容易計算了
   * 另外還要注意
     從最高位向最低位去計算
     是爲了逐步確定數在序關係中的位置
** number->gamber
   #+begin_src cicada-nymph :tangle core.cn
   : number->gamber
     << number -- gamber >>
     dup 1 bit-right
     bit-xor
     end
   ; define-function
   #+end_src
** gamber->number
   #+begin_src cicada-nymph :tangle core.cn
   : gamber->number,loop
     << gamber, number, cursor -- number >>
     dup negative? if
       drop
       swap drop
       end
     then
     >:cursor
     >:number
     >:gamber
     :gamber :cursor get-bit
     :number :cursor add1 get-bit
     xor if
       :number :cursor set-bit >:number
     then
     :gamber
     :number
     :cursor sub1
     <> gamber->number,loop
   ; define-function

   : gamber->number
     << gamber -- number >>
     dup find-highest-set-bit
     dup negative? if
       drop
       end
     then
     0 over set-bit
     swap sub1
     gamber->number,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,gamber
     << -- >>
     2#0000 number->gamber .#2 .l
     2#0001 number->gamber .#2 .l
     2#0010 number->gamber .#2 .l
     2#0011 number->gamber .#2 .l
     2#0100 number->gamber .#2 .l
     2#0101 number->gamber .#2 .l
     2#0110 number->gamber .#2 .l
     2#0111 number->gamber .#2 .l
     2#1000 number->gamber .#2 .l
     2#1001 number->gamber .#2 .l
     2#1010 number->gamber .#2 .l
     2#1011 number->gamber .#2 .l
     2#1100 number->gamber .#2 .l
     2#1101 number->gamber .#2 .l
     2#1110 number->gamber .#2 .l
     2#1111 number->gamber .#2 .l
     .l
     2#0000 number->gamber gamber->number .#2 .l
     2#0001 number->gamber gamber->number .#2 .l
     2#0010 number->gamber gamber->number .#2 .l
     2#0011 number->gamber gamber->number .#2 .l
     2#0100 number->gamber gamber->number .#2 .l
     2#0101 number->gamber gamber->number .#2 .l
     2#0110 number->gamber gamber->number .#2 .l
     2#0111 number->gamber gamber->number .#2 .l
     2#1000 number->gamber gamber->number .#2 .l
     2#1001 number->gamber gamber->number .#2 .l
     2#1010 number->gamber gamber->number .#2 .l
     2#1011 number->gamber gamber->number .#2 .l
     2#1100 number->gamber gamber->number .#2 .l
     2#1101 number->gamber gamber->number .#2 .l
     2#1110 number->gamber gamber->number .#2 .l
     2#1111 number->gamber gamber->number .#2 .l
     .l
     end
   ; define-function
   test,gamber
   #+end_src
* *rule-set,make-jojo* : number with base
** syntax,base#wild-integer-string,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,base#wild-integer-string,make-jojo
     << string[address, length], word[address, length] --
        string[address, length] >>
     *literal* save-into,jo-area
     base#wild-integer-string->integer
     save-into,jo-area
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo base#wild-integer-string?
     jo syntax,base#wild-integer-string,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,syntax,base#wild-integer-string,make-jojo
     << -- >>
     0#111
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add
     . . .l

     1#111
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add
     . . .l

     10#123
     _1_0__#_1__2_3_
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add
     . . .l .

     2#1000
     2#_1000_
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add
     . . .l .

     2#1111_1111
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add
     . . .l

     16#f_f
     16 0 power 15 mul
     16 1 power 15 mul add
     . . .l

     100#111
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add
     . . .l

     64#zzz
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add
     . . .l

     36#zzzz
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add
     . . .l

     end
   ; define-function

   test,syntax,base#wild-integer-string,make-jojo
   #+end_src
* allocate
** note
   * an interface of *un-initialized-memory*
** clear-memory [not using]
   * this kinds of functions
     must be implemented in assembly code
   #+begin_src cicada-nymph
   : clear-memory
     << size, address -- >>
     over zero? if
       drop2
       end
     then
     0 over save
     add1 swap
     sub1 swap
     <> clear-memory
   ; define-function
   #+end_src
** allocate-memory
   #+begin_src cicada-nymph :tangle core.cn
   : allocate-memory
     << size -- address >>
     dup *current-free-address,un-initialized-memory* clear-memory
     *current-free-address,un-initialized-memory* swap << address as return value >>
     address *current-free-address,un-initialized-memory* add-save
     end
   ; define-function
   #+end_src
* basic-REPL                          :redefine:
** *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   1024 *jo-size* mul
   : *size,rule-set,basic-REPL*
   ; define-variable

   << for cursor >>
   *jo-size* allocate-memory drop

   *size,rule-set,basic-REPL*
   allocate-memory
   : *rule-set,basic-REPL*
   ; define-variable

   *rule-set,basic-REPL*
   *rule-set,basic-REPL* *jo-size* sub
   save
   #+end_src
** execute-word
   * to protect exception-jo from be called from basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : execute-word
     << word[address, length] -- unknown >>
     dup2
     find if
       dup exception-jo? if
         drop
         "* (execute-word) can not execute exception directly : " .s
         .s .l
         end
       then
       << function & primitive-function & variable >>
       xx|swap|x drop2
       execute-jo
       end
     else
     "* (execute-word) meets undefined word : " .s
     .s .l
     then
     end
   ; define-function
   #+end_src
** word:bye?
   #+begin_src cicada-nymph :tangle core.cn
   : word:bye?
     << word[address, length] -- bool >>
     "bye" string-equal?
     end
   ; define-function
   #+end_src
** !bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : !bye,basic-REPL
     << -- >>
     drop-syntax-stack
     end
   ; define-exception
   #+end_src
** syntax,bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,bye,basic-REPL
     << word:bye -- >>
     drop2
     !bye,basic-REPL
   ; define-function
   #+end_src
** word:jo?
   #+begin_src cicada-nymph :tangle core.cn
   : word:jo?
     << word[address, length] -- bool >>
     "jo" string-equal?
     end
   ; define-function
   #+end_src
** syntax,jo,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,jo,basic-REPL
     << word:jo -- >>
     drop2
     read-word-for-REPL
     >::word
     ::word find if
       end
     then
     "* (syntax,jo,basic-REPL) meet undefined word after jo : " .s ::word .s .l
     end
   ; define-function
   #+end_src
** init,rule-set,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : init,rule-set,basic-REPL
     << -- >>
     jo integer-string? jo string->integer       *rule-set,basic-REPL* add-rule
     jo word:bye?       jo syntax,bye,basic-REPL *rule-set,basic-REPL* add-rule
     jo word:jo?        jo syntax,jo,basic-REPL  *rule-set,basic-REPL* add-rule
     jo base#wild-integer-string? jo base#wild-integer-string->integer *rule-set,basic-REPL* add-rule
     end
   ; define-function

   init,rule-set,basic-REPL
   #+end_src
** basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : basic-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     <> basic-REPL,loop
   ; define-function

   : basic-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     basic-REPL,loop
     end
   ; define-function

   basic-REPL
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111
   0 0 power 1 mul
   0 1 power 1 mul add
   0 2 power 1 mul add
   . .

   1#111
   1 0 power 1 mul
   1 1 power 1 mul add
   1 2 power 1 mul add
   . .

   10#123
   _1_0__#_1__2_3_
   10 0 power 3 mul
   10 1 power 2 mul add
   10 2 power 1 mul add
   . . .

   2#1000
   2#_1000_
   2 0 power 0 mul
   2 1 power 0 mul add
   2 2 power 0 mul add
   2 3 power 1 mul add
   . . .

   2#1111_1111
   2 0 power 1 mul
   2 1 power 1 mul add
   2 2 power 1 mul add
   2 3 power 1 mul add
   2 4 power 1 mul add
   2 5 power 1 mul add
   2 6 power 1 mul add
   2 7 power 1 mul add
   . .

   16#f_f
   16 0 power 15 mul
   16 1 power 15 mul add
   . .

   100#111
   100 0 power 1 mul
   100 1 power 1 mul add
   100 2 power 1 mul add
   . .

   64#zzz
   64 0 power 35 mul
   64 1 power 35 mul add
   64 2 power 35 mul add
   . .

   36#zzzz
   36 0 power 35 mul
   36 1 power 35 mul add
   36 2 power 35 mul add
   36 3 power 35 mul add
   . .
   #+end_src
* *rule-set,basic-REPL* : if & else & then
** note ending jo
   * you do not need to use ending jo
     in code blocks formed by if else then
     because in a REPL
     things are different from function body
     and there is no such thing as
     the end of a function body in the REPL
** syntax,if,basic-REPL,meet-true
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL,meet-true,else
     << -- >>
     read-word-for-REPL
     "then" string-equal? if
       end
     then
     <> syntax,if,basic-REPL,meet-true,else
   ; define-function

   : syntax,if,basic-REPL,meet-true
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 "else" string-equal? if
       drop2
       syntax,if,basic-REPL,meet-true,else
       end
     then
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     <> syntax,if,basic-REPL,meet-true
   ; define-function
   #+end_src
** syntax,if,basic-REPL,meet-false
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL,meet-false,else
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     <> syntax,if,basic-REPL,meet-false,else
   ; define-function

   : syntax,if,basic-REPL,meet-false
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 "else" string-equal? if
       drop2
       syntax,if,basic-REPL,meet-false,else
       end
     then
     drop2
     <> syntax,if,basic-REPL,meet-false
   ; define-function
   #+end_src
** syntax,if,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL
     << bool, word:if -- >>
     drop2 if
       syntax,if,basic-REPL,meet-true
     else
       syntax,if,basic-REPL,meet-false
     then
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:if? jo syntax,if,basic-REPL *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   one? if
     111 . .l
   then

   one? if
     111 . .l
   else
     666 . .l
   then
   #+end_src
* *rule-set,basic-REPL* : double-quote
** *circular-string-area*
   * no length in the area anymore
     [not like the primitive-string-area]
   * and ending each string here with a 0
   #+begin_src cicada-nymph :tangle core.cn
   1024 1024 mul
   : *circular-string-area,size*
   ; define-variable


   *circular-string-area,size* allocate-memory
   : *circular-string-area*
   ; define-variable

   *circular-string-area*
   : *current-free-address,circular-string-area*
   ; define-variable
   #+end_src
** save-into,circular-string-area
   #+begin_src cicada-nymph :tangle core.cn
   : save-into,circular-string-area
     << string[address, length] -- >>
     dup *current-free-address,circular-string-area* add
     *circular-string-area,size* *circular-string-area* add
     greater-or-equal? if
       *circular-string-area*
       address *current-free-address,circular-string-area*
       save
     then
     tuck
     *current-free-address,circular-string-area*
     string->buffer!
     address *current-free-address,circular-string-area*
     add-save
     0 *current-free-address,circular-string-area*
     save-byte
     1 address *current-free-address,circular-string-area*
     add-save
     end
   ; define-function
   #+end_src
** syntax,double-quote,basic-REPL
   * in ASCII encode double-quote is 34
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,double-quote,basic-REPL,loop
     << cursor -- cursor >>
     read-byte
     dup 34 equal? if
       drop
       end
     then
     over save-byte
     add1
     <> syntax,double-quote,basic-REPL,loop
   ; define-function

   : syntax,double-quote,basic-REPL
     << word:double-quote -- string[address, length] >>
     drop2
     1024 2 mul allocate-local-memory >:buffer
     :buffer
     syntax,double-quote,basic-REPL,loop
     >:cursor
     *current-free-address,circular-string-area* >:address
     :buffer
     :cursor :buffer sub dup >:length
     save-into,circular-string-area
     :address
     :length
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:double-quote? jo syntax,double-quote,basic-REPL *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   one? if
     "111" .s .l
   then

   one? if
     "111" .s .l
   else
     "___" .s .l
   then
   #+end_src
* *rule-set,basic-REPL* : address
** syntax,address,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *syntax,address,basic-REPL,stack-balancer*
   ; define-variable

   : syntax,address,basic-REPL
     << word:address -- address >>
     drop2
     read-word-for-REPL
     >::word
     ::word find if
     else
       "* (syntax,address,basic-REPL) meet undefined word : " .s ::word .s .l
       address *syntax,address,basic-REPL,stack-balancer*
       end
     then
     >:jo
     :jo variable-jo? if
     else
       "* (syntax,address,basic-REPL) meet a not variable-jo : " .s ::word .s .l
       address *syntax,address,basic-REPL,stack-balancer*
       end
     then
     :jo *jo-size* add
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:address? jo syntax,address,basic-REPL *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   666
   address *syntax,address,basic-REPL,stack-balancer* save
   *syntax,address,basic-REPL,stack-balancer*

   address kkk
   #+end_src
* stack-REPL
** note
   * print argument-stack in every loop
** print-argument-stack
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,loop
     << address, counter -- >>
     dup zero? if
       drop2
       end
     then
     sub1 swap
       dup fetch .
     *jo-size* add
     swap
     <> print-argument-stack,loop
   ; define-function

   : print-argument-stack
     << -- >>
     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     *the-stack* greater-or-equal? if
       *the-stack*   << address as return value >>
       *the-stack-pointer-snapshot* *the-stack* sub
       *jo-size* div << counter as return value >>
       print-argument-stack,loop
       end
     then
     "below the stack " .s
     end
   ; define-function
   #+end_src
** print-argument-stack,pretty
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,pretty
     << -- >>
     snapshot-the-stack-pointer
     .l
     "  * " .s
        *the-stack-pointer-snapshot*
        *the-stack* sub
        << ad hoc for the BUG of div >>
        dup negative? if
          negate
          *jo-size* div
          negate
        else
          *jo-size* div
        then
        .i
     " * " .s
     " -- " .s
       print-argument-stack
     "--" .s
     .l
     end
   ; define-function
   #+end_src
** stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : stack-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     print-argument-stack,pretty
     <> stack-REPL,loop
   ; define-function

   : stack-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     stack-REPL,loop
     end
   ; define-function
   #+end_src
* -----------------------------------
* constant for linux                  :linux:
** init-syscall-number
   #+begin_src cicada-nymph :tangle core.cn
   *jo-size* 4 equal? if
     5   : :syscall-number,open:       ; define-variable
     6   : :syscall-number,close:      ; define-variable
     3   : :syscall-number,read:       ; define-variable
     4   : :syscall-number,write:      ; define-variable
     9   : :syscall-number,link:       ; define-variable
     10  : :syscall-number,unlink:     ; define-variable
     39  : :syscall-number,mkdir:      ; define-variable
     40  : :syscall-number,rmdir:      ; define-variable
     141 : :syscall-number,getdents:   ; define-variable
     220 : :syscall-number,getdents64: ; define-variable
     106 : :syscall-number,stat:       ; define-variable
     1   : :syscall-number,exit:       ; define-variable
     43  : :syscall-number,times:      ; define-variable
   then
   *jo-size* 8 equal? if
     2   : :syscall-number,open:       ; define-variable
     3   : :syscall-number,close:      ; define-variable
     0   : :syscall-number,read:       ; define-variable
     1   : :syscall-number,write:      ; define-variable
     86  : :syscall-number,link:       ; define-variable
     87  : :syscall-number,unlink:     ; define-variable
     83  : :syscall-number,mkdir:      ; define-variable
     84  : :syscall-number,rmdir:      ; define-variable
     78  : :syscall-number,getdents:   ; define-variable
     217 : :syscall-number,getdents64: ; define-variable
     4   : :syscall-number,stat:       ; define-variable
     60  : :syscall-number,exit:       ; define-variable
     100 : :syscall-number,times:      ; define-variable
   then
   #+end_src
** error-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : error-code->string
     << error-code -- string[address, length] >>
     dup -1  equal? if drop  << EPERM   >>   "Operation not permitted " end then
     dup -2  equal? if drop  << ENOENT  >>   "No such file or directory " end then
     dup -3  equal? if drop  << ESRCH   >>   "No such process " end then
     dup -4  equal? if drop  << EINTR   >>   "Interrupted system call " end then
     dup -5  equal? if drop  << EIO     >>   "I/O error " end then
     dup -6  equal? if drop  << ENXIO   >>   "No such device or address " end then
     dup -7  equal? if drop  << E2BIG   >>   "Argument list too long " end then
     dup -8  equal? if drop  << ENOEXEC >>   "Exec format error " end then
     dup -9  equal? if drop  << EBADF   >>   "Bad file number " end then
     dup -10 equal? if drop  << ECHILD  >>   "No child processes " end then
     dup -11 equal? if drop  << EAGAIN  >>   "Try again " end then
     dup -12 equal? if drop  << ENOMEM  >>   "Out of memory " end then
     dup -13 equal? if drop  << EACCES  >>   "Permission denied " end then
     dup -14 equal? if drop  << EFAULT  >>   "Bad address " end then
     dup -15 equal? if drop  << ENOTBLK >>   "Block device required " end then
     dup -16 equal? if drop  << EBUSY   >>   "Device or resource busy " end then
     dup -17 equal? if drop  << EEXIST  >>   "File exists " end then
     dup -18 equal? if drop  << EXDEV   >>   "Cross-device link " end then
     dup -19 equal? if drop  << ENODEV  >>   "No such device " end then
     dup -20 equal? if drop  << ENOTDIR >>   "Not a directory " end then
     dup -21 equal? if drop  << EISDIR  >>   "Is a directory " end then
     dup -22 equal? if drop  << EINVAL  >>   "Invalid argument " end then
     dup -23 equal? if drop  << ENFILE  >>   "File table overflow " end then
     dup -24 equal? if drop  << EMFILE  >>   "Too many open files " end then
     dup -25 equal? if drop  << ENOTTY  >>   "Not a typewriter " end then
     dup -26 equal? if drop  << ETXTBSY >>   "Text file busy " end then
     dup -27 equal? if drop  << EFBIG   >>   "File too large " end then
     dup -28 equal? if drop  << ENOSPC  >>   "No space left on device " end then
     dup -29 equal? if drop  << ESPIPE  >>   "Illegal seek " end then
     dup -30 equal? if drop  << EROFS   >>   "Read-only file system " end then
     dup -31 equal? if drop  << EMLINK  >>   "Too many links " end then
     dup -32 equal? if drop  << EPIPE   >>   "Broken pipe " end then
     dup -33 equal? if drop  << EDOM    >>   "Math argument out of domain of func " end then
     dup -34 equal? if drop  << ERANGE  >>   "Math result not representable " end then
     "unknow error-code : " .s .i .l
     "* (error-code->string) fail" << to balance the argument-stack >>
     end
   ; define-function
   #+end_src
** file-type-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : file-type-code->string
     << file-type-code -- string[address, length] >>
     dup 1  equal?  << DT_FIFO  >>  if drop "named pipe i.e. FIFO"  end then
     dup 2  equal?  << DT_CHR   >>  if drop "character device"      end then
     dup 4  equal?  << DT_DIR   >>  if drop "directory"             end then
     dup 6  equal?  << DT_BLK   >>  if drop "block device"          end then
     dup 8  equal?  << DT_REG   >>  if drop "regular file"          end then
     dup 10 equal?  << DT_LNK   >>  if drop "symbolic link"         end then
     dup 12 equal?  << DT_SOCK  >>  if drop "UNIX domain socket"    end then
     drop
     "unknow file type"
     end
   ; define-function
   #+end_src
* -----------------------------------
* jotionary
** jotionary,list-by-jo-predicate
   * 最後寫到珠典裏的 被最先打印出來
   #+begin_src cicada-nymph :tangle core.cn
   : jotionary,list-by-jo-predicate,loop
     << jo-predicate, counter, jo -- total >>
     dup zero? if
       drop
       swap drop
       end
     then
     dup x|over|xxx execute-jo false? if
       jo->pre-jo
       <> jotionary,list-by-jo-predicate,loop
     then
     swap
       "  " .s
       add1 dup .i ". " .s
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "  unnamed" .s .l
     else
       .s .l
     then
     jo->pre-jo
     <> jotionary,list-by-jo-predicate,loop
   ; define-function

   : jotionary,list-by-jo-predicate
     << jo-predicate -- total >>
     0 *first-jo-in-jotionary*
     jotionary,list-by-jo-predicate,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,jotionary,list-by-jo-predicate
     << -- >>
     jo primitive-function-jo? jotionary,list-by-jo-predicate
     end
   ; define-function
   test,jotionary,list-by-jo-predicate
   #+end_src
** jotionary,report
   * different types of words in jotionary
     are showed separately
   #+begin_src cicada-nymph :tangle core.cn
   : jotionary,report
     << -- >>
     "* all primitive-function in jotionary :" .s .l
     jo primitive-function-jo?
     jotionary,list-by-jo-predicate
     "* all function in jotionary :" .s .l
     jo function-jo?
     jotionary,list-by-jo-predicate add
     "* all exception in jotionary :" .s .l
     jo exception-jo?
     jotionary,list-by-jo-predicate add
     "* all variable in jotionary :" .s .l
     jo variable-jo?
     jotionary,list-by-jo-predicate add
     "* totally : " .s
     .i .l
     end
   ; define-function
   #+end_src
* rule-set
** rule-set,list
   * 最後寫到規則集合裏的 被最先打印出來
   * 下面的打印方式 看似有些不簡潔
     是因爲 我還沒有 integer->string 這樣的函數
     [因爲 沒有對字符串的動態內存管理]
   #+begin_src cicada-nymph :tangle core.cn
   : rule-set,list,loop
     << rule-set, cursor, counter -- >>
     xx|over|x equal? if
       drop drop2
       end
     then
     "  * " .s
     "(" .s
     add1 dup .i
     ")" .s .l
     swap
       dup cursor->predicate
       "    " .s jo->name .s .l
       dup cursor->function
       "    " .s jo->name .s .l
       *jo-size* sub *jo-size* sub
     swap
     <> rule-set,list,loop
   ; define-function

   : rule-set,list
     << rule-set -- >>
     dup rule-set,fetch-cursor
     0 rule-set,list,loop
     end
   ; define-function
   #+end_src
* report
** report-memory
   #+begin_src cicada-nymph :tangle core.cn
   : report-memory
     << -- >>
     "* *un-initialized-memory*" .s .l
     "  * size : " .s
          *size,un-initialized-memory*
          . .l
     "  * used : " .s
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub . .l
     "  * free : " .s
          *size,un-initialized-memory*
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub sub . .l
     "* *primitive-string-area*" .s .l
     "  * size : " .s
          *size,primitive-string-area*
          . .l
     "  * used : " .s
          *current-free-address,primitive-string-area*
          *primitive-string-area*
          sub . .l
     "  * free : " .s
          *size,primitive-string-area*
          *current-free-address,primitive-string-area*
          *primitive-string-area*
          sub sub . .l
     "* *jo-area*" .s .l
     "  * size : " .s
          *size,jo-area* . .l
     "  * used : " .s
          *current-free-address,jo-area*
          *jo-area*
          sub . .l
     "  * free : " .s
          *size,jo-area*
          *current-free-address,jo-area*
          *jo-area*
          sub sub . .l
     end
   ; define-function
   #+end_src
** report-platform
   #+begin_src cicada-nymph :tangle core.cn
   : report-platform
     << -- >>
     "* platform : " .s
     platform .s
     .l
     end
   ; define-function
   #+end_src
** report-jo-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-jo-size
     << -- >>
     "* jo-size : " .s
     *jo-size* write-number
     " bytes" .s
     .l
     end
   ; define-function
   #+end_src
** report-machine-word-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-machine-word-size
     << -- >>
     "* machine-word-size : " .s
     *jo-size* 8 mul write-number
     " bits" .s
     .l
     end
   ; define-function
   #+end_src
** report-syntax
   #+begin_src cicada-nymph :tangle core.cn
   : report-syntax
     << -- >>
     "* *rule-set,make-jojo* :" .s .l
      *rule-set,make-jojo* rule-set,list
     "* *rule-set,basic-REPL* :" .s .l
      *rule-set,basic-REPL* rule-set,list
     "* tos-syntax-stack :" .s .l
      tos-syntax-stack rule-set,list
     end
   ; define-function
   #+end_src
** report-loaded-core-file
   #+begin_src cicada-nymph :tangle core.cn
   : report-loaded-core-file
     << -- >>
     "* loaded-core-file : " .s
     get-path,loaded-core-file .s .l
     end
   ; define-function
   #+end_src
** initial-report
   #+begin_src cicada-nymph :tangle core.cn
   : initial-report
     << -- >>
     "* initial-report : " .s .l
     "  " .s report-loaded-core-file
     "  " .s report-platform
     "  " .s report-machine-word-size
     "  " .s report-jo-size
     end
   ; define-function
   #+end_src
* hi
** welcome
   #+begin_src cicada-nymph :tangle core.cn
   : welcome
     << -- >>
     "* welcome to cicada-nymph" .s .l
     end
   ; define-function
   #+end_src
** hi
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *hi,random-base*
   ; define-variable

   : hi,random
     << -- random-number >>
     0 :syscall-number,times:
     1 syscall
     9 mod
     <<
      *hi,random-base*
      *hi,random-base* add1 13 mod
      address *hi,random-base* save
     >>
     end
   ; define-function

   : hi,say
     << number -- >>
     dup 0 equal? if drop "  cica cica da yaya !!!" .s .l end then
     dup 1 equal? if drop "  hi ^-^" .s .l end then
     dup 2 equal? if drop "  hello :)" .s .l end then
     dup 3 equal? if drop "  hey *^-^*" .s .l end then
     dup 4 equal? if drop "  hiya \^o^/" .s .l end then
     dup 5 equal? if drop "  I wish you a lovely day" .s .l end then
     dup 6 equal? if drop "  I wish you a lovely day { or night :P }" .s .l end then
     dup 7 equal? if drop "  o.o" .s .l end then
                     drop "  lovely ^3^" .s .l end
   ; define-function

   : hi
     << -- >>
     hi,random
     hi,say
     end
   ; define-function
   #+end_src
** help
   #+begin_src cicada-nymph :tangle core.cn
   : help
     << -- >>
     "* helpful documentations will be written soon" .s .l
     "  please wait ^-^" .s .l
     end
   ; define-function
   #+end_src
* -----------------------------------
* port
** note linux header
   * 8 base number :
     O_ACCMODE          0003
     O_RDONLY             00
     O_WRONLY             01
     O_RDWR               02
     O_CREAT            0100  Not fcntl
     O_EXCL             0200  Not fcntl
     O_NOCTTY           0400  Not fcntl
     O_TRUNC           01000  Not fcntl
     O_APPEND          02000
     O_NONBLOCK        04000
     O_NDELAY     O_NONBLOCK
     O_SYNC         04010000
     O_FSYNC          O_SYNC
     O_ASYNC          020000
     O_LARGEFILE     0100000
     O_DIRECTORY     0200000
     O_NOFOLLOW      0400000
     O_CLOEXEC      02000000
     O_DIRECT         040000
     O_NOATIME      01000000
     O_PATH        010000000
     O_DSYNC          010000
     O_TMPFILE     020200000
** 記 關於輸入輸出
   * 接口設計分兩個層次
     1. 底層的以 port 爲基礎的接口
        這裏應該如何設計還不確定
        可能會模仿操作系統所提供的接口
     2. 高層的以 path 爲基礎的接口
        這裏將抽象掉 port 這個概念
        也就是每次簡單的讀寫都伴隨兩個對 port 的操作
        這樣接口就很簡單 但是速度可能會非常慢
** input-port,open                    :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : input-port,open
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     0
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** output-port,[creat|update]
   * interface
     |--------+-----------------------|
     | creat  | fail if already exist |
     | update | fail if nor exist     |
     |--------+-----------------------|
   * one should always know if a file exist or not
     when open it as output-port
     predicates are provided to help you to do so
   #+begin_src cicada-nymph :tangle core.cn
   : output-port,creat
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1102 <<
     O_RDWR   0002
     O_CREAT  0100
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function

   : output-port,update
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     110100100b
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** port,close                         :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : port,close
     << port
        -- true
        -- error-code, false >>
     :syscall-number,close:
     1 syscall
     dup
     negative? if
       false
       end
     then
     drop true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,output-port,creat
     << -- >>
     "kkk~" output-port,creat if
       port,close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,output-port,creat

   : test,output-port,update
     << -- >>
     "kkk~" output-port,update if
       port,close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,output-port,update
   #+end_src
** port,read                          :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : port,read
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** port,write
   #+begin_src cicada-nymph :tangle core.cn
   : port,write
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,port,read
     << -- >>
     64 allocate-local-memory
     dup
     "kkk~" input-port,open if
       64 swap port,read if
         .s .l
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,port,read
   #+end_src
* file-tree
** note interface
   * file-tree
     two types of nodes
     1. file
     2. directory
     a leaf must be a file
   * the following interface is provided
     * they use path as an argument
     * they print error message on error
       instead of return error info
       or rise exception
     * the concept of port is
       completely removed from the interface
     --------------------------------
     * file
       1. file,creat
       2. file,update
       3. file,remove
     * jotionary
       1. directory,creat
       2. directory,remove
       3. empty-directory?
     * list
       1. directory,list-file
       2. directory,list-directory
     * find
       1. directory,find-file
       2. directory,find-directory
** 記 錯誤處理
   * 兩種風格
     IO 相關的函數在出錯時
     1. 立即報錯
     2. 返回出錯信息
   * 第一種很簡單
     它假設了所有的錯誤都是不可忽略的
** 記 元數據
   * 訪問管理
     1. 誰有權訪問這個文件
     2. 他的權利是什麼
   * 文件類型
     [linux 沒有]
   * 文件大小
   * 文件使用註釋
     [linux 沒有]
** file,creat
   #+begin_src cicada-nymph :tangle core.cn
   : file,creat
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#0200
     8#0100 bit-or <<
     O_EXCL   0200
     O_CREAT  0100
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (file,creat) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     port,close if
       end
     then
     "* (file,creat) fail to close port for the following path :" .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** file,update
   #+begin_src cicada-nymph :tangle core.cn
   : file,update
     << string[address, length], path[address, length] -- >>
     >::path
     >::string
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (file,update) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     ::string swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       "* (file,update) fail to write port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:counter << bytes been written >>
     :port
     port,close if
       end
     then
     "* (file,update) fail to close port for the following path : " .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** file,remove
   #+begin_src cicada-nymph :tangle core.cn
   : file,remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,unlink:
     1 syscall
     dup
     negative? if
       "* (file,remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,file,creat
     << -- >>
     "kkk~" file,creat
     "core" file,creat
     end
   ; define-function
   test,file,creat

   : test,file,update
     << -- >>
     "kkk~" file,creat
     "kkk took my baby away !!!" "kkk~" file,update
     end
   ; define-function
   test,file,update

   : test,file,remove
     << -- >>
     "kkk~" file,remove
     "play" file,remove
     end
   ; define-function
   test,file,remove
   #+end_src
** directory,creat
   #+begin_src cicada-nymph :tangle core.cn
   : directory,creat
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#755 <<
     2#111101101
     >>
     :syscall-path
     :syscall-number,mkdir:
     2 syscall
     dup
     negative? if
       "* (directory,creat) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** directory,remove
   #+begin_src cicada-nymph :tangle core.cn
   : directory,remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,rmdir:
     1 syscall
     dup
     negative? if
       "* (directory,remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,directory,creat
     << -- >>
     "play" directory,creat
     end
   ; define-function
   test,directory,creat

   : test,directory,remove
     << -- >>
     "play" directory,remove
     end
   ; define-function
   test,directory,remove
   #+end_src
** getdents64 structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +getdents64,d_ino+        ; define-variable
   0 : +getdents64,d_off+        ; define-variable
   0 : +getdents64,d_reclen+     ; define-variable
   0 : +getdents64,d_type+       ; define-variable
   0 : +getdents64,d_name+       ; define-variable
   0 : +getdents64,end+          ; define-variable

   : init,getdents64
     << offset -- >>
     *jo-size* 4 equal? if
       dup address +getdents64,d_ino+       save 8 add
       dup address +getdents64,d_off+       save 8 add
       dup address +getdents64,d_reclen+    save 2 add
       dup address +getdents64,d_type+      save 1 add
       dup address +getdents64,d_name+      save 256 add
           address +getdents64,end+           save
       end
     then
     *jo-size* 8 equal? if
       dup address +getdents64,d_ino+       save 8 add
       dup address +getdents64,d_off+       save 8 add
       dup address +getdents64,d_reclen+    save 2 add
       dup address +getdents64,d_type+      save 1 add
       dup address +getdents64,d_name+      save 256 add
           address +getdents64,end+           save
       end
     then
     end
   ; define-function

   0 init,getdents64
   +getdents64,end+ : +getdents64,length+ ; define-variable
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,getdents64,print
     << -- >>
     "+getdents64,d_ino+ : "    .s +getdents64,d_ino+     fetch . .l
     "+getdents64,d_off+ : "    .s +getdents64,d_off+     fetch . .l
     "+getdents64,d_reclen+ : " .s +getdents64,d_reclen+  fetch-two-bytes . .l
     "+getdents64,d_type+ : "   .s
     +getdents64,d_type+
     fetch-byte file-type-code->string .s .l
     "+getdents64,d_name+ : "   .s
     +getdents64,d_name+
     dup 256
     0 string,find-char
     drop  << drop 0 >>
     over sub .s .l
     .l
     end
   ; define-function

   : test,getdents64,loop,structure
     << end, cursor -- >>
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     :cursor init,getdents64
     test,getdents64,print
     :cursor +getdents64,d_reclen+ fetch-two-bytes add
     <> test,getdents64,loop,structure
   ; define-function

   : test,getdents64,loop
     << port -- >>
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     "* syscall returns : " .s dup .i .l
     dup negative? if
       error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     test,getdents64,loop,structure
     :port
     <> test,getdents64,loop
   ; define-function

   : test,getdents64
     << path[address, length] -- >>
     >::path
     ::path input-port,open if
     else
       "* (test,getdents64) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port test,getdents64,loop
     :port port,close if
       end
     then
     "* (test,getdents64) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function

   : play ;
   test,getdents64

   : play/kkk ;
   test,getdents64

   : . ;
   test,getdents64

   : / ;
   test,getdents64
   #+end_src
** empty-directory?
   #+begin_src cicada-nymph :tangle core.cn
   : empty-directory?
     << path[address, length] -- bool >>
     >::path
     ::path input-port,open if
     else
       "* (empty-directory?) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       false
       end
     then
     >:port
     128 allocate-local-memory >:getdents64-structure-list
     128
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     48 equal? << this call to equal? returns the needed bool >>
     :port port,close if
       end
     then
     "* (empty-directory?) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     false
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : play ;
   empty-directory? . .l

   : play/kkk ;
   empty-directory? . .l

   : play/aaa ;
   empty-directory? . .l

   : . ;
   empty-directory? . .l

   : / ;
   empty-directory? . .l
   #+end_src
** directory,list-by-file-type-code
   #+begin_src cicada-nymph :tangle core.cn
   : directory,list-by-file-type-code,loop,print
     << end, cursor, file-type-code -- >>
     >:file-type-code
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     :cursor init,getdents64
     +getdents64,d_type+ fetch-byte
     :file-type-code equal? if
       "  " .s
       +getdents64,d_name+
       dup 256
       0 string,find-char
       drop  << drop 0 >>
       over sub .s .l
     then
     :cursor
     +getdents64,d_reclen+ fetch-two-bytes
     add
     :file-type-code
     <> directory,list-by-file-type-code,loop,print
   ; define-function

   : directory,list-by-file-type-code,loop
     << port, file-type-code -- >>
     >:file-type-code
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     dup negative? if
       error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     :file-type-code
     directory,list-by-file-type-code,loop,print
     :port
     :file-type-code
     <> directory,list-by-file-type-code,loop
   ; define-function

   : directory,list-by-file-type-code
     << directory-path[address, length], file-type-code -- >>
     >:file-type-code
     >::path
     ::path input-port,open if
     else
       "* (directory,list-by-file-type-code) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port :file-type-code directory,list-by-file-type-code,loop
     :port port,close if
       end
     then
     "* (directory,list-by-file-type-code) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** directory,list-file
   #+begin_src cicada-nymph :tangle core.cn
   : directory,list-file
     << directory-path[address, length] -- >>
     8 directory,list-by-file-type-code
     end
   ; define-function
   #+end_src
** directory,list-directory
   #+begin_src cicada-nymph :tangle core.cn
   : directory,list-directory
     << directory-path[address, length] -- >>
     4 directory,list-by-file-type-code
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : play ;
   dup2 directory,list-file
   directory,list-directory

   : play/kkk ;
   dup2 directory,list-file
   directory,list-directory

   : . ;
   dup2 directory,list-file
   directory,list-directory

   : / ;
   dup2 directory,list-file
   directory,list-directory
   #+end_src
** directory,find-by-file-type-code
   #+begin_src cicada-nymph :tangle core.cn
   : directory,find-by-file-type-code,loop,find
     << end, cursor, file-name[address, length], file-type-code -- bool >>
     >:file-type-code
     >::file-name
     dup2 less-or-equal? if
       drop2
       false
       end
     then
     >:cursor
     >:end
     :cursor init,getdents64
     +getdents64,d_type+ fetch-byte :file-type-code equal? if
       ::file-name +getdents64,d_name+
       dup2 add fetch-byte zero? if
         over string-equal? if
           true
           end
         then
       else
         drop drop2
       then
     then
     :end
     :cursor +getdents64,d_reclen+ fetch-two-bytes add
     ::file-name
     :file-type-code
     <> directory,find-by-file-type-code,loop,find
   ; define-function

   : directory,find-by-file-type-code,loop
     << port, file-name[address, length], file-type-code -- bool >>
     >:file-type-code
     >::file-name
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     dup negative? if
       "* (directory,find-by-file-type-code,loop) syscall fail" .s .l
       "  " .s error-code->string .s .l
       false
       end
     then
     dup zero? if
       << zero as false >>
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     ::file-name
     :file-type-code
     directory,find-by-file-type-code,loop,find if
       true
       end
     then
     :port
     ::file-name
     :file-type-code
     <> directory,find-by-file-type-code,loop
   ; define-function

   : directory,find-by-file-type-code
     << directory-path[address, length],
        file-name[address, length],
        file-type-code
        -- true
        -- false >>
     >:file-type-code
     >::file-name
     >::directory-path
     ::directory-path input-port,open if
     else
       "* (directory,find-by-file-type-code) fail to open : " .s ::directory-path .s .l
       "  " .s error-code->string .s .l
       false
       end
     then
     >:port
     :port ::file-name :file-type-code directory,find-by-file-type-code,loop
     :port port,close if
       end
     then
     "* (directory,find-by-file-type-code) fail to close : " .s ::directory-path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** directory,find-file
   #+begin_src cicada-nymph :tangle core.cn
   : directory,find-file
     << directory-path[address, length],
        file-name[address, length]
        -- true
        -- false >>
     8 directory,find-by-file-type-code
     end
   ; define-function
   #+end_src
** directory,find-directory
   #+begin_src cicada-nymph :tangle core.cn
   : directory,find-directory
     << directory-path[address, length],
        file-name[address, length]
        -- true
        -- false >>
     4 directory,find-by-file-type-code
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,directory,find-file
     << -- >>
     "play" "cn" directory,find-file .
     "play" "kkk" directory,find-file .
     "play" "no" directory,find-file .
     .l
     "playlay" "no" directory,find-file .
     .l
     end
   ; define-function
   test,directory,find-file

   : test,directory,find-directory
     << -- >>
     "play" "cn" directory,find-directory .
     "play" "kkk" directory,find-directory .
     "play" "no" directory,find-directory .
     .l
     "playlay" "no" directory,find-directory .
     .l
     end
   ; define-function
   test,directory,find-directory
   #+end_src
* path
** 記 syntax about path
   * 利用了系統的路徑格式
     同時又把系統的路徑格式抽象掉了
   #+begin_src cicada-nymph
   {path: home xyh cicada core.cn}
   "/home/xyh/cicada/core.cn"

   {path: home xyh cicada}
   "/home/xyh/cicada"

   {path: +working+ core.cn}
   "./core.cn"

   {path: +parent+ cicada core.cn}
   "../cicada/core.cn"

   {path: +library+ kkk main.cn}
   "/home/xyh/.cicada/library/kkk/main.cn"
   #+end_src
** relative-path?
** full-path?
** stat structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +stat,st_dev+        ; define-variable
   0 : +stat,st_ino+        ; define-variable
   0 : +stat,st_mode+       ; define-variable
   0 : +stat,st_nlink+      ; define-variable
   0 : +stat,st_uid+        ; define-variable
   0 : +stat,st_gid+        ; define-variable
   0 : +stat,st_rdev+       ; define-variable
   0 : +stat,st_size+       ; define-variable
   0 : +stat,st_blksize+    ; define-variable
   0 : +stat,st_blocks+     ; define-variable
   0 : +stat,st_atime+      ; define-variable
   0 : +stat,st_atime_nsec+ ; define-variable
   0 : +stat,st_mtime+      ; define-variable
   0 : +stat,st_mtime_nsec+ ; define-variable
   0 : +stat,st_ctime+      ; define-variable
   0 : +stat,st_ctime_nsec+ ; define-variable
   0 : +stat,__unused4+     ; define-variable
   0 : +stat,__unused5+     ; define-variable
   0 : +stat,end+           ; define-variable

   : init,stat
     << offset -- >>
     *jo-size* 4 equal? if
       dup address +stat,st_dev+        save *jo-size* add
       dup address +stat,st_ino+        save *jo-size* add
       dup address +stat,st_mode+       save 2 add
       dup address +stat,st_nlink+      save 2 add
       dup address +stat,st_uid+        save 2 add
       dup address +stat,st_gid+        save 2 add
       dup address +stat,st_rdev+       save *jo-size* add
       dup address +stat,st_size+       save *jo-size* add
       dup address +stat,st_blksize+    save *jo-size* add
       dup address +stat,st_blocks+     save *jo-size* add
       dup address +stat,st_atime+      save *jo-size* add
       dup address +stat,st_atime_nsec+ save *jo-size* add
       dup address +stat,st_mtime+      save *jo-size* add
       dup address +stat,st_mtime_nsec+ save *jo-size* add
       dup address +stat,st_ctime+      save *jo-size* add
       dup address +stat,st_ctime_nsec+ save *jo-size* add
       dup address +stat,__unused4+     save *jo-size* add
       dup address +stat,__unused5+     save *jo-size* add
           address +stat,end+           save
       end
     then
     *jo-size* 8 equal? if
       dup address +stat,st_dev+        save *jo-size* add
       dup address +stat,st_ino+        save *jo-size* add
       <<
       note the following order changing
       this is linux' bad
       >>
       dup address +stat,st_nlink+      save 8 add
       dup address +stat,st_mode+       save 4 add

       dup address +stat,st_uid+        save 4 add
       dup address +stat,st_gid+        save 4 add
                                             4 add << padding >>
       dup address +stat,st_rdev+       save *jo-size* add
       dup address +stat,st_size+       save *jo-size* add
       dup address +stat,st_blksize+    save *jo-size* add
       dup address +stat,st_blocks+     save *jo-size* add
       dup address +stat,st_atime+      save *jo-size* add
       dup address +stat,st_atime_nsec+ save *jo-size* add
       dup address +stat,st_mtime+      save *jo-size* add
       dup address +stat,st_mtime_nsec+ save *jo-size* add
       dup address +stat,st_ctime+      save *jo-size* add
       dup address +stat,st_ctime_nsec+ save *jo-size* add
       dup address +stat,__unused4+     save *jo-size* add
       dup address +stat,__unused5+     save *jo-size* add
           address +stat,end+           save
       end
     then
     end
   ; define-function

   0 init,stat
   +stat,end+ : +stat,length+ ; define-variable
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,stat
     << path[address, length] -- >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       dup .
       error-code->string .s .l
       end
     then
     drop
     :stat-structure init,stat
     "+stat,st_dev+ : " .s +stat,st_dev+        fetch . .l
     "+stat,st_ino+ : " .s +stat,st_ino+        fetch . .l
     *jo-size* 4 equal? if
     "+stat,st_mode+ : " .s +stat,st_mode+       fetch-two-bytes  . .l
     "+stat,st_nlink+ : " .s +stat,st_nlink+      fetch-two-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        fetch-two-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        fetch-two-bytes  . .l
     then
     *jo-size* 8 equal? if
     "+stat,st_nlink+ : " .s +stat,st_nlink+      fetch  . .l
     "+stat,st_mode+ : " .s +stat,st_mode+       fetch-four-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        fetch-four-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        fetch-four-bytes  . .l
     then
     "+stat,st_rdev+ : " .s +stat,st_rdev+       fetch . .l
     "+stat,st_size+ : " .s +stat,st_size+       fetch . .l
     "+stat,st_blksize+ : " .s +stat,st_blksize+    fetch . .l
     "+stat,st_blocks+ : " .s +stat,st_blocks+     fetch . .l
     "+stat,st_atime+ : " .s +stat,st_atime+      fetch . .l
     "+stat,st_atime_nsec+ : " .s +stat,st_atime_nsec+ fetch . .l
     "+stat,st_mtime+ : " .s +stat,st_mtime+      fetch . .l
     "+stat,st_mtime_nsec+ : " .s +stat,st_mtime_nsec+ fetch . .l
     "+stat,st_ctime+ : " .s +stat,st_ctime+      fetch . .l
     "+stat,st_ctime_nsec+ : " .s +stat,st_ctime_nsec+ fetch . .l
     "+stat,__unused4+ : " .s +stat,__unused4+     fetch . .l
     "+stat,__unused5+ : " .s +stat,__unused5+     fetch . .l
     end
   ; define-function

   : cn ;
   test,stat

   : no ;
   test,stat
   #+end_src
** note predicate
   * to use predicate to know more about the file-tree
     before calling a function that makes action on the file-tree
** path,nothing?
   #+begin_src cicada-nymph :tangle core.cn
   : path,nothing?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     -2 equal?
     end
   ; define-function
   #+end_src
** path,file?
   #+begin_src cicada-nymph :tangle core.cn
   : path,file?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       fetch-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       fetch-four-bytes
     then
     12 bit-right
     8#0010
     equal?
     <<
     0170000
     S_IFDIR       0040000 /* Directory.  */
     S_IFCHR       0020000 /* Character device.  */
     S_IFBLK       0060000 /* Block device.  */
     S_IFREG       0100000 /* Regular file.  */
     S_IFIFO       0010000 /* FIFO.  */
     S_IFLNK       0120000 /* Symbolic link.  */
     S_IFSOCK      0140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** path,directory?
   #+begin_src cicada-nymph :tangle core.cn
   : path,directory?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       fetch-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       fetch-four-bytes
     then
     12 bit-right
     8#0004
     equal?
     <<
     0170000
     S_IFDIR       00040000 /* Directory.  */
     S_IFCHR       00020000 /* Character device.  */
     S_IFBLK       00060000 /* Block device.  */
     S_IFREG       00100000 /* Regular file.  */
     S_IFIFO       00010000 /* FIFO.  */
     S_IFLNK       00120000 /* Symbolic link.  */
     S_IFSOCK      00140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : cn ; path,nothing? . << 0 >>
   : core ; path,nothing? . << 0 >>
   : ai ; path,nothing? . << 1 >>

   : cn ; path,file? . << 1 >>
   : core ; path,file? . << 0 >>
   : ai ; path,file? . << 0 >>

   : cn ; path,directory? . << 0 >>
   : core ; path,directory? . << 1 >>
   : ai ; path,directory? . << 0 >>
   #+end_src
* poi
** note
   * poi denotes path-organizer
     it can give a name to a path
     one path one name
     it is designed for (load-file)
** note two directories
   * two directories to store the name path record
     1. user :
        "/home/<user>/.cicada/poi"
     2. system :
        "/etc/cicada/poi"
   * note that
     these two directories are viewed as one by poi
     no such things like
     user overriding system will happen
     one name can only exist in one of the two directories
     more on this in the following note
** note interface for command-line-function
   * cn poi add  <name> <relative-path>
   * cn poi sub  <name>
   * cn poi up   <name> <relative-path>
   * cn poi show <name>
   * cn poi list
   * <relative-path> is converted to <full-path>
     with the help of working-directory
   * <relative-path> is in the format of
     "./directory/file"
     "./directory/directory"
     note that
     for a <relative-path> of directory
     not tailing "/" should be added
** note interface for load-file
   * a path can be a file or a directory
     1. file
        "name" load-file
     2. directory
        "name/file" load-file
        note that
        use "name/file"
        instead of "name/file.cn"
** note interface in cicada-nymph code
   * poi should not be called in cicada-nymph code
** help
   #+begin_src cicada-nymph :tangle core.cn
   : poi,help
     << -- >>

     end
   ; define-function
   #+end_src
** add
   #+begin_src cicada-nymph :tangle core.cn
   : poi,add
     << name[address, length], relative-path[address, length] -- >>

     end
   ; define-function
   #+end_src
** sub
   #+begin_src cicada-nymph :tangle core.cn
   : poi,sub
     << name[address, length] -- >>

     end
   ; define-function
   #+end_src
** up
   * up denotes update
   #+begin_src cicada-nymph :tangle core.cn
   : poi,up
     << name[address, length], relative-path[address, length] -- >>

     end
   ; define-function
   #+end_src
** list
   #+begin_src cicada-nymph :tangle core.cn
   : poi,list
     << -- >>

     end
   ; define-function
   #+end_src
** show
   #+begin_src cicada-nymph :tangle core.cn
   : poi,show
     << name[address, length] -- >>

     end
   ; define-function
   #+end_src
* -----------------------------------
* name-hash-table
** note naming & factoring
   * open addressing
     for we do not need to delete
   * math
     * hash
     * probe
   * memory
     * insert
     * search
   * function
     * map
     * reverse
** *name-hash-table*
   * the following are some prime number
     ready to be used
     * 1000003   about 976 k
     * 1000033
     * 1000333
     * 100003    about 97 k
     * 100333
     * 997
     * 499
   #+begin_src cicada-nymph :tangle core.cn
   100333 drop
   13
   : *name-hash-table,size*
   ; define-variable

   *jo-size* 4 mul
   : *name-hash-table,unit*
   ; define-variable

   *name-hash-table,size*
   *name-hash-table,unit* mul
   allocate-memory
   : *name-hash-table*
   ; define-variable

   0
   : *name-hash-table,counter*
   ; define-variable
   #+end_src
** name-hash-table,hash
   * prime table size
   * linear probing
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,hash
     << number, counter -- index >>
     add *name-hash-table,size* mod
     end
   ; define-function
   #+end_src
** string->finite-carry-sum
   #+begin_src cicada-nymph :tangle core.cn
   16
   : *max-carry-position*
   ; define-variable

   : string->finite-carry-sum,loop
     << carry-sum, string[address, length], counter -- carry-sum >>
     over zero? if
       drop drop2
       end
     then
     dup *max-carry-position* greater-than? if
       drop 0 << re-start from 0 >>
     then
     xx|over|x
     string-head,char over
     2 swap power
     mul
     x|swap|xxxx add xxx|swap|x
     add1 xx|swap|x
     string-tail,char x|swap|xx
     <> string->finite-carry-sum,loop
   ; define-function

   : string->finite-carry-sum
     << string[address, length] -- carry-sum >>
     0 xx|swap|x << carry-sum >>
     0 << counter >>
     string->finite-carry-sum,loop
     end
   ; define-function
   #+end_src
** name
*** note
    * a name is an index into name-hash-table
    * an entry can be viewed
      1. as a point
      2. as an orbit
    * in a name entry we have the following fields
      |-------------------------------+-------------------------|
      |                               | note                    |
      |-------------------------------+-------------------------|
      | primitive-string              | 0 denotes               |
      | [address]                     | name not used           |
      |-------------------------------+-------------------------|
      | title                         | 0 denotes               |
      | [index into name-title-table] | name not used as title  |
      |-------------------------------+-------------------------|
      | orbit-length                  | as an orbit             |
      | [number]                      | its length gets updated |
      |-------------------------------+-------------------------|
      | orbiton                       | as a point              |
      | [address]                     | it is on an orbit       |
      |-------------------------------+-------------------------|
*** name->address
    #+begin_src cicada-nymph :tangle core.cn
    : name->address
      << name -- address >>
      *name-hash-table,unit* mul
      *name-hash-table* add
      end
    ; define-function
    #+end_src
*** name,used?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used?
      << name -- bool >>
      name->address
      fetch zero? false?
      end
    ; define-function
    #+end_src
*** name,used-as-title?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used-as-title?
      << name -- bool >>
      name->address
      *jo-size* add
      fetch zero?
      end
    ; define-function
    #+end_src
*** name,fetch-string
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-string
      << name -- string[address, length] >>
      name->address
      fetch
      address->primitive-string
      end
    ; define-function
    #+end_src
*** name,fetch-title-index sadsfiljdasd
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-title-index
      << name -- index >>
      name->address
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-orbit-length
      << name -- length >>
      name->address
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-orbiton
      << name -- address >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,save-string
    * note that
      primitive-string-area is used
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-string
      << string[address, length], name -- >>
      *current-free-address,primitive-string-area*
      xx|swap|xx
      save-into,primitive-string-area
      swap
      name->address
      save
      end
    ; define-function
    #+end_src
*** name,save-title-index
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-title-index
      << index, name -- >>
      name->address
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-orbit-length
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-orbiton
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,no-collision?
    #+begin_src cicada-nymph :tangle core.cn
    : name,no-collision?
      << name -- bool >>
      dup name,fetch-orbiton
      equal?
      end
    ; define-function
    #+end_src
** name-hash-table,search
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,search,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       :name false
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :name name,fetch-orbit-length
     :counter equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,search,loop
   ; define-function

   : name-hash-table,search
     << string[address, length]
        -- name, true
        -- false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,search,loop
     end
   ; define-function
   #+end_src
** name-hash-table,insert
   * I found that (insert) can not re-use (search)
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       ::string :name
       name,save-string
       :orbit :name
       name,save-orbiton
       :counter :orbit
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       :name true
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :counter *name-hash-table,size* equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** string->name & name->string
   * error handling here
   #+begin_src cicada-nymph :tangle core.cn
   : string->name
     << string[address, length] -- name >>
     name-hash-table,insert
     false? if
       "* (string->name) *name-hash-table* is full!" .s .l
       end
     then
     end
   ; define-function

   : name->string
     << name -- string[address, length]] >>
     name,fetch-string
     end
   ; define-function
   #+end_src
** test
   * set *name-hash-table,size* to a small number [for example 13]
     then use the following function
     and (name-hash-table,report) to do test
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,test
     << -- >>
     "a-000" string->name . .l
     "a-111" string->name . .l
     "a-222" string->name . .l
     "a-333" string->name . .l
     "a-444" string->name . .l
     "a-555" string->name . .l
     "a-666" string->name . .l
     "a-777" string->name . .l
     "a-888" string->name . .l
     "a-999" string->name . .l
     "b-000" string->name . .l
     "b-111" string->name . .l
     "b-222" string->name . .l
     "b-333" string->name . .l
     "b-444" string->name . .l
     "b-555" string->name . .l
     "b-666" string->name . .l
     "b-777" string->name . .l
     "b-888" string->name . .l
     "b-999" string->name . .l
     end
   ; define-function
   #+end_src
** note about report
   * report point orbit by orbit
     in the following format
   * {index} string # orbit-lenght
     * {index} string
     * {index} string
     * {index} string
   * if used as title
     add a (AS TITLE) as postfix
** name-hash-table,report
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,report,orbit
     << name, counter -- >>
     over name,fetch-orbit-length
     over less-than? if
       drop2
       end
     then
     over name,fetch-string string->finite-carry-sum
     over name-hash-table,hash
     dup name,fetch-orbiton
     << name, counter, new-name, orbiton >>
     x|over|xxx name,fetch-string string->finite-carry-sum
     0 name-hash-table,hash
     equal? if
       "  {" .s
       dup write-number
       "} " .s
       name,fetch-string .s
       .l
     else
       drop
     then
     add1 <> name-hash-table,report,orbit
   ; define-function

   : name-hash-table,report,loop
     << name -- >>
     dup *name-hash-table,size* equal? if
       drop
       end
     then
     dup name,used? if
     dup name,no-collision? if
       << * {index} string # orbit-lenght >>
       "* {" .s
       dup write-number
       "} " .s
       dup name,fetch-string .s
       " # " .s
       dup name,fetch-orbit-length
       write-number
       .l
       dup 1 name-hash-table,report,orbit
     then
     then
     add1 <> name-hash-table,report,loop
   ; define-function

   : name-hash-table,report
     << -- >>
     0 name-hash-table,report,loop
     "* totally : " .s
     *name-hash-table,counter* write-number
     .l
     end
   ; define-function
   #+end_src
* -----------------------------------
* command-line-interface
** note
** command-line,unknow-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,unknow-function
     << -- >>
     "* (cicada-nymph) unknow command-line-function : " .s
     get-command-line
     string-tail,word
     string-head,word .s .l
     "* good bye ^-^/" .s .l
     bye
     end
   ; define-function
   #+end_src
** command-line,stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,stack-REPL
     << -- >>
     welcome
     hi
     initial-report
     "* you are in the (stack-REPL)" .s .l
     "  every time after a word is executed" .s .l
     "  the argument-stack get printed" .s .l
     print-argument-stack,pretty
     jo stack-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,basic-REPL
     << -- >>
     welcome
     hi
     initial-report
     "* you are in the (basic-REPL)" .s .l
     "  this REPL does not print any thing automaticly" .s .l
     jo basic-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,poi
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,poi
     << -- >>
     "* poi byebye" .s .l
     bye
     end
   ; define-function
   #+end_src
** command-line,no-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,no-function
     << -- >>
     <> command-line,stack-REPL
   ; define-function
   #+end_src
** command-line-dispatcher
   #+begin_src cicada-nymph :tangle core.cn
   : command-line-dispatcher
     << -- >>
     get-command-line
     string-tail,word
     dup2 space-string? if
       drop2
       <> command-line,no-function
     then
     string-head,word
     >::1st-word
     ::1st-word "basic-REPL" string-equal? if
       <> command-line,basic-REPL
     then
     ::1st-word "stack-REPL" string-equal? if
       <> command-line,stack-REPL
     then
     ::1st-word "poi" string-equal? if
       <> command-line,poi
     then
       <> command-line,unknow-function
   ; define-function
   #+end_src
* *the-story-begin*
  #+begin_src cicada-nymph :tangle core.cn
  : the-story-begin
    << -- >>
    <> command-line-dispatcher
  ; define-function

  the-story-begin
  #+end_src
* ===================================
* test
** name-hash-table
   #+begin_src cicada-nymph
   name-hash-table,test
   name-hash-table,report
   #+end_src
** report
   #+begin_src cicada-nymph
   report-memory
   report-syntax
   jotionary,report
   #+end_src
* ===================================
