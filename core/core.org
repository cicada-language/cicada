#+TITLE:  小蟬之核 / core of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* module mechanism
** about <importing-stack>
** ><>< syntax
** >< exception
* todo
** 語法擴展機制的接口需要改進
   * 目前如果 謂詞是匿名函數的話 sub-rule 就沒法用了
     因爲 add-rule 時的匿名函數是不同的
** 基礎設施 之 測試框架
   * 讓所有的測試讀的內容讀起來都有趣味
** 基礎設施 之 返回值
** 基礎設施 之 靜態類型
** do we need stack balancer at all ?
   * (<basic-REPL-syntax> address) is using
   * (<basic-REPL-syntax> jo) is not
** 基礎設施 之 利用類型來優化 [提前作用]
** 重新實現關於局部變元的語法 以在匿名函數中使用 修復 if 的問題 並增加語法
   * 還有 標記語言語法的實現 以向嵌套的匿名函數中代入東西
     注意
     被代入的東西 其實是在 *local-jo* 中的
     如果想要形成兩端函數的 concatenate
     那麼就必須在 複製的時候去處理這種 concatenate
     也就是說
     代入的方式可以各種各樣
     一套設計良好的標記語言語法 就能完成這個特性
   * 還有 各種返回方式的實現
** 基礎設施 之 代碼生成
   * new way to do data-structure
   * more (define*) about with-title
** 基礎設施 之 除錯模式               :maybe:
   * debug-REPL
** ----------------------------------
** 整理結構 之 分組命名
** 整理結構 之 使用匿名函數
** 整理結構 之 使用返回值
** 整理結構 之 良好測試
** 整理結構 之 分散文件
** ----------------------------------
** better names for (make-*)
** 利用 alias 來實現中文支持
** 基礎設施 之 匿名函數 之 *circular-jojo-area* :maybe:
   * make-jojo 需要重寫
   * 也許 make-jojo make-link make-jo-head
     這一系列函數的名字都應該重新做
     因爲他們的名字
     已經越來越不能展示他們的接口了
** design a way to remove magic numbers [not variable, but file by file like erlang ?]
** only one error-code->string is not enough :maybe:
** language-level support for creating and managing processes :maybe:
* ===================================
* *小蟬記*
** 原則
*** 認知負擔
    * 人以程序語言與機器對話
      正如人與人對話
      其思想互交流兩相影響
      笨機器 成人的認知負擔
      正如笨人 成我的認知負擔
      而程序語言之設計 只爲減少這種認知負擔
*** 莫若以名
    * 少使機器自動處理
      多以人工明顯表達
*** 順序
    * 一個文件中代碼 之 處理順序
      一個函數定義 之 處理順序
      定義好的函數 之 作用順序
*** 底層
    * 我要能完全控制底層機器資源
      如果把類型信息編碼到值中 [即 所謂的動態語言]
      因爲要對編碼和數值做轉換
      那麼這種對底層的控制就成了一種負擔
      是故 小蟬 不用動態類型編碼
      只爲更好控制底層資源
*** 簡單
    * 複雜性狀都在解釋器中實現
      解釋器本身是一個很簡單的匯編程序
    * 我一直維持着上面所聲明的這個特性
      只爲將來能夠快速把解釋器移植到各種機器上
    * 但是我所使用的匯編器能力有限
      這就導致了一下幾點
      1. name-hash-table 在解釋器中實現
         在解釋器中把 link 中的名字加載到 name-hash-table 中
      2. 如果有靜態類型檢查的話
         在匯編代碼中 可能很難做好類型聲明
         也必須在解釋器中 順着 link 來重新把聲明補上
** 語義
*** 基本語義
    * 所謂基本語義有兩點
      對每個程序語言來說都一樣
      1. 如何讓函數作用於參數
      2. 如何定義新的函數
*** 函數定義
    * 我稱函數爲珠
      我稱函數體爲珠珠
      珠 與 珠珠 形成嵌套
    * 又有名來給珠命名
      函數體中保存的是珠而不是名
      其重要特點是
      名動 而 珠靜
    * 返回棧 即 珠珠之棧
*** 函數作用
    * 參數棧 即 函數作用時所取參數之所
      函數所取參數之個數與形態 不受語法控制
    * 有名參數沒有默認值
      實爲函數作用本性所致
** 機制 與 性狀
*** 術語
    * 一個機制 實現 一個性狀
      一組機制 可以被成爲 一組性狀的實現
*** 參數棧
    * 實現函數的參數傳遞
*** 返回棧
    * 實現對函數體中的返回地址的記憶
    * 對返回棧的查找與直接操縱
      實現異常處理
    * 在返回棧中保存兩個局部數據區域的指針
      實現 有名的局部變元 和 局部的內存分配
*** 閱讀棧
    * 使得閱讀地點可以被重新定向到字符串
      實現對字符串的解釋
    * 實現 把括號識別爲詞
*** 語法棧
    * 實現對語境的靈活轉換
    * 語法棧中保存的規則集
      實現對語法動態添加與刪除
*** 鏈
    * 只有唯一一個鏈
      記錄函數被定義的線性線性順序
*** 名散表
    * 實現對函數的快速查找
*** 姓
    * 讓命名更加規則
*** 撤銷棧
    * 用以保存某一時刻的全局狀態
      以實現撤銷
*** 加載棧
    * 用以保存被加載的代碼的信息
      使得代碼可以被分散到不同的文件
      以形成相對獨立的的模塊
** >< 語法
*** 語境
    * reading-stack
    * syntax-stack
    * rule-set
*** >< 括號
    * 應該如何使用 保留的括號 ()
      所謂 mixfix notation ?
      所謂 borderfix notation ?
** 類型
*** >< 靜態類型檢查
    * 目前是完全無類型的語言
      是否應該引入靜態類型檢查
      應該如何引入
      類型檢查可能是很簡單的
      否則 對參數註釋 做爲信息 就被機器浪費了
    * 對類型的處理
      其實是要植入 函數語義的接口 當中
      即 函數作用 與 函數定義 當中
    * 所謂 靜態
      與動態相對
      其含義爲
      類型信息不以類型標籤的形式編碼在數據中
    * 所謂 類型檢查
      函數有類型聲明
      定義函數時
      可由函數體算出其實際類型是否與聲明類型相符合
      不符則拒絕定義
    * 類型有編碼
      只是編碼不保存在這個類型的數據當中
      而保存函數當中
      類型編碼只能用 name 和 數組 進行
      而不應該用字符串
    * 副作用應該如何處理
      也應該有編碼 ?
    * 保存在函數中的元數據可以用於計算
      當做出上面這種論斷的時候
      需要明確的是計算所使用的代數結構是什麼
    * 我可不可以把這個代數結構變得特別靈活 ?
      不光對棧的副作用可以用於計算
      對別的數據結構的副作用也可以被用於計算
      如果我能提供機制來定製各種各樣的計算規則
      那麼我就達到了我所說的靈活性
    * 棧所形成的 所謂 最一般的結合代數 也是一個代數結構
      重範疇論的角度觀察
      兩個代數結構之間相差一個遺忘函子
      忘了數據本身的值 只記住其類型
*** >< 類型與姓的關係
    * 當說 類型應該用 name 來編碼的時候
      其實就是說類型應該用 姓 來編碼
    * 但是 <title> name 完全是一種命名機制
      函數本身的類型可以是完全與 <title> 無關的
      也就說 在名字中的 <title> 是對 在提醒函數類型可能與 <title> 有關
*** >< 不加檢查之時
    * 在形成類型檢查機制之前 有不加檢查之時
      必須保證兩種狀態的順利銜接
    * 這也就是說
      在形成類型檢查機制之前
      我還是能去設計和增加別的機制
      很多機制的設計不必等待類型檢查
      [比如 加載機制]
** 優化
   * 有了類型信息
     就有可能在定義函數的時候把某些可以執行的計算進行掉
     如果引入這種優化
     那麼 就有必要 區分變元與常元了
** >< 函數體內的結構化數據
*** 不能用來做返回值的結構化數據
    * 在一個函數體內
      它盡可以 通過 (allocate-local-memory)
      來分配 *local-byte*
      然後自己製作結構化的數據
      但是這裏所製作的數據並不能用來做返回值
      因爲函數退出的時候
      所分配的局部內存就被回收了
*** 函數返回 靜態的 結構化數據
    * 函數能夠返回結構化數據
      只因沒有動態的內存管理
      所以保存函數內結構化數據的內存
      都是在定義函數的時候分配的
      對這些函數的返回值進行副作用將是危險的
    * 比如
      | string | *string-area* |
      | jojo   | *jojo-area*   |
*** 函數返回 動態的 結構化數據
    * 這裏簡陋的實現動態內存分配的方式是
      使用 circular
      所達到的效果是 讓人們不能依賴這裏的數據
      數據分配到了這裏 就得儘快使用掉
      否則一個週期之後 數據就被覆蓋了
    * 比如
      | string | *circular-string-area* |
      | jojo   | *circular-jojo-area*   |
** 數據結構
*** 計劃
    * 這裏其實是把 蟬語 中所設想的 姓 的機制
      變成 數據結構接口管理器
      也就是 實現 姓 做爲 數據結構
*** 實現
    * 既然已經有了 name-hash-table 那麼這些就都是可能實現的了
    * 可以用語法擴展來實現編譯時期對 jo 的查找
    * 接口方面 有兩種方式
      1. 完全與 已有的 查找 jo 的機制相互分離
      2. 重用已有的機制
      已有的機制有兩種
      一個是 利用單項鏈接的鏈表
      一個是 利用 name-hash-table 中的 nymph-jo 域
    * 使用分離的 title-table 和 data-structure-table
      都是爲了 減輕 name-hash-table 的負載
      但是 也許這種負載對於 name-hash-table 是微乎其微的
    * 我使用這樣一種方式來重用 name-hash-table
      利用的特性是 如果做爲名字的字符串中帶有空格
      那麼它就不可能被 以正常的方式找到
      而利用這種 空格所形成的名字的 層次結構
      我可以實現我所需要的性狀
    * 在 name-hash-table 之外
      我還需要像 jo 的全局鏈表一樣的鏈表來實現 每個 data-structure
** 評論
*** 命名 與 分解 與 匿名
    * 命名
      命名有兩種
      1. 局部的
      2. 全局的
    * 分解
      分解有兩種
      1. 利用函數作用的
         這種分解利用了局部的名
      2. 利用函數複合的
         這種分解利用了全局的名
    * 許多 forth 所崇尚的分解
      其實是單純爲了緩解 置換棧 的壓力的
    * 匿名
      緩解命名壓力的方式是匿名
      實現匿名的方式有兩種
      1. lambda
         其實是一種標記語言
         lambda 的參數名字 是用來標記代入點用的
         這裏
         理解上的壓力來源於
         對標記的分析
      2. 組合子
         每個組合子都是一個全局的名字
         從 lambda 的角度看
         每個組合子捕捉某種代入模式
         然後給這種代入模式一個名字
         這裏
         理解上的壓力來源於
         對名字所捕捉的模式的熟悉
*** 圓上的點
    * 一個點在圓上移動
      它的位置在變 但是它到圓心的距離始終相等
** 命名
*** 鍊
    * 之所以需要 鍊
      是因爲匯編語言的能力太弱
      直接在其中實現 名散表 太費心力
    * 一旦解釋器被執行起來之後
      連就會被拋棄
*** 名散表
    * 名散表 是處理命名的唯一數據結構
      其中每個 名欄 之 珠域 對珠的保存
      就是命名過程
    * 珠子本身還是有名字的
      但是這些名字只用來打印函數體
      而別無他用
      來自模塊的珠子
      其名字中的前綴指示其模塊
      這樣我就能在出錯時從文件中找到這個珠子的位置
      也許有多個位置 因爲可能有重複命名
*** 名備份區
    * 需要備份的原因是
      1. 我需要記錄珠被命名的順序
      2. 我需要能夠把 名散表 恢復到之前的狀態
*** 珠 到 名
    * 很難從 珠 找到它當時的命名
      正確的做法是
      在函數提中的每個位置增加一個名
    * 假設這種 珠 到 名 的函數
      只爲除錯所用
      那麼在 *global-naming-stack* 中搜索 珠 的名字
      也是可以接受的
      我選擇這種方式
      並且把 名域 從 珠中剔除
** 姓
*** 目的
    * 在 小蟬 中
      姓 可以被理解爲 接口管理器
      或者 名字管理器
      其目的是
      在需要的時候
      將命名過程變得更加正規
    * 姓 的
      1. 編碼數據類型的功能
      2. 簡化函數調用語法的功能
      只有在 有類型的 蟬語 中
      才能實現
    * 接口管理器 可以用來建立 數據結構的概念
      但是 接口管理器 本身的機制是與 數據結構的機制相互分離的
*** 實現
    * 每個 <title> 在全局的 link 中
      做爲一個 variable-jo 而存在
      其中保存一個 link
    * 這個 link 中的 jo 就是登記在 這個 <title> 下的 jo
      同時也會在 name-hash-table 中登記
      此時
      比如 function 會被登記到 "<title> function" 這個 name 下
*** 接口
    * (define-function,with-title)
      直接製作新的東西
      並註冊新的 function 到 <title> 下
      與 (define-function) 完全類似
      當第一次遇到某個 <title> 時
      初始化這個 <title> 做爲 variable-jo 的存在
    * (alias)
      把已有舊的東西
      給一個 name 以註冊到 <title> 下
      可以讓它處理一個列表的東西
      同樣初的版本可以是最簡單的
    * 在着兩個底層函數之後
      應該重新定義 (define-function)
      使得他們能夠處理 帶有 <title> 的情形
*** implementation
    * a title is a link
      a name under title can be found
      by normal link interface
    * a title also has some special meaning to the name-hash-table
      a name under title can NOT be found
      by normal name-hash-table interface
      to be found
      the name must be prefix by the string "<title> "
** 命名
   * 命名行爲有很多類型
     令人困惑 列舉如下
     1. 首先是全局變量
        一個全局變量 是一個有名字的盒子
        裏面可以保存值
     2. 其次是有 名域 的數據結構
        比如 珠 和 鍊
     3. 再次是 名散表 中
        一個 名 下所保存的值
   * 特點是
     1. 由值不能找回名字
     2. 值本身是一個數據結構的地址
        可以用以找回名字
        因爲名字只是這個數據結構的一個域
     3. 目前 名散表 中所保存的值
        只限於 珠
        一個 珠 可以存在於很多 名散表 中的 名欄 中
        每個 名欄 之名 都是這個珠的別名
        珠 做爲數據結構其內所保存的名字
        纔是這個珠的真名
   * 問題
     1. 珠 內的真名 是有必要的還是沒必要的
        這個名字的唯一目的就是 用以打印於顯示
        完全沒有查找的功能
   * 這種混亂的原因在於
     1. 函數體中所保存的
        不是 名散表 中的 名欄
        而是 函數的真正地址
   * 這導致動態性的喪失
     即 重新定義一個函數的時候
     有時必須重新定義所有依賴於它的函數
     才能達到所期望的效果
     同時獲得靜態性
     即 重新定義一個函數時
     不會破壞以前的定義
** 局部變元的語法
   * joy 中的匿名謂詞
     在作用於棧中的值的時候
     不必複製它所作用的值
   * 而 cicada-nymph 必須以明顯的方式複製棧中的值
     如果每一組函數對棧中的值的消耗都能夠被編譯器計算出來
     那麼就可以省略這些明顯的複製了
     這些是可能實現的
     只要把註釋信息設計成 良好的 可以被自動處理的 格式 就可以了
   * 然而
     在沒有對棧的註釋的自動推演的情況下
     我也可以通過設計特殊的語法來實現比較好的效果
   * a macro to pickup values from stack by index
     index starts from 0
     #+begin_src cicada-nymph
     :0 :1 :2 :3
     ::0 ::1

     :0 as dup
     ::0 as dup2
     #+end_src
   * a macro to pickup values from stack by name
     #+begin_src cicada-nymph
     << string[address, length], counter -- >>

     << do not eat >>
     :2 :1 >::string :0 >:counter
     ::2 >::string :0 >:counter
     =>[::string :counter]

     << eat >>
     >:counter >::string
     >[::string :counter]
     #+end_src
   * by the above example
     we know that
     we also need
     #+begin_src cicada-nymph
     =>::name
     #+end_src
     to replace
     #+begin_src cicada-nymph
     dup2 >::name
     #+end_src
** 結構化數據的初始化語法
   * [ ] 是 匿名的 jo 這種結構化數據的初始化語法
     然而
     別的結構化的數據應該如何呢 ?
   * 比如 path: directory-name file-name ;
     是一種用來初始化 特殊的[代表 path 的]字符串的語法
   * 需要類似的語法的地方還有
     1. vector of name
     2. vector of string
     注意這裏的 vector 都是類型良好的
     必須是這樣
     因爲我根本沒有對類型編碼
   * 對於上面所欠缺的兩種語法
     我可以很容易想出很多設計方式
     但是要知道
     語法是可以靈活轉換的
     所以可以先實現幾個語法試試效果
** 局部變元代入嵌套的無名函數
   * 局部變元代入嵌套的無名函數 是可以實現的
     可以實現特殊的標記語法來支持這個特性
     並且
     當些無名函數需要被做爲返回值返回時
     去返回無名函數的複製
     而不返回在大函數體內的無名函數本身 就行了
     此時的複製有兩種
     1. 複製到圈狀內存中
        此時所返回的值必須在短時間內被用掉
     2. 複製到靜態內存中
        這樣就提供了一種生成函數的方式了
** data-structure
   * a data-structure is a pattern of bit [thus byte [thus jo]] in memory
   * a data-structure is referenced by is address in memory
   * what a low level programming language should provide
     is a flexible way [a mechanism]
     to manage the interfaces of all kinds of data-structures
     including
     1. define
     2. allocate & init
     3. get & set
     4. equal & copy
     and other operating functions
   * that is to say
     the interface of a data-structure is a set of functions
     what should be managed are
     1. how to define these functions
        maybe to generate these functions group by group
     2. how to apply these functions on their arguments
        i.e. to call these functions
   * the mechanism implemented here is very flexible
     thus
     it usage is not limited to help to form the concept about data-structure
** 匯編器
*** 能夠編譯自己之後之後才能實現的性狀
    * jotionary 中 jojo 的長度
    * 把對 棧註釋 處理成 元數據
      利用這些元數據 就能夠實現簡單的類型推導
    * 一個 debug 模式
      在其中 對所有的基本的 棧的接口加上保護
    * jojo 的頭部 和 jojo 本身的分離
      這樣就能在 link 方面增加一層間接
      而實現別名機制
*** 對匯編器的需要
    * 爲了實現上面的性狀
      把 cicada-nymph 編譯到任何一個語言都是可以的
      [比如 Fasm]
    * 但是我還是需要自己實現匯編器
      因爲就工作量而言 二者相當
      就所形成的實現策略的靈活性而言
      根據 自己的匯編器 所制定的實現策略 要靈活很多
*** 小蟬 與 蟬語
    * 關係如下
      #+begin_src return-stack
      (machine) -> (cicada-nymph)
      (assembler) & (vm) -> (cicada-language)
      #+end_src
    * 可移植性由小蟬的易實現性來維護
    * (vm) 是
      實現與 cicada-nymph 中的
      對底層機器的特殊屬性依賴很弱的
      線串碼解釋器
    * (assembler) 是
      以 cicada-nymph 所提供的交叉匯編器框架爲基礎的
** 交叉匯編器構架
   * cross assembler framework
   * 目的 爲了寫 cicada-language 的 VM 的 匯編器
   * 在 name-hash-table 中貢獻出一個域
     來分離 匯編器 的命名空間
   * memory buffer editor
     1. bit buffer editor
     2. byte buffer editor
   * 多光標編輯
     * cursor = 1 cursor
     * buffer = 2 cursor
     * xxxxxx = 3 cursor
   * line editor 外加各種 mode
** >< 異常處理
   * 所謂的異常處理其重點有二
     1. 非局部退出
     2. 對同樣的異常情況
        在不同的場合下需要有不同的處理方式
   * 而我現在所實現的只是 1 而沒有 2
* ===================================
* writers
** note name of writers
   * the use of "." as prefix
     is inherited from Forth
   * table
     | .  | pretty_write_integer | assembly |
     | .i | write_integer        | core     |
     | .s | write_string         | assembly |
     | .l | linefeed             | core     |
     | .b | write-byte           |          |
** .l .i .b
   #+begin_src cicada-nymph :tangle core.cn
   : .l
     << -- >>
     10 write-byte
     end
   ; define-function

   : .i
     << -- >>
     write-integer
     end
   ; define-function

   : .b
     << byte -- >>
     write-byte
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : kkk
     "kkk took my baby away !" .s
     .l
     end
   ; define-function

   kkk
   #+end_src
* more syntax for definer
** if & else & then                   :syntax:
*** 記 條件轉跳
    * one predicate can make two branchs
      three predicates can make four branchs
      three predicates may only make three branchs
      but indeed there must be an invisible branch
*** word:[if|else|then]?
    #+begin_src cicada-nymph :tangle core.cn
    : word:if?
      << word[address, length] -- bool >>
      "if" string-equal?
      end
    ; define-function

    : word:else?
      << word[address, length] -- bool >>
      "else" string-equal?
      end
    ; define-function

    : word:then?
      << word[address, length] -- bool >>
      "then" string-equal?
      end
    ; define-function
    #+end_src
*** syntax,[if|else|then],make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,if,make-jojo
      << jo, string[address, length], word:if --
         address, jo, string[address, length] >>
      drop2
      jo instruction,false?branch
        jojo-area,stay
      *jojo-area,current-free-address* xxx|swap|x
      0 jojo-area,stay
      end
    ; define-function

    : syntax,else,make-jojo
      << address, jo, string[address, length], word:else --
         address, jo, string[address, length] >>
      drop2
      jo instruction,branch
         jojo-area,stay
      x|swap|xxx
      *jojo-area,current-free-address* xxxx|swap|x
      0 jojo-area,stay
      << address, string[address, length], address >>
      *jojo-area,current-free-address*
      over sub *jo-size* div
      swap set
      end
    ; define-function

    : syntax,then,make-jojo
      << address, jo, string[address, length], word:then --
         jo, string[address, length] >>
      drop2
      x|swap|xxx
      *jojo-area,current-free-address*
      over sub *jo-size* div
      swap set
      end
    ; define-function
    #+end_src
** test if & else & then
   #+begin_src cicada-nymph
   : .12
     << 1 2 -- >>
     2 equal? if
       "(^-^)" .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     else
       "     " .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     then
     end
   ; define-function

   : .12,test
     .l
     1 2 .12 .l
     6 2 .12 .l
     1 6 .12 .l
     6 6 .12 .l
     end
   ; define-function
   .12,test
   #+end_src
** test if & else & then [by factorial]
   #+begin_src cicada-nymph
   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 factorial
     mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function
   factorial,test
   #+end_src
** prepare-for                        :syntax:
*** word:prepare-for?
    #+begin_src cicada-nymph :tangle core.cn
    : word:prepare-for?
      << word[address, length] -- bool >>
      "prepare-for" string-equal?
      end
    ; define-function
    #+end_src
*** syntax,prepare-for,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,prepare-for,make-jojo
      << string[address, length], word:prepare-for --
         string[address, length] >>
      drop2
      jo instruction,prepare-for
        jojo-area,stay
      jo instruction,exception-head
        jojo-area,stay
      end
    ; define-function
    #+end_src
** exception-reset-stack              :syntax:
*** word:exception-reset-stack?
    #+begin_src cicada-nymph :tangle core.cn
    : word:exception-reset-stack?
      << word[address, length] -- bool >>
      "exception-reset-stack" string-equal?
      end
    ; define-function
    #+end_src
*** syntax,exception-reset-stack,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,exception-reset-stack,make-jojo
      << jo, string[address, length], word:exception-reset-stack --
         jo, string[address, length] >>
      drop2
      jo instruction,exception-reset-stack
        jojo-area,stay
      x|over|xx
        jojo-area,stay
      end
    ; define-function
    #+end_src
** loop                               :syntax:
*** word:loop?
    #+begin_src cicada-nymph :tangle core.cn
    : word:loop?
      << word[address, length] -- bool >>
      "loop" string-equal?
      end
    ; define-function
    #+end_src
*** syntax,loop,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,loop,make-jojo
      << jo, string[address, length], word:loop --
         jo, string[address, length] >>
      drop2
      jo tail-call
        jojo-area,stay
      x|over|xx
        jojo-area,stay
      end
    ; define-function
    #+end_src
** recur                              :syntax:
*** word:recur?
    #+begin_src cicada-nymph :tangle core.cn
    : word:recur?
      << word[address, length] -- bool >>
      "recur" string-equal?
      end
    ; define-function
    #+end_src
*** syntax,recur,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,recur,make-jojo
      << jo, string[address, length], word:recur --
         jo, string[address, length] >>
      drop2
      x|over|xx
        jojo-area,stay
      end
    ; define-function
    #+end_src
** test recur [by factorial]
   #+begin_src cicada-nymph
   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 recur mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function
   factorial,test


   : factorial,loop
     << counter, product -- product >>
     over one? if
       swap drop
       end
     then
     over mul
     swap sub1 swap
     loop
   ; define-function

   : factorial
     << number -- number >>
     1 factorial,loop
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function
   factorial,test
   #+end_src
** test recur [by fibonacci]
   #+begin_src cicada-nymph
   << 0 1 1 2 3 5 8 13 21 34 55 89 144 233 >>

   : fibonacci
     << number -- number >>
     dup zero? if
       end
     then
     dup one? if
       end
     then
     dup sub1 recur
     swap sub1 sub1 recur
     add
     end
   ; define-function

   : fibonacci,test
     .l
     0 fibonacci . .l
     1 fibonacci . .l
     2 fibonacci . .l
     3 fibonacci . .l
     4 fibonacci . .l
     5 fibonacci . .l
     6 fibonacci . .l
     7 fibonacci . .l
     8 fibonacci . .l
     9 fibonacci . .l
     10 fibonacci . .l
     11 fibonacci . .l
     12 fibonacci . .l
     13 fibonacci . .l
     14 fibonacci . .l
     15 fibonacci . .l
     16 fibonacci . .l
     17 fibonacci . .l
     18 fibonacci . .l
     19 fibonacci . .l
     20 fibonacci . .l
     end
   ; define-function
   fibonacci,test
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
     jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
     jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule

     jo word:prepare-for?
     jo syntax,prepare-for,make-jojo
     *rule-set,make-jojo* add-rule
     jo word:exception-reset-stack?
     jo syntax,exception-reset-stack,make-jojo
     *rule-set,make-jojo* add-rule

     jo word:loop?  jo syntax,loop,make-jojo  *rule-set,make-jojo* add-rule
     jo word:recur? jo syntax,recur,make-jojo *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
* name & name-hash-table
** note
   * the name-hash-table
     is used both in cicada-nymph and cicada-language
** allocate
*** note
    * an interface of *un-initialized-memory*
*** allocate-memory
    #+begin_src cicada-nymph :tangle core.cn
    : allocate-memory
      << size -- address >>
      dup *un-initialized-memory,current-free-address* clear-memory
      *un-initialized-memory,current-free-address* swap << address as return value >>
      address *un-initialized-memory,current-free-address* add-set
      end
    ; define-function
    #+end_src
** *name-hash-table*
   * the following are some prime number
     ready to be used
     * 1000003   about 976 k
     * 1000033
     * 1000333
     * 100003    about 97 k
     * 100333
     * 997
     * 499
   #+begin_src cicada-nymph :tangle core.cn
   100333
   << drop 13 >>
   : *name-hash-table,size*
   ; define-variable,with-tos

   *jo-size* 5 mul
   : *name-hash-table,unit*
   ; define-variable,with-tos

   *name-hash-table,size*
   *name-hash-table,unit* mul allocate-memory
   : *name-hash-table*
   ; define-variable,with-tos

   0
   : *name-hash-table,counter*
   ; define-variable,with-tos
   #+end_src
** *name-hash-table,string-area*
   #+begin_src cicada-nymph :tangle core.cn
   *name-hash-table,size* 32 mul
   : *name-hash-table,string-area,size*
   ; define-variable,with-tos

   *name-hash-table,string-area,size*
   allocate-memory
   : *name-hash-table,string-area*
   ; define-variable,with-tos

   *name-hash-table,string-area*
   : *name-hash-table,string-area,current-free-address*
   ; define-variable,with-tos
   #+end_src
** name-hash-table,string-area,stay
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,string-area,stay
     << string[address, length] -- >>
     tuck
     *name-hash-table,string-area,current-free-address*
     string->buffer!
     address *name-hash-table,string-area,current-free-address*
     add-set
     end
   ; define-function
   #+end_src
** make-string,for-name
   #+begin_src cicada-nymph :tangle core.cn
   : make-string,for-name
     << string[address, length] -- string-copy[address, length] >>
     *name-hash-table,string-area,current-free-address*
     xx|swap|x
     tuck
     name-hash-table,string-area,stay
     end
   ; define-function
   #+end_src
** name
*** note
    * a name is an index into name-hash-table
    * an entry can be viewed
      1. as a point
      2. as an orbit
    * in a name entry we have the following fields
      |------+---------------------|
      | name | name-string-address |
      |      | name-string-length  |
      |------+---------------------|
      |      | orbit-length        |
      |      | orbiton             |
      |      | jo                  |
      |------+---------------------|
      1. name-string-address
         0 denotes name not used
      2. orbit-length
         as an orbit
         its length gets updated
      3. as a point
         it is on an orbit
      4. jo
         0 denotes name not used as jo
*** name->address
    #+begin_src cicada-nymph :tangle core.cn
    : name->address
      << name -- address >>
      *name-hash-table,unit* mul
      *name-hash-table* add
      end
    ; define-function
    #+end_src
*** name,used?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used?
      << name -- bool >>
      name->address
      get zero? false?
      end
    ; define-function
    #+end_src
*** name,used-as-jo?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used-as-jo?
      << name -- bool >>
      name->address
      *jo-size* 4 mul add
      get zero? not
      end
    ; define-function
    #+end_src
*** name->string
    #+begin_src cicada-nymph :tangle core.cn
    : name->string
      << name -- string[address, length] >>
      name->address
      2 n-get
      end
    ; define-function
    #+end_src
*** name,get-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,get-orbit-length
      << name -- orbit-length >>
      name->address
      *jo-size* 2 mul add
      get
      end
    ; define-function
    #+end_src
*** name,get-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,get-orbiton
      << name -- orbiton >>
      name->address
      *jo-size* 3 mul add
      get
      end
    ; define-function
    #+end_src
*** name,get-jo
    #+begin_src cicada-nymph :tangle core.cn
    : name,get-jo
      << name -- jo >>
      name->address
      *jo-size* 4 mul add
      get
      end
    ; define-function
    #+end_src
*** name,set-string
    #+begin_src cicada-nymph :tangle core.cn
    : name,set-string
      << string[address, length], name -- >>
      >:name
      make-string,for-name
      :name name->address
      2 n-set
      end
    ; define-function
    #+end_src
*** name,set-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,set-orbit-length
      << orbit-length, name -- >>
      name->address
      *jo-size* 2 mul add
      set
      end
    ; define-function
    #+end_src
*** name,set-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,set-orbiton
      << orbiton, name -- >>
      name->address
      *jo-size* 3 mul add
      set
      end
    ; define-function
    #+end_src
*** name,set-jo
    #+begin_src cicada-nymph :tangle core.cn
    : name,set-jo
      << jo, name -- >>
      name->address
      *jo-size* 4 mul add
      set
      end
    ; define-function
    #+end_src
*** name,no-collision?
    #+begin_src cicada-nymph :tangle core.cn
    : name,no-collision?
      << name -- bool >>
      dup name,get-orbiton
      equal?
      end
    ; define-function
    #+end_src
** name-hash-table
*** note interface
    * open addressing
      for we do not need to delete
    * math
      * hash
    * memory
      * insert
      * search
    * function
      * string->name
      * name->string
*** name-hash-table,hash
    * prime table size
    * linear probing
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,hash
      << number, counter -- index >>
      add *name-hash-table,size* mod
      end
    ; define-function
    #+end_src
*** string->finite-carry-sum
    #+begin_src cicada-nymph :tangle core.cn
    16
    : *max-carry-position*
    ; define-variable,with-tos

    : string->finite-carry-sum,loop
      << carry-sum, string[address, length], counter -- carry-sum >>
      over zero? if
        drop drop2
        end
      then
      dup *max-carry-position* greater-than? if
        drop 0 << re-start from 0 >>
      then
      xx|over|x
      string,byte over
      2 swap power
      mul
      x|swap|xxxx add xxx|swap|x
      add1 xx|swap|x
      string,byte-tail x|swap|xx
      loop
    ; define-function

    : string->finite-carry-sum
      << string[address, length] -- carry-sum >>
      0 xx|swap|x << carry-sum >>
      0 << counter >>
      string->finite-carry-sum,loop
      end
    ; define-function
    #+end_src
*** name-hash-table,search
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,search,loop
      << string[address, length], number, counter
         -- name, true
         -- name, false >>
      >:counter >:number >::string
      :number :counter name-hash-table,hash
      >:name
      :number 0 name-hash-table,hash
      >:orbit
      :name name,used? false? if
        :name false
        end
      then
      :name name->string
      ::string string-equal? if
        :name true
        end
      then
      :name name,get-orbit-length
      :counter equal? if
        :name false
        end
      then
      ::string
      :number :counter add1
      loop
    ; define-function

    : name-hash-table,search
      << string[address, length]
         -- name, true
         -- name, false >>
      dup2 string->finite-carry-sum
      0 name-hash-table,search,loop
      end
    ; define-function
    #+end_src
*** name-hash-table,insert
    * I found that (insert) can not re-use (search)
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,insert,loop
      << string[address, length], number, counter
         -- name, true
         -- name, false >>
      >:counter >:number >::string
      :number :counter name-hash-table,hash
      >:name
      :number 0 name-hash-table,hash
      >:orbit
      :name name,used? false? if
        ::string :name
        name,set-string
        :orbit :name
        name,set-orbiton
        :counter :orbit
        name,set-orbit-length
        1 address *name-hash-table,counter* add-set
        :name true
        end
      then
      :name name->string
      ::string string-equal? if
        :name true
        end
      then
      :counter *name-hash-table,size* equal? if
        :name false
        end
      then
      ::string
      :number
      :counter add1
      loop
    ; define-function

    : name-hash-table,insert
      << string[address, length]
         -- name, true
         -- name, false >>
      dup2 string->finite-carry-sum
      0 name-hash-table,insert,loop
      end
    ; define-function
    #+end_src
*** string->name
    * error handling here
    #+begin_src cicada-nymph :tangle core.cn
    : string->name
      << string[address, length] -- name >>
      name-hash-table,insert
      false? if
        "* (string->name) *name-hash-table* is full!" .s .l
        end
      then
      end
    ; define-function
    #+end_src
*** note about report
    * report point orbit by orbit
      in the following format
    * {index} string # orbit-lenght
      * {index} string
      * {index} string
      * {index} string
    * if used as title
      add a (AS TITLE) as postfix
*** name-hash-table,report
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,report,orbit
      << name, counter -- >>
      over name,get-orbit-length
      over less-than? if
        drop2
        end
      then
      over name->string string->finite-carry-sum
      over name-hash-table,hash
      dup name,get-orbiton
      << name, counter, new-name, orbiton >>
      x|over|xxx name->string string->finite-carry-sum
      0 name-hash-table,hash
      equal? if
        "  {" .s
        dup write-number
        "} " .s
        name->string .s
        .l
      else
        drop
      then
      add1
      loop
    ; define-function

    : name-hash-table,report,loop
      << name -- >>
      dup *name-hash-table,size* equal? if
        drop
        end
      then
      dup name,used? if
      dup name,no-collision? if
        << * {index} string # orbit-lenght >>
        "* {" .s
        dup write-number
        "} " .s
        dup name->string .s
        " # " .s
        dup name,get-orbit-length
        write-number
        .l
        dup 1 name-hash-table,report,orbit
      then
      then
      add1
      loop
    ; define-function

    : name-hash-table,report
      << -- >>
      0 name-hash-table,report,loop
      "* totally : " .s
      *name-hash-table,counter* write-number
      .l
      end
    ; define-function
    #+end_src
*** test
    * set *name-hash-table,size* to a small number [for example 13]
      then use the following function
      and (name-hash-table,report) to do test
    #+begin_src cicada-nymph
    : test,name-hash-table
      << -- >>
      "a-000" string->name . .l
      "a-111" string->name . .l
      "a-222" string->name . .l
      "a-333" string->name . .l
      "a-444" string->name . .l
      "a-555" string->name . .l
      "a-666" string->name . .l
      "a-777" string->name . .l
      "a-888" string->name . .l
      "a-999" string->name . .l
      "b-000" string->name . .l
      "b-111" string->name . .l
      "b-222" string->name . .l
      "b-333" string->name . .l
      "b-444" string->name . .l
      "b-555" string->name . .l
      "b-666" string->name . .l
      "b-777" string->name . .l
      "b-888" string->name . .l
      "b-999" string->name . .l
      end
    ; define-function
    test,name-hash-table

    name-hash-table,report
    #+end_src
*** name-hash-table,find-jo
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,find-jo
      << word[address, length]
         -- jo, true
         -- false >>
      name-hash-table,search if
      else
        drop
        false
        end
      then
      dup name,used-as-jo? if
        name,get-jo
        true
        end
      then
      drop
      false
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "add" name-hash-table,find-jo
    #+end_src
* name-record
** note global-naming-stack
   * (define-*) push
     (undo) pop
** note name-record
   * *global-naming-stack* contain name-record
   * structure
     | name-record | old-jo |
     |             | name   |
     |             | new-jo |
** *global-naming-stack*
   #+begin_src cicada-nymph :tangle core.cn
   100 1024 mul
   : *global-naming-stack,size*
   ; define-variable,with-tos

   3 *jo-size* mul
   : *global-naming-stack,unit*
   ; define-variable,with-tos

   *global-naming-stack,size*
   *global-naming-stack,unit* mul allocate-memory
   : *global-naming-stack*
   ; define-variable,with-tos

   *global-naming-stack*
   : *global-naming-stack,pointer*
   ; define-variable,with-tos
   #+end_src
** name-record,[get|set]-old-jo
   #+begin_src cicada-nymph :tangle core.cn
   : name-record,get-old-jo
     << name-record -- old-jo >>
     get
     end
   ; define-function

   : name-record,set-old-jo
     << old-jo, name-record -- >>
     set
     end
   ; define-function
   #+end_src
** name-record,[get|set]-name
   #+begin_src cicada-nymph :tangle core.cn
   : name-record,get-name
     << name-record -- name >>
     *jo-size* add get
     end
   ; define-function

   : name-record,set-name
     << name, name-record -- >>
     *jo-size* add set
     end
   ; define-function
   #+end_src
** name-record,[get|set]-new-jo
   #+begin_src cicada-nymph :tangle core.cn
   : name-record,get-new-jo
     << name-record -- new-jo >>
     *jo-size* 2 mul add get
     end
   ; define-function

   : name-record,set-new-jo
     << new-jo, name-record -- >>
     *jo-size* 2 mul add set
     end
   ; define-function
   #+end_src
** global-naming-stack,record-jo
   #+begin_src cicada-nymph :tangle core.cn
   : global-naming-stack,record-jo
     << jo, name -- >>
     dup name,get-jo
     *global-naming-stack,pointer* name-record,set-old-jo
     dup2 name,set-jo
     *global-naming-stack,pointer* name-record,set-name
     *global-naming-stack,pointer* name-record,set-new-jo
     *global-naming-stack,unit* address *global-naming-stack,pointer* add-set
     end
   ; define-function
   #+end_src
** global-naming-stack,delete-last-record
   #+begin_src cicada-nymph :tangle core.cn
   : global-naming-stack,delete-last-record
     << -- >>
     *global-naming-stack,unit*
     address *global-naming-stack,pointer*
     sub-set
     *global-naming-stack,pointer* name-record,get-old-jo
     *global-naming-stack,pointer* name-record,get-name
     name,set-jo
     end
   ; define-function
   #+end_src
** jo,find-name
   #+begin_src cicada-nymph :tangle core.cn
   : jo,find-name,loop
     << jo, current-record
        -- name, true
        -- false >>
     dup *global-naming-stack* equal? if
       drop2
       false
       end
     then
     *global-naming-stack,unit* sub
     dup >:name-record
     over
     :name-record name-record,get-new-jo equal? if
       drop2
       :name-record name-record,get-name
       true
       end
     then
     loop
   ; define-function

   : jo,find-name
     << jo
        -- name, true
        -- false >>
     *global-naming-stack,pointer*
     jo,find-name,loop
     end
   ; define-function
   #+end_src
** name-hash-table,record-jo,by-link
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,record-jo,by-link
     << link -- >>
     >:link
     :link link->jo
     :link link->name-string string->name
     global-naming-stack,record-jo
     end
   ; define-function
   #+end_src
* basic-REPL
** *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   1024 *jo-size* mul
   : *rule-set,basic-REPL,size*
   ; define-variable,with-tos

   << for cursor >>
   *jo-size* allocate-memory drop

   *rule-set,basic-REPL,size*
   allocate-memory
   : *rule-set,basic-REPL*
   ; define-variable,with-tos

   *rule-set,basic-REPL*
   *rule-set,basic-REPL* *jo-size* sub
   set
   #+end_src
** eval-word
   * to protect exception-jo from be called from basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : eval-word
     << word[address, length] -- unknown >>
     dup2 find-syntax if
       apply
       end
     then
     dup2
     name-hash-table,find-jo if
       dup exception-jo? if
         drop
         "* (eval-word) can not execute exception directly : " .s
         .s .l
         end
       then
       << function & primitive-function & variable >>
       xx|swap|x drop2
       apply
       end
     else
     "* (eval-word) meets undefined word : " .s
     .s .l
     then
     end
   ; define-function
   #+end_src
** !bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : !bye,basic-REPL
     << -- >>
     exception-reset-stack
     drop-syntax-stack
     end
   ; define-exception
   #+end_src
** syntax,bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,bye,basic-REPL
     << word:bye -- >>
     drop2
     !bye,basic-REPL
   ; define-function
   #+end_src
** basic-REPL                         :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : basic-REPL,loop
     << unknown -- unknown >>
     read-word
     eval-word
     loop
   ; define-function

   : basic-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     basic-REPL,loop
     end
   ; define-function
   #+end_src
** number with base
*** 記 原理
    * 現在 的 number 就只是 "integer" 而已
      更多的數的類型將在 cicada 中實現
    * 在 "integer" 這個函數中 我將只支持 對四種進位制的 字符串的 閱讀
      * 十進制
        10#1231
        10#-1231
        1231
        -1231
      * 二進制
        2#101001
        2#-101001
        2#-1011_1001
        "-" 和 "_" 的同時存在有點難讀
        此時可以用 2#1011_1001 negate
        也就是說雖然允許用 "-" 來表示負數
        但是不鼓勵這樣做
        之所以允許這樣做
        是因爲在打印負數的時候需要這種表示方式
        不能把 "-123" 打印成 "123 negate"
      * 八進制
        8#712537
        8#-712537
      * 十六進制
        16#f123acb3
        16#-F123ACB3
        大寫小寫字母都可以
    * one can use "_" to separate the number
      to make it more readable
      for example
      2#1111_0101_0001
    * actually, the base can be any 10 based number
      even greater then 36
      but when the base is greater then 36
      not all integer can be represented under this base
      for we only have 36 bytes
*** remove-byte!
    #+begin_src cicada-nymph :tangle core.cn
    : remove-byte!,loop
      << cursor, length, byte -- cursor >>
      >:byte
      >:length
      >:cursor
      :length zero? if
        :cursor
        end
      then
      :cursor get-byte :byte equal? if
        :cursor add1 :length sub1
        :cursor
        string->buffer!
        :cursor
        :length sub1
        :byte
      else
        :cursor add1
        :length sub1
        :byte
      then
      loop
    ; define-function

    : remove-byte!
      << string[address, length], byte -- string[address, length] >>
      x|over|xx >:address
      remove-byte!,loop >:cursor
      :address
      :cursor :address sub
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,remove-byte!
      << -- >>
      "2#1001_1001"
      "_" string,byte
      remove-byte! .s << 2#1001_1001 >>
      .l
      "___2#1001___1001___"
      "_" string,byte
      remove-byte! .s << 2#1001_1001 >>
      .l
      end
    ; define-function
    test,remove-byte!
    #+end_src
*** latin-byte?
    #+begin_src cicada-nymph :tangle core.cn
    : latin-byte?
      << byte -- bool >>
      dup "A" string,byte less-than? if
        drop false
        end
      then
      dup "Z" string,byte less-or-equal? if
        drop true
        end
      then
      dup "a" string,byte less-than? if
        drop false
        end
      then
      dup "z" string,byte less-or-equal? if
        drop true
        end
      then
      drop false
      end
    ; define-function
    #+end_src
*** latin-byte->number
    #+begin_src cicada-nymph :tangle core.cn
    : latin-byte->number
      << latin-byte -- number >>
      dup "A" string,byte less-than? if
        "* (latin-byte->number) the argument must be a latin-byte" .s .l
        "  but the following byte is less-than 'A' : " .s
        .i .l
        end
      then
      dup "Z" string,byte less-or-equal? if
        "A" string,byte
        sub
        10 add
        end
      then
      dup "a" string,byte less-than? if
        "* (latin-byte->number) the argument must be a latin-byte" .s .l
        "  but the following byte is less-than 'a' but greater-then 'Z' : " .s
        .i .l
        end
      then
      dup "z" string,byte less-or-equal? if
        "a" string,byte
        sub
        10 add
        end
      then
      "* (latin-byte->number) the argument must be a latin-byte" .s .l
      "  but the following byte is greater-then 'z' : " .s
      .i .l
      end
    ; define-function
    #+end_src
*** number->latin-byte
    #+begin_src cicada-nymph :tangle core.cn
    : number->latin-byte
      << number -- latin-byte >>
      10 sub
      "a" string,byte
      add
      end
    ; define-function
    #+end_src
*** wild-digit-string?
    #+begin_src cicada-nymph :tangle core.cn
    : wild-digit-string?
      << string[address, length] -- bool >>
      dup zero? if
        drop2 true
        end
      then
      over get-byte
      dup digit-byte?
      swap latin-byte?
      or if
        string,byte-tail
        loop
      then
      drop2
      false
      end
    ; define-function
    #+end_src
*** wild-integer-string?
    #+begin_src cicada-nymph :tangle core.cn
    : wild-integer-string?
      << string[address, length] -- bool >>
      dup zero? if
        drop2 false
        end
      then
      dup2 string,byte
      "-" string,byte
      equal? if
        string,byte-tail
        wild-digit-string?
        end
      then
      wild-digit-string?
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,wild-integer-string?
      << -- >>
      "" wild-integer-string? . << 1 >>
      .l
      " " wild-integer-string? . << 0 >>
      "_asd" wild-integer-string? . << 0 >>
      " asd" wild-integer-string? . << 0 >>
      .l
      "asd" wild-integer-string? . << 1 >>
      "123" wild-integer-string? . << 1 >>
      "123asd" wild-integer-string? . << 1 >>
      .l
      end
    ; define-function
    test,wild-integer-string?
    #+end_src
*** base#wild-integer-string?
    * a string for the following format
      is viewed as a base#digit-string
      <digit-string>#[-]<wild-integer-string-string>
      any "_" in the anywhere of the above string
      will be ignored
    #+begin_src cicada-nymph :tangle core.cn
    : base#wild-integer-string?
      << string[address, length] -- bool >>
      128 allocate-local-memory
      >:string-address
      tuck
      :string-address
      string->buffer!
      :string-address swap
      "_" string,byte
      remove-byte!
      >:new-string-length
      >:new-string-address
      << dup2 .s .l 0 end >>
      :new-string-address
      :new-string-length
      "#" string,byte
      string,find-byte if
      else
        false
        end
      then
      >:address-of-#
      :new-string-address
      :address-of-# :new-string-address sub
      >::base-string
      :address-of-# add1
      :address-of-# :new-string-address sub add1
      :new-string-length swap sub
      >::wild-integer-string
      ::base-string digit-string?
      ::base-string empty-string? not
      and if
      else
        false
        end
      then
      ::wild-integer-string wild-integer-string?
      ::wild-integer-string empty-string? not
      and if
        true
      else
        false
      then
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,base#wild-integer-string?
      << -- >>
      "#" base#wild-integer-string? . << 0 >>
      "##" base#wild-integer-string? . << 0 >>
      "#___#" base#wild-integer-string? . << 0 >>
      "   " base#wild-integer-string? . << 0 >>
      "______#__1______" base#wild-integer-string? . << 0 >>
      "___2___#__1___c29bf210019___漢字" base#wild-integer-string? . << 0 >>
      .l
      "1#1" base#wild-integer-string? . << 1 >>
      "123#1c29bf219g42" base#wild-integer-string? . << 1 >>
      "___2___#__1___c29bf210019___g42" base#wild-integer-string? . << 1 >>
      .l
      end
    ; define-function
    test,base#wild-integer-string?
    #+end_src
*** base#wild-integer-string->base-string
    #+begin_src cicada-nymph :tangle core.cn
    : base#wild-integer-string->base-string
      << string[address, length] -- string[address, length] >>
      >:length
      >:address
      :address
      :length
      "#" string,byte
      string,find-byte if
      else
        "* (base#wild-integer-string->base-string)" .s .l
        "  the argument must be a base#wild-integer-string" .s .l
        "  but the following string does not even have a '#' in it :" .s .l
        "  " .s
        :address :length .s .l
        << to balance the argument-stack or not ??? >>
        << :address :length >>
        end
      then
      >:address-of-#
      :address
      :address-of-# :address sub
      end
    ; define-function
    #+end_src
*** base#wild-integer-string->wild-integer-string
    #+begin_src cicada-nymph :tangle core.cn
    : base#wild-integer-string->wild-integer-string
      << string[address, length] -- string[address, length] >>
      >:length
      >:address
      :address
      :length
      "#" string,byte
      string,find-byte if
      else
        "* (base#wild-integer-string->wild-integer-string)" .s .l
        "  the argument must be a base#wild-integer-string" .s .l
        "  but the following string does not even have a '#' in it :" .s .l
        "  " .s
        :address :length .s .l
        << to balance the argument-stack or not ??? >>
        << :address :length >>
        end
      then
      >:address-of-#
      :address-of-# add1
      :address-of-# :address sub add1
      :length swap sub
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,base#wild-integer-string->base-string
      << -- >>
      "___2___ __1___c29bf210019___漢字" base#wild-integer-string->base-string
      .l
      "1#1" base#wild-integer-string->base-string .s .l << 1 >>
      "123#1c29bf219g42" base#wild-integer-string->base-string .s .l << 123 >>
      "___2___#__1___c29bf210019___g42" base#wild-integer-string->base-string .s .l << ___2___ >>
      .l
      end
    ; define-function
    test,base#wild-integer-string->base-string

    : test,base#wild-integer-string->wild-integer-string
      << -- >>
      "___2___ __1___c29bf210019___漢字" base#wild-integer-string->wild-integer-string
      .l
      "1#1" base#wild-integer-string->wild-integer-string .s .l << 1 >>
      "123#1c29bf219g42" base#wild-integer-string->wild-integer-string .s .l << 1c29bf219g42 >>
      "___2___#__1___c29bf210019___g42" base#wild-integer-string->wild-integer-string .s .l << __1___c29bf210019___g42 >>
      .l
      end
    ; define-function
    test,base#wild-integer-string->wild-integer-string
    #+end_src
*** wild-integer-string->integer,with-base
    #+begin_src cicada-nymph :tangle core.cn
    : wild-integer-string->integer,with-base,loop
      << string[address, length], base, sum, counter -- integer >>
      >:counter
      >:sum
      >:base
      >:length
      >:address
      :length zero? if
        :sum
        end
      then
      :address get-byte >:byte
      :byte digit-byte? if
        :byte digit-byte->number
      then
      :byte latin-byte? if
        :byte latin-byte->number
      then
      :base :counter power
      mul
      :sum add
      >:sum
      :address add1
      :length sub1
      :base
      :sum
      :counter add1
      loop
    ; define-function

    : wild-integer-string->integer,with-base
      << string[address, length], base -- integer >>
      >:base
      dup zero? if
        drop2
        0
        end
      then
      dup2 string,byte
      "-" string,byte
      equal? if
        string,byte-tail
        -1 >:sign
      else
        1 >:sign
      then
      >::string
      ::string string-reverse!
      :base
      0 0 wild-integer-string->integer,with-base,loop
      :sign mul
      ::string string-reverse!
      drop2
      end
    ; define-function
    #+end_src
*** base#wild-integer-string->integer
    #+begin_src cicada-nymph :tangle core.cn
    : base#wild-integer-string->integer
      << string[address, length] -- integer >>
      128 allocate-local-memory
        >:address
      tuck :address string->buffer!
        >:length
      :address :length
      "_" string,byte remove-byte!
        >::string
      ::string
      base#wild-integer-string->base-string
        >::base-string
      ::string
      base#wild-integer-string->wild-integer-string
        >::wild-integer-string
      ::base-string
      digit-string->number
        >:base
      ::wild-integer-string
      :base
      wild-integer-string->integer,with-base
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,base#wild-integer-string->integer
      << -- >>
      "0#111" base#wild-integer-string->integer .
      0 0 power 1 mul
      0 1 power 1 mul add
      0 2 power 1 mul add .
      .l
      "1#111" base#wild-integer-string->integer .
      1 0 power 1 mul
      1 1 power 1 mul add
      1 2 power 1 mul add .
      .l
      "10#123" base#wild-integer-string->integer .
      "_1_0__#_1__2_3_" base#wild-integer-string->integer .
      10 0 power 3 mul
      10 1 power 2 mul add
      10 2 power 1 mul add .
      .l
      "2#1000" base#wild-integer-string->integer .
      "2#_1000_" base#wild-integer-string->integer .
      2 0 power 0 mul
      2 1 power 0 mul add
      2 2 power 0 mul add
      2 3 power 1 mul add .
      .l
      "2#1111_1111" base#wild-integer-string->integer .
      2 0 power 1 mul
      2 1 power 1 mul add
      2 2 power 1 mul add
      2 3 power 1 mul add
      2 4 power 1 mul add
      2 5 power 1 mul add
      2 6 power 1 mul add
      2 7 power 1 mul add .
      "16#f_f" base#wild-integer-string->integer .
      16 0 power 15 mul
      16 1 power 15 mul add .
      .l
      "100#111" base#wild-integer-string->integer .
      100 0 power 1 mul
      100 1 power 1 mul add
      100 2 power 1 mul add .
      .l
      "64#zzz" base#wild-integer-string->integer .
      64 0 power 35 mul
      64 1 power 35 mul add
      64 2 power 35 mul add .
      .l
      "36#zzzz" base#wild-integer-string->integer .
      36 0 power 35 mul
      36 1 power 35 mul add
      36 2 power 35 mul add
      36 3 power 35 mul add .
      .l
      end
    ; define-function
    test,base#wild-integer-string->integer
    #+end_src
*** note writers
    * a general function
      and three special ones
    * they all writer integer
    * I will implemented them by syntax when needed
*** .#
    #+begin_src cicada-nymph :tangle core.cn
    : .#,loop
      << number, base, cursor -- cursor >>
      >:cursor
      >:base
      >:number
      :number zero? if
        :cursor
        end
      then
      :number
      :base
      divmod >:mod >:div
      :mod 10 less-than? if
        :mod number->digit-byte
      else
        :mod number->latin-byte
      then
      :cursor
      set-byte
      :div
      :base
      :cursor add1
      loop
    ; define-function

    : .#
      << integer, base -- >>
      over zero? if
        drop .i
        end
      then
      dup 36 greater-than?
      over 2 less-than?
      or if
        "* (.#) the base " .s .i " is not valid to write a number" .s .l
        "  a base should in between 2 and 36 includingly" .s .l
        "  the integer to be written is " .s .i .l
        end
      then
      dup .i
      "#" .s
      over negative? if
        swap negate swap
        "-" .s
      then
      128 allocate-local-memory >:buffer
      :buffer
      .#,loop >:cursor
      :buffer
      :cursor :buffer sub
      string-reverse! .s
      end
    ; define-function
    #+end_src
*** .#2 .#8 .#16
    #+begin_src cicada-nymph :tangle core.cn
    : .#2  2  .# " " .s end ; define-function
    : .#8  8  .# " " .s end ; define-function
    : .#16 16 .# " " .s end ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    0#111        0  .#
    1#111        1  .#
    10#123       10 .#
    10#0         10 .#
    2#1000       2  .#
    2#1111_1111  2  .#
    16#f_f       16 .#
    36#zzzz      36 .#

    2#1111_1111  .#2
    8#123        .#8
    16#fff       .#16
    #+end_src
*** 記 bit-xor
    * 對 bit-xor 的解釋
      1. 對稱地看
         diff
      2. 非對稱地看
         後者是 1 則 求 invert
      結構上 對於同樣的抽象函數
      認識上 可以有不同的理解方式
*** 記 gamber
    * gray code 很有趣
      尤其是其生成方式
      即 先取對稱 再加前綴
      是利用 對稱性 和 不變量[不變性] 的典型例子
    * 同樣的一個 0 1 字符串
      比如 "100"
      把它做爲自然編碼的二進制數 其值爲 4 這個是 number
      把它做爲 gray code 編碼的二進制數 其值爲 7 這個我稱之爲 gamber
    * 這樣 我們就有如下兩個函數
      string->number
      string->gamber
      同時這兩個函數還引出了下面兩個函數
      number->gamber
      gamber->number
    * 下面的的算法是通過把數字列表之後
      逐 bit 觀察每列的接連 bit 值的規則而得來的
      比如
      以生成規則爲定義
      然後總結一下所發現的每一列的規律
      就可以得到對下面的算法的有效性的嚴格證明
    * 注意
      兩個方向的運算迥然不同
      還是要以生成方式爲核心來理解這一點
      只要把生成過程中
      每次在做完對稱後
      所添加的 一串前綴 1 看成是一個整體
      就能理解了
      可以把每次的 一串前綴 1 看成是一根棍子
      一根棍子 一根棍子 地 來觀察所生成的列表 就行了
      可以發現
      棍子 其實就是 自然編碼時
      逐 bit 觀察列表時的 接連 bit 值
      那麼就能理解到
      爲什麼 number->gamber 比 gamber->number 容易計算了
    * 另外還要注意
      從最高位向最低位去計算
      是爲了逐步確定數在序關係中的位置
*** number->gamber
    #+begin_src cicada-nymph :tangle core.cn
    : number->gamber
      << number -- gamber >>
      dup 1 bit-right
      bit-xor
      end
    ; define-function
    #+end_src
*** gamber->number
    #+begin_src cicada-nymph :tangle core.cn
    : gamber->number,loop
      << gamber, number, cursor -- number >>
      dup negative? if
        drop
        swap drop
        end
      then
      >:cursor
      >:number
      >:gamber
      :gamber :cursor get-bit
      :number :cursor add1 get-bit
      xor if
        :number :cursor set-bit >:number
      then
      :gamber
      :number
      :cursor sub1
      loop
    ; define-function

    : gamber->number
      << gamber -- number >>
      dup find-highest-set-bit
      dup negative? if
        drop
        end
      then
      0 over set-bit
      swap sub1
      gamber->number,loop
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test,gamber
      << -- >>
      2#0000 number->gamber .#2 .l
      2#0001 number->gamber .#2 .l
      2#0010 number->gamber .#2 .l
      2#0011 number->gamber .#2 .l
      2#0100 number->gamber .#2 .l
      2#0101 number->gamber .#2 .l
      2#0110 number->gamber .#2 .l
      2#0111 number->gamber .#2 .l
      2#1000 number->gamber .#2 .l
      2#1001 number->gamber .#2 .l
      2#1010 number->gamber .#2 .l
      2#1011 number->gamber .#2 .l
      2#1100 number->gamber .#2 .l
      2#1101 number->gamber .#2 .l
      2#1110 number->gamber .#2 .l
      2#1111 number->gamber .#2 .l
      .l
      2#0000 number->gamber gamber->number .#2 .l
      2#0001 number->gamber gamber->number .#2 .l
      2#0010 number->gamber gamber->number .#2 .l
      2#0011 number->gamber gamber->number .#2 .l
      2#0100 number->gamber gamber->number .#2 .l
      2#0101 number->gamber gamber->number .#2 .l
      2#0110 number->gamber gamber->number .#2 .l
      2#0111 number->gamber gamber->number .#2 .l
      2#1000 number->gamber gamber->number .#2 .l
      2#1001 number->gamber gamber->number .#2 .l
      2#1010 number->gamber gamber->number .#2 .l
      2#1011 number->gamber gamber->number .#2 .l
      2#1100 number->gamber gamber->number .#2 .l
      2#1101 number->gamber gamber->number .#2 .l
      2#1110 number->gamber gamber->number .#2 .l
      2#1111 number->gamber gamber->number .#2 .l
      .l
      end
    ; define-function
    test,gamber
    #+end_src
** init,rule-set,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : init,rule-set,basic-REPL
     << -- >>
     jo integer-string?
     jo string->integer
     *rule-set,basic-REPL* add-rule

     jo base#wild-integer-string?
     jo base#wild-integer-string->integer
     *rule-set,basic-REPL* add-rule
     end
   ; define-function

   init,rule-set,basic-REPL
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111
   0 0 power 1 mul
   0 1 power 1 mul add
   0 2 power 1 mul add
   . .

   1#111
   1 0 power 1 mul
   1 1 power 1 mul add
   1 2 power 1 mul add
   . .

   10#123
   _1_0__#_1__2_3_
   10 0 power 3 mul
   10 1 power 2 mul add
   10 2 power 1 mul add
   . . .

   2#1000
   2#_1000_
   2 0 power 0 mul
   2 1 power 0 mul add
   2 2 power 0 mul add
   2 3 power 1 mul add
   . . .

   2#1111_1111
   2 0 power 1 mul
   2 1 power 1 mul add
   2 2 power 1 mul add
   2 3 power 1 mul add
   2 4 power 1 mul add
   2 5 power 1 mul add
   2 6 power 1 mul add
   2 7 power 1 mul add
   . .

   16#f_f
   16 0 power 15 mul
   16 1 power 15 mul add
   . .

   100#111
   100 0 power 1 mul
   100 1 power 1 mul add
   100 2 power 1 mul add
   . .

   64#zzz
   64 0 power 35 mul
   64 1 power 35 mul add
   64 2 power 35 mul add
   . .

   36#zzzz
   36 0 power 35 mul
   36 1 power 35 mul add
   36 2 power 35 mul add
   36 3 power 35 mul add
   . .
   #+end_src
* define-function
** <word>?
   #+begin_src cicada-nymph :tangle core.cn
   : <word>?
     << string[address, length] -- bool >>
     dup 2 less-or-equal? if
       drop2
       false
       end
     then
     dup2 string-end,byte
     ">" string-end,byte equal? not if
       drop2
       false
       end
     then
     string,byte
     "<" string,byte equal?
     end
   ; define-function
   #+end_src
** make-jojo                          :redefine:
*** 記 ad hoc
    * 這裏對 name-hash-table 的 undo 是 ad hoc
      因爲沒法重新定義 (!undo-make-jojo)
      因爲有太多的函數調用它了
    * 只有當有自己的匯編器的時候 才能解除這個 ad hoc
    * 並且
      此時只有對 *link* 的 undo
      但是沒有對 (define-function,with-title) 中的
      :address,link,title 的 undo
      這是錯誤的 這導致 :address,link,title 在不必要地增長
      但是這不是知名的錯誤
      因爲
      在調用的時候 用的是 name-hash-table 來做查找
      而不是用 link 來查找
*** make-jojo,dispatch-word
    #+begin_src cicada-nymph :tangle core.cn
    : make-jojo,dispatch-word
      << jo, string[address, length], word[address, length] --
         jo, string[address, length] >>
      dup2 find-syntax if
        apply
        end
      then
      dup2 name-hash-table,find-jo if
        xx|swap|x drop2
        jojo-area,stay
        end
      then
      "* (make-jojo) meets undefined word : " .s .s .l
      global-naming-stack,delete-last-record
      !undo-make-jojo
    ; define-function
    #+end_src
*** make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : make-jojo,loop
      << jo, string[address, length] -- >>
      dup2 space-string? if
        drop2
        drop
        end
      then
      dup2
      string,word-tail
      xx|swap|xx
      string,word
      make-jojo,dispatch-word
      loop
    ; define-function

    : make-jojo
      << jo, string[address, length] -- >>
      local-variable-table,clear
      *rule-set,make-jojo*
      push-syntax-stack
      make-jojo,loop
      drop-syntax-stack
      end
    ; define-function
    #+end_src
** init,name-hash-table,by-link
   * the function should be executed right after
     (define-function) is redefined
   * be ware of
     the interface of (name-hash-table,search)
   * I simply implement it as a recursive function
   #+begin_src cicada-nymph :tangle core.cn
   : init,name-hash-table,by-link
     << link -- >>
     >:link
     :link zero? if
       end
     then
     :link link->next-link recur
     :link name-hash-table,record-jo,by-link
     end
   ; define-function
   #+end_src
** n-string->buffer!
   * this function return length
   #+begin_src cicada-nymph :tangle core.cn
   : n-string->buffer!,loop
     << string-1[address, length],
        ...
        string-2[address, length],
        buffer, n, cursor
        -- length >>
     >:cursor
     >:n
     >:buffer
     :n zero? if
       :buffer
       :cursor :buffer sub
       string-reverse!
       swap drop
       end
     then
     dup zero? if
       drop2
       :buffer
       :n sub1
       :cursor
       loop
     then
     dup2 add sub1 get-byte :cursor set-byte
     sub1
     :buffer
     :n
     :cursor add1
     loop
   ; define-function

   : n-string->buffer!
     << string-1[address, length],
        ...
        string-2[address, length],
        buffer, n
        -- length >>
     over n-string->buffer!,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : *test,buffer*
     512 allocate-memory
   ; define-variable

   "/home" "/xyh" "/cicada"
   *test,buffer*
   3 n-string->buffer!
   *test,buffer* swap
   .s
   #+end_src
** define-function               :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : define-function
     << string[address, length] -- >>
     *string-area,current-free-address* xx|swap|x
     *jojo-area,current-free-address* xx|swap|x
     *link* xx|swap|x
     << *string-area,current-free-address*
        *jojo-area,current-free-address*
        *link*
        string[address, length] >>
     prepare-for
       !undo-make-jojo
       end

     dup2 >::string

     ::string string,word >::title
     ::string string,word-tail string,word >::name
     ::string string,word-tail string,word-tail >::body

     ::title " " ::name
     512 allocate-local-memory dup >:buffer
     3 n-string->buffer! >:length
     :buffer :length >::name
     ::title <word>? not if
       ::string string,word >::name
       ::string string,word-tail >::body
     then

     *explainer,function* 0
     make-jo-head >:jo

     :jo
     ::name string->name
     global-naming-stack,record-jo

     *jojo-area,current-free-address* >:old-address

     :jo ::body make-jojo

     *jojo-area,current-free-address*
     :old-address sub *jo-size* div
     :jo jo,set-length

     drop2
     drop
     drop
     drop
     end
   ; define-function
   #+end_src
** test function
   #+begin_src cicada-nymph
   : k 1 2 3 add add . end ; define-function
   k

   : k 1 2 3 end ; define-function
   k add add .

   << error >>
   : k no end ; define-function


   << with-title >>
   : <test-title> test-name
     << -- >>
     "TEST" .s .l
     end
   ; define-function

   : test
     << -- >>
     <test-title> test-name
     end
   ; define-function

   test

   << error >>
   : <test-title> test-name,testing-undefine
     << -- >>
     testing-undefine
     "TEST" .s .l
     end
   ; define-function

   : test,testing-undefine
     << -- >>
     <test-title> test-name,testing-undefine
     end
   ; define-function

   test,testing-undefine
   #+end_src
* to use the new naming mechanism
  * 這裏的函數需要處理 鏈 中的重複定義的 珠
    重複定義者 只有很少的幾個
    一是 make-jojo 以及相關的
    一是 define-function
  #+begin_src cicada-nymph :tangle core.cn
  *link* init,name-hash-table,by-link
  basic-REPL
  #+end_src
* define-variable,with-tos
** define-variable,with-tos           :redefine:
   * not undo is needed for define-variable,with-tos
   #+begin_src cicada-nymph :tangle core.cn
   : define-variable,with-tos
     << value, string[address, length] -- >>
     >::string
     >:value

     ::string string,word >::title
     ::string string,word-tail string,word >::name

     ::title " " ::name
     512 allocate-local-memory dup >:buffer
     3 n-string->buffer! >:length
     :buffer :length >::name
     ::title <word>? not if
       ::title >::name
     then

     *explainer,variable* 0
     make-jo-head >:jo

     :jo
     ::name string->name
     global-naming-stack,record-jo

     1 :jo jo,set-length

     :value jojo-area,stay
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   233 : *three* ; define-variable,with-tos
   : add-three *three* add end ; define-function
   1 add-three . << 234 >>

   << you get the address of the variable *three*
      by add "address" in front of it >>
   : fix-*three* 3 address *three* set end ; define-function
   fix-*three*
   1 add-three . << 4 >>

   << with-title >>
   233 : <test-title> *three* ; define-variable,with-tos
   : add-three <test-title> *three* add end ; define-function
   1 add-three . << 234 >>
   #+end_src
* define-exception
** define-exception                   :redefine:
   #+begin_src cicada-nymph :tangle core.cn
   : define-exception
     << string[address, length] -- >>
     *string-area,current-free-address* xx|swap|x
     *jojo-area,current-free-address* xx|swap|x
     *link* xx|swap|x
     << *string-area,current-free-address*
        *jojo-area,current-free-address*
        *link*
        string[address, length] >>
     prepare-for
       !undo-make-jojo
       end

     dup2 >::string

     ::string string,word >::title
     ::string string,word-tail string,word >::name
     ::string string,word-tail string,word-tail >::body

     ::title " " ::name
     512 allocate-local-memory dup >:buffer
     3 n-string->buffer! >:length

     :buffer :length >::name

     ::title <word>? not if
       ::string string,word >::name
       ::string string,word-tail >::body
     then

     *explainer,exception* 0
     make-jo-head >:jo

     :jo
     ::name string->name
     global-naming-stack,record-jo

     *jojo-area,current-free-address* >:old-address

     :jo ::body make-jojo

     *jojo-area,current-free-address*
     :old-address sub *jo-size* div
     :jo jo,set-length

     drop2
     drop
     drop
     drop
     end
   ; define-function
   #+end_src
* alias
** note
   * there shall be no way to know a naming is an alias or not
** alias
   #+begin_src cicada-nymph :tangle core.cn
   : alias
     << alias[address, length], name[address, length] -- >>
     >::name >::alias
     ::name name-hash-table,find-jo if
     else
       "* (alias) fail" .s .l
       "  because can not find name in name-hash-table" .s .l
       "  alias : " .s ::alias .s .l
       "  name : " .s ::name .s .l
       end
     then
     >:jo
     :jo
     ::alias string->name
     global-naming-stack,record-jo
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "adba" "add" alias
   1 2 adba . << 3 >>

   "<test-title> add" "add" alias
   : test,alias
     1 2 <test-title> add .
     end
   ; define-function
   test,alias << 3 >>

   << error >>
   "ab" "ad" alias
   #+end_src
* rule-set
** test endianness of n-get & n-set
   * big-endian is used
     in memory
     | value-1 |
     | value-2 |
     | value-3 |
     on stack
     << value-1, value-2, value-3 >>
   #+begin_src cicada-nymph
   3 *jo-size* mul allocate-memory
   : *t*
   ; define-variable,with-tos

   1 2 3 *t* 3 n-set

   << re-occur when geting through >>
   *t* get .
   *t* *jo-size* add get .
   *t* *jo-size* 2 mul add get .

   *t* 3 n-get
   #+end_src
** list-rule
   * 最後寫到規則集合裏的 被最先打印出來
   * 下面的打印方式 看似有些不簡潔
     是因爲 我還沒有 integer->string 這樣的函數
     [因爲 沒有對字符串的動態內存管理]
   #+begin_src cicada-nymph :tangle core.cn
   : list-rule,loop
     << rule-set, cursor, counter -- >>
     xx|over|x equal? if
       drop drop2
       end
     then
     "  * " .s
     "(" .s
     add1 dup .i
     ")" .s .l
     swap
       dup cursor->predicate
       "    " .s jo,find-name if name->string else "  unnamed jo" then .s .l
       dup cursor->function
       "    " .s jo,find-name if name->string else "  unnamed jo" then .s .l
       *jo-size* sub *jo-size* sub
     swap
     loop
   ; define-function

   : list-rule
     << rule-set -- >>
     dup rule-set,get-border
     0 list-rule,loop
     end
   ; define-function
   #+end_src
** sub-rule
   * firstly
     in (sub-rule,loop)
     cursor move from border down to address of rule-set
     secondly
     in (sub-rule,move)
     cursor move from founded place up to border
   #+begin_src cicada-nymph :tangle core.cn
   : sub-rule,move-one
     << cursor -- >>
     >:cursor
     :cursor 2 n-get
     :cursor *jo-size* 2 mul sub
     2 n-set
     end
   ; define-function

   : sub-rule,move
     << rule-set, cursor -- >>
     >:cursor
     >:rule-set
     :rule-set rule-set,get-border >:border
     :cursor :border equal? if
       :border *jo-size* 2 mul sub
       :rule-set
       rule-set,set-border
       end
     then
     :cursor sub-rule,move-one
     :rule-set
     :cursor *jo-size* 2 mul add
     loop
   ; define-function

   : sub-rule,loop
     << rule[predicate, function], rule-set, cursor -- >>
     >:cursor
     >:rule-set
     >::rule
     :cursor :rule-set equal? if
       end
     then
     ::rule :cursor cursor->rule equal2? if
       :rule-set :cursor
       sub-rule,move
       end
     then
     ::rule
     :rule-set
     :cursor *jo-size* 2 mul sub
     loop
   ; define-function

   : sub-rule
     << rule[predicate, function], rule-set -- >>
     dup rule-set,get-border
     sub-rule,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   *rule-set,basic-REPL* list-rule

   jo word:address?
   jo <basic-REPL-syntax> address
   *rule-set,basic-REPL* add-rule
   jo word:double-quote?
   jo <basic-REPL-syntax> double-quote
   *rule-set,basic-REPL* add-rule
   *rule-set,basic-REPL* list-rule

   jo word:address?
   jo <basic-REPL-syntax> address
   *rule-set,basic-REPL* sub-rule
   *rule-set,basic-REPL* list-rule

   jo word:double-quote?
   jo <basic-REPL-syntax> double-quote
   *rule-set,basic-REPL* sub-rule
   *rule-set,basic-REPL* list-rule
   #+end_src
* more syntax for definer
** <title>                            :syntax:
*** note
    * <title> in *rule-set,make-jojo*
      <title> name
      set a jo into *jojo-area*
    * <title> in *rule-set,basic-REPL*
      <title> name
      execute a jo
*** name-hash-table,find-jo,with-title
    #+begin_src cicada-nymph :tangle core.cn
    : name-hash-table,find-jo,with-title
      << title[address, length], word[address, length]
         -- jo, true
         -- false >>
      512 allocate-local-memory >:buffer
      " " xx|swap|xx
      :buffer
      3 n-string->buffer! >:length
      :buffer
      :length
      name-hash-table,search if
      else
        drop
        false
        end
      then
      dup name,used-as-jo? if
        name,get-jo
        true
        end
      then
      drop
      false
      end
    ; define-function
    #+end_src
*** syntax,title,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : syntax,title,make-jojo
      << jo, string[address, length], <title>[address, length] --
         jo, string[address, length] >>
      >::title
      >::string
      >:jo
      ::title ::string string,word
      name-hash-table,find-jo,with-title if
        jojo-area,stay
      else
        "* (syntax,title,make-jojo) meet undefined" .s .l
        "  title : " .s ::title .s .l
        "  name  : " .s ::string string,word .s .l
        global-naming-stack,delete-last-record
        !undo-make-jojo
      then
      :jo
      ::string string,word-tail
      end
    ; define-function
    #+end_src
*** more,rule-set,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : more,rule-set,make-jojo
      << -- >>
      jo <word>?
      jo syntax,title,make-jojo
      *rule-set,make-jojo* add-rule
      end
    ; define-function

    more,rule-set,make-jojo
    #+end_src
*** test
    #+begin_src cicada-nymph
    : <test-title> test-name
      << -- >>
      "TEST" .s .l
      end
    ; define-function

    : test
      << -- >>
      <test-title> test-name
      end
    ; define-function

    test


    : <test-title> test-name,testing-undefine
      << -- >>
      testing-undefine
      "TEST" .s .l
      end
    ; define-function

    : test,testing-undefine
      << -- >>
      <test-title> test-name,testing-undefine
      end
    ; define-function

    test,testing-undefine
    #+end_src
** unnamed function                   :syntax:
*** string,find-word
    #+begin_src cicada-nymph :tangle core.cn
    : string,find-word
      << string[address, length], word[address, length]
         -- sub-string[address, length], true
         -- false >>
      xx|over|xx space-string? if
        drop2 drop2
        false
        end
      then
      xx|over|xx string,word
      xx|over|xx string-equal? if
        drop2
        true
        end
      then
      xx|swap|xx string,word-tail
      xx|swap|xx
      loop
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "111 222 333" "222" string,find-word if
      string,word .s
    then

    "111 222 333" "444" string,find-word if
      string,word .s
    then

    "111 222 [] 333" "[" string,find-word if
      string,word .s
    then
    #+end_src
*** note side-effect
    * side-effect on function [unnamed or named] is actually not so needed
      for function is mainly used to encode algorithm
    * but side-effect on function is always possible when needed
*** note scope of named-local-variable
    * in named function or unnamed function
      the scope of named-local-variable is linear
*** word:square-bar?
    #+begin_src cicada-nymph :tangle core.cn
    : word:square-bar?
      << word[address, length] -- bool >>
      "[" string-equal?
      end
    ; define-function
    #+end_src
*** word:square-ket?
    #+begin_src cicada-nymph :tangle core.cn
    : word:square-ket?
      << word[address, length] -- bool >>
      "]" string-equal?
      end
    ; define-function
    #+end_src
*** note memory usage
    * for the array can be nested
      we must allocate the memory in place
      a branch is there helping us to achieve this
    * [dup drop end]
      |-------------------|
      | branch            |
      | offset to jo      |
      |-------------------|
      | <jo-head>         |
      |-------------------|
      | dup               |
      | drop              |
      | end               |
      |-------------------|
      | literal           |
      | address of the jo |
      |-------------------|
*** <make-jojo-syntax> square-bar
    #+begin_src cicada-nymph :tangle core.cn
    : <make-jojo-syntax> square-bar
      << jo, string[address, length], word:square-bar --
         jo, string[address, length] >>
      drop2
      >::string
      >:jo

      jo instruction,branch
        jojo-area,stay
      *jojo-area,current-free-address* >:offset-address
      0 jojo-area,stay

      *explainer,function* 0
      make-jo-head >:new-jo

      :offset-address
      :new-jo
      :jo
      ::string
      end
    ; define-function
    #+end_src
*** <make-jojo-syntax> square-ket
    #+begin_src cicada-nymph :tangle core.cn
    : <make-jojo-syntax> square-ket
      << offset-address, new-jo,
         jo, string[address, length], word:square-ket --
         jo, string[address, length] >>
      drop2
      >::string
      >:jo
      >:new-jo
      >:offset-address

      *jojo-area,current-free-address*
      :offset-address sub
      *jo-size* div
      :offset-address set

      jo instruction,literal
        jojo-area,stay
      :new-jo
        jojo-area,stay

      :jo
      ::string
      end
    ; define-function
    #+end_src
*** more,rule-set,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : more,rule-set,make-jojo
      << -- >>
      jo word:square-bar?
      jo <make-jojo-syntax> square-bar
      *rule-set,make-jojo* add-rule
      jo word:square-ket?
      jo <make-jojo-syntax> square-ket
      *rule-set,make-jojo* add-rule
      end
    ; define-function

    more,rule-set,make-jojo
    #+end_src
*** test [by factorial]
    #+begin_src cicada-nymph
    : test
      << -- >>
      ["here" .s .l end]
      end
    ; define-function
    test apply

    : factorial
      << number -- number >>
      [dup
       one? if
         end
       then
       dup sub1 recur
       mul
       end] apply
      end
    ; define-function

    : factorial,test
      .l
      1 factorial . .l
      2 factorial . .l
      3 factorial . .l
      4 factorial . .l
      5 factorial . .l
      6 factorial . .l
      7 factorial . .l
      8 factorial . .l
      9 factorial . .l
      10 factorial . .l
      11 factorial . .l
      12 factorial . .l
      13 factorial . .l
      14 factorial . .l
      15 factorial . .l
      16 factorial . .l
      17 factorial . .l
      18 factorial . .l
      19 factorial . .l
      20 factorial . .l
      end
    ; define-function
    factorial,test
    #+end_src
*** 記 大喜過望
    * 當有了匿名函數之後
      我就可以定義各種遞歸組合子來做函數式編程了
      但是 沒有類型編碼 也沒有動態內存管理
      cicada-nymph 中
      並沒有 鏈表 這個有趣的數據結構 用以實踐函數式編程
    * 需要做的是
      去尋找一些 有趣的
      能夠在 cicada-nymph 中以簡單方式實現的
      具有良好遞歸定義的數據結構
** name                               :syntax:
*** <make-jojo-syntax> name
    #+begin_src cicada-nymph :tangle core.cn
    : <make-jojo-syntax> name
      << string[address, length], word[address, length] --
         string[address, length] >>
      drop2
      jo instruction,literal
        jojo-area,stay
      dup2
      string,word
      string->name
        jojo-area,stay
      string,word-tail
      end
    ; define-function
    #+end_src
*** more,rule-set,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : more,rule-set,make-jojo
      << -- >>
      ["name" string-equal? end]
      jo <make-jojo-syntax> name
      *rule-set,make-jojo* add-rule
      end
    ; define-function

    more,rule-set,make-jojo
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test
      << -- >>
      name test-test-test name->string .s
      end
    ; define-function
    test
    #+end_src
** base#wild-integer-string           :syntax:
*** <make-jojo-syntax> base#wild-integer-string
    #+begin_src cicada-nymph :tangle core.cn
    : <make-jojo-syntax> base#wild-integer-string
      << string[address, length], word[address, length] --
         string[address, length] >>
      jo instruction,literal
        jojo-area,stay
      base#wild-integer-string->integer
        jojo-area,stay
      end
    ; define-function
    #+end_src
*** more,rule-set,make-jojo
    #+begin_src cicada-nymph :tangle core.cn
    : more,rule-set,make-jojo
      << -- >>
      jo base#wild-integer-string?
      jo <make-jojo-syntax> base#wild-integer-string
      *rule-set,make-jojo* add-rule
      end
    ; define-function

    more,rule-set,make-jojo
    #+end_src
*** test
    #+begin_src cicada-nymph
    : test
      << -- >>
      0#111
      0 0 power 1 mul
      0 1 power 1 mul add
      0 2 power 1 mul add
      . . .l

      1#111
      1 0 power 1 mul
      1 1 power 1 mul add
      1 2 power 1 mul add
      . . .l

      10#123
      _1_0__#_1__2_3_
      10 0 power 3 mul
      10 1 power 2 mul add
      10 2 power 1 mul add
      . . .l .

      2#1000
      2#_1000_
      2 0 power 0 mul
      2 1 power 0 mul add
      2 2 power 0 mul add
      2 3 power 1 mul add
      . . .l .

      2#1111_1111
      2 0 power 1 mul
      2 1 power 1 mul add
      2 2 power 1 mul add
      2 3 power 1 mul add
      2 4 power 1 mul add
      2 5 power 1 mul add
      2 6 power 1 mul add
      2 7 power 1 mul add
      . . .l

      16#f_f
      16 0 power 15 mul
      16 1 power 15 mul add
      . . .l

      100#111
      100 0 power 1 mul
      100 1 power 1 mul add
      100 2 power 1 mul add
      . . .l

      64#zzz
      64 0 power 35 mul
      64 1 power 35 mul add
      64 2 power 35 mul add
      . . .l

      36#zzzz
      36 0 power 35 mul
      36 1 power 35 mul add
      36 2 power 35 mul add
      36 3 power 35 mul add
      . . .l

      end
    ; define-function

    test
    #+end_src
* more syntax for REPL
** jo                                 :syntax:
*** <basic-REPL-syntax> jo
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> jo
      << word:jo -- jo >>
      drop2
      read-word
      >::word

      ::word <word>? if
        512 allocate-local-memory >:buffer
        ::word dup >:length
        :buffer string->buffer!
        1024 allocate-local-memory >:new-buffer
        :buffer :length " " read-word
        :new-buffer
        3 n-string->buffer! >:new-length
        :new-buffer :new-length >::word
      then

      ::word name-hash-table,find-jo if
        end
      then
      "* (<basic-REPL-syntax> jo) meet undefined word after jo : " .s ::word .s .l
      end
    ; define-function
    #+end_src
*** more,rule-set,basic-REPL
    #+begin_src cicada-nymph :tangle core.cn
    : more,rule-set,basic-REPL
      << -- >>
      ["bye" string-equal? end]
      jo syntax,bye,basic-REPL
      *rule-set,basic-REPL* add-rule

      ["jo" string-equal? end]
      jo <basic-REPL-syntax> jo
      *rule-set,basic-REPL* add-rule
      end
    ; define-function

    more,rule-set,basic-REPL
    #+end_src
** if & else & then                   :syntax:
*** note ending jo
    * you do not need to use ending jo
      in code blocks formed by if else then
      because in a REPL
      things are different from function body
      and there is no such thing as
      the end of a function body in the REPL
*** note executing (end) in REPL
    * when executing (end) in REPL
      nothing will happen
      this is because (eval-word) calls (end)
      and the jojo (eval-word) is pop out of return-stack
      just like meet (end) in the function-body of (eval-word)
*** <basic-REPL-syntax> if,meet-true
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> if,meet-true,else
      << -- >>
      read-word
      "then" string-equal? if
        end
      then
      loop
    ; define-function

    : <basic-REPL-syntax> if,meet-true
      << -- >>
      read-word
      dup2 "then" string-equal? if
        drop2
        end
      then
      dup2 "else" string-equal? if
        drop2
        <basic-REPL-syntax> if,meet-true,else
        end
      then
      eval-word
      loop
    ; define-function
    #+end_src
*** <basic-REPL-syntax> if,meet-false
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> if,meet-false,else
      << -- >>
      read-word
      dup2 "then" string-equal? if
        drop2
        end
      then
      eval-word
      loop
    ; define-function

    : <basic-REPL-syntax> if,meet-false
      << -- >>
      read-word
      dup2 "then" string-equal? if
        drop2
        end
      then
      dup2 "else" string-equal? if
        drop2
        <basic-REPL-syntax> if,meet-false,else
        end
      then
      drop2
      loop
    ; define-function
    #+end_src
*** <basic-REPL-syntax> if
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> if
      << bool, word:if -- >>
      drop2 if
        <basic-REPL-syntax> if,meet-true
      else
        <basic-REPL-syntax> if,meet-false
      then
      end
    ; define-function
    #+end_src
*** add-rule to *rule-set,basic-REPL*
    #+begin_src cicada-nymph :tangle core.cn
    jo word:if? jo <basic-REPL-syntax> if *rule-set,basic-REPL* add-rule
    #+end_src
*** test
    #+begin_src cicada-nymph
    one? if
      111 . .l
    then

    one? if
      111 . .l
    else
      666 . .l
    then
    #+end_src
** *circular-string-area*
*** note
    * no length in the area anymore
      [not like the string-area]
    * and ending each string here with a 0
*** allocate-memory
    #+begin_src cicada-nymph :tangle core.cn
    1024 1024 mul
    : *circular-string-area,size*
    ; define-variable,with-tos


    *circular-string-area,size* allocate-memory
    : *circular-string-area*
    ; define-variable,with-tos

    *circular-string-area*
    : *circular-string-area,current-free-address*
    ; define-variable,with-tos
    #+end_src
** double-quote                       :syntax:
*** circular-string-area,stay
    #+begin_src cicada-nymph :tangle core.cn
    : circular-string-area,stay
      << string[address, length] -- >>
      dup *circular-string-area,current-free-address* add
      *circular-string-area,size* *circular-string-area* add
      greater-or-equal? if
        *circular-string-area*
        address *circular-string-area,current-free-address* set
      then
      tuck
      *circular-string-area,current-free-address*
      string->buffer!
      address *circular-string-area,current-free-address*
      add-set
      0 *circular-string-area,current-free-address*
      set-byte
      1 address *circular-string-area,current-free-address*
      add-set
      end
    ; define-function
    #+end_src
*** <basic-REPL-syntax> double-quote
    * in ASCII encode double-quote is 34
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> double-quote,loop
      << cursor -- cursor >>
      read-byte
      dup 34 equal? if
        drop
        end
      then
      over set-byte
      add1
      loop
    ; define-function

    : <basic-REPL-syntax> double-quote
      << word:double-quote -- string[address, length] >>
      drop2
      1024 2 mul allocate-local-memory >:buffer
      :buffer
      <basic-REPL-syntax> double-quote,loop
      >:cursor
      *circular-string-area,current-free-address* >:address
      :buffer
      :cursor :buffer sub dup >:length
      circular-string-area,stay
      :address
      :length
      end
    ; define-function
    #+end_src
*** add-rule to *rule-set,basic-REPL*
    #+begin_src cicada-nymph :tangle core.cn
    jo word:double-quote? jo <basic-REPL-syntax> double-quote *rule-set,basic-REPL* add-rule
    #+end_src
*** test
    #+begin_src cicada-nymph
    one? if
      "111" .s .l
    then

    one? if
      "111" .s .l
    else
      "___" .s .l
    then
    #+end_src
** address                            :syntax:
*** <basic-REPL-syntax> address
    #+begin_src cicada-nymph :tangle core.cn
    0
    : <basic-REPL-syntax> *address,stack-balancer*
    ; define-variable,with-tos

    : <basic-REPL-syntax> address
      << word:address -- address >>
      drop2
      read-word
      >::word
      ::word <word>? if
        512 allocate-local-memory >:buffer
        ::word dup >:length
        :buffer string->buffer!
        1024 allocate-local-memory >:new-buffer
        :buffer :length " " read-word
        :new-buffer
        3 n-string->buffer! >:new-length
        :new-buffer :new-length >::word
      then

      ::word name-hash-table,find-jo if
      else
        "* (<basic-REPL-syntax> address) meet undefined word : " .s ::word .s .l
        address <basic-REPL-syntax> *address,stack-balancer*
        end
      then

      >:jo
      :jo variable-jo? if
      else
        "* (<basic-REPL-syntax> address) meet a not variable-jo : " .s ::word .s .l
        address <basic-REPL-syntax> *address,stack-balancer*
        end
      then
      :jo *jo-size* add
      end
    ; define-function
    #+end_src
*** add-rule to *rule-set,basic-REPL*
    #+begin_src cicada-nymph :tangle core.cn
    jo word:address?
    jo <basic-REPL-syntax> address
    *rule-set,basic-REPL* add-rule
    #+end_src
*** test
    #+begin_src cicada-nymph
    666
    address <basic-REPL-syntax> *address,stack-balancer* set
    <basic-REPL-syntax> *address,stack-balancer*

    << error >>
    address kkk
    #+end_src
** word:name?
   #+begin_src cicada-nymph :tangle core.cn
   : word:name?
     << word[address, length] -- bool >>
     "name" string-equal?
     end
   ; define-function
   #+end_src
** name                               :syntax:
*** <basic-REPL-syntax> name
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> name
      << word:name -- name >>
      drop2
      read-word
      >::word
      ::word <word>? if
        512 allocate-local-memory >:buffer
        ::word dup >:length
        :buffer string->buffer!
        1024 allocate-local-memory >:new-buffer
        :buffer :length " " read-word
        :new-buffer
        3 n-string->buffer! >:new-length
        :new-buffer :new-length >::word
      then

      ::word string->name
      end
    ; define-function
    #+end_src
*** add-rule to *rule-set,basic-REPL*
    #+begin_src cicada-nymph :tangle core.cn
    jo word:name?
    jo <basic-REPL-syntax> name
    *rule-set,basic-REPL* add-rule
    #+end_src
*** test
    #+begin_src cicada-nymph
    name add
    name->string .s .l

    name <basic-REPL-syntax> *name,stack-balancer*
    name->string .s .l

    name kkk
    name->string .s .l
    #+end_src
** <title>                            :syntax:
*** note
    * <title> in *rule-set,make-jojo*
      <title> name
      set a jo into *jojo-area*
    * <title> in *rule-set,basic-REPL*
      <title> name
      execute a jo
*** <basic-REPL-syntax> title
    #+begin_src cicada-nymph :tangle core.cn
    : <basic-REPL-syntax> title
      << <title>[address, length] -- unknown >>
      >::title
      512 allocate-local-memory >:buffer
      ::title :buffer string->buffer!
      :buffer ::title swap drop >::title

      read-word >::name
      ::title ::name
      name-hash-table,find-jo,with-title if
        apply
        end
      then
      "* (<basic-REPL-syntax> title) meet undefined" .s .l
      "  title : " .s ::title .s .l
      "  name  : " .s ::name .s .l
      end
    ; define-function
    #+end_src
*** add-rule to *rule-set,basic-REPL*
    #+begin_src cicada-nymph :tangle core.cn
    jo <word>?
    jo <basic-REPL-syntax> title
    *rule-set,basic-REPL* add-rule
    #+end_src
*** test
    #+begin_src cicada-nymph
    : <test-title> test-name
      << -- >>
      "TEST" .s .l
      end
    ; define-function
    <test-title> test-name
    #+end_src
* to define some alias
** <string>
   #+begin_src cicada-nymph :tangle core.cn
   "<string> byte" "string,byte" alias
   "<string> byte-tail" "string,byte-tail" alias
   "<string> byte-back" "string,byte-back" alias

   "<string> word" "string,word" alias
   "<string> word-begin" "string,word-begin" alias
   "<string> word-end" "string,word-end" alias
   "<string> word-tail" "string,word-tail" alias

   "<string> equal?" "string-equal?" alias

   "<string> space?" "space-string?" alias
   "<string> empty?" "empty-string?" alias

   "<string> find-byte" "string,find-byte" alias
   #+end_src
** *rule-set*
   #+begin_src cicada-nymph :tangle core.cn
   "<basic-REPL> *rule-set*" "*rule-set,basic-REPL*" alias
   "<make-jojo> *rule-set*" "*rule-set,make-jojo*" alias
   #+end_src
** syntax
   #+begin_src cicada-nymph :tangle core.cn
   "<make-jojo-syntax> title" "syntax,title,make-jojo" alias
   "<make-jojo-syntax> recur" "syntax,recur,make-jojo" alias
   "<make-jojo-syntax> loop" "syntax,loop,make-jojo" alias
   "<make-jojo-syntax> exception-reset-stack" "syntax,exception-reset-stack,make-jojo" alias
   "<make-jojo-syntax> prepare-for" "syntax,prepare-for,make-jojo" alias
   "<make-jojo-syntax> then" "syntax,then,make-jojo" alias
   "<make-jojo-syntax> else" "syntax,else,make-jojo" alias
   "<make-jojo-syntax> if" "syntax,if,make-jojo" alias
   "<make-jojo-syntax> local-variable-get" "syntax,local-variable-get,make-jojo" alias
   "<make-jojo-syntax> local-variable-set" "syntax,local-variable-set,make-jojo" alias
   "<make-jojo-syntax> double-quote" "syntax,double-quote,make-jojo" alias
   "<make-jojo-syntax> jo" "syntax,jo,make-jojo" alias
   "<make-jojo-syntax> address" "syntax,address,make-jojo" alias
   "<make-jojo-syntax> integer-string" "syntax,integer-string,make-jojo" alias

   "<basic-REPL-syntax> bye" "syntax,bye,basic-REPL" alias
   #+end_src
** <name-record>
   #+begin_src cicada-nymph :tangle core.cn
   "<name-record> get-old-jo" "name-record,get-old-jo" alias
   "<name-record> set-old-jo" "name-record,set-old-jo" alias

   "<name-record> get-name" "name-record,get-name" alias
   "<name-record> set-name" "name-record,set-name" alias

   "<name-record> get-new-jo" "name-record,get-new-jo" alias
   "<name-record> set-new-jo" "name-record,set-new-jo" alias
   #+end_src
** <global-naming-stack>
   #+begin_src cicada-nymph :tangle core.cn
   "<global-naming-stack> record-jo" "global-naming-stack,record-jo" alias
   "<global-naming-stack> delete-last-record" "global-naming-stack,delete-last-record" alias
   #+end_src
* a test of nested comment
** in function body
   #+begin_src cicada-nymph
   : test
     << -- >>
     1 << 2 >> 3 . . .l
     1 << << 2 >> 3 >> 4 . . .l
     end
   ; define-function
   test
   <<
   3 1
   4 1
   >>
   #+end_src
** in REPL
   #+begin_src cicada-nymph
   1 << << 2 >> 3 >>  4 . . .l
   #+end_src
* stack-REPL
** note
   * print argument-stack in every loop
** print-argument-stack
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,loop
     << address, counter -- >>
     dup zero? if
       drop2
       end
     then
     sub1 swap
       dup get .
     *jo-size* add
     swap
     loop
   ; define-function

   : print-argument-stack
     << -- >>
     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     *the-stack* greater-or-equal? if
       *the-stack*   << address as return value >>
       *the-stack-pointer-snapshot* *the-stack* sub
       *jo-size* div << counter as return value >>
       print-argument-stack,loop
       end
     then
     "below the stack " .s
     end
   ; define-function
   #+end_src
** print-argument-stack,pretty
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,pretty
     << -- >>
     snapshot-the-stack-pointer
     .l
     "  * " .s
        *the-stack-pointer-snapshot*
        *the-stack* sub
        << ad hoc for the BUG of div >>
        dup negative? if
          negate
          *jo-size* div
          negate
        else
          *jo-size* div
        then
        .i
     " * " .s
     " -- " .s
       print-argument-stack
     "--" .s
     .l
     end
   ; define-function
   #+end_src
** stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : stack-REPL,loop
     << unknown -- unknown >>
     read-word
     eval-word
     print-argument-stack,pretty
     loop
   ; define-function

   : stack-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     stack-REPL,loop
     end
   ; define-function
     #+end_src
** reset *lost-exception-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo stack-REPL address *lost-exception-REPL* set
   #+end_src
** test
   #+begin_src cicada-nymph
   : function-with-lost-exception
     !undo-make-jojo
   ; define-function
   function-with-lost-exception
   #+end_src
* eval-string
** note
   * (eval-string) is implemented by doing side-effect on reading-stack
     this is because syntax extension system is implemented by reader-macro
   * by implementing (eval-string) this way
     i can easily change the syntax be used to eval a string
** eval-string
   #+begin_src cicada-nymph :tangle core.cn
   : eval-string,loop
     << unknown -- unknown >>
     tos-reading-stack <string> space? if
       end
     then
     read-word
     eval-word
     loop
   ; define-function

   : eval-string
     << string[address, length] -- unknown >>
     push-reading-stack
     eval-string,loop
     drop-reading-stack
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "1 2 3 add add . " eval-string << 6 >>
   "1 2 3 add add ." eval-string  << 6 >>
   ": k 1 2 3 add add . end ; define-function k" eval-string << 6 >>
   k << 6 >>
   #+end_src
* define-variable
** note string allocation
   * string should be allocated to a static area
     instead of dynamic area like *circular-string-area*
     thus we have
     (syntax,double-quote,define-variable)
** syntax,double-quote,define-variable
   * in ASCII encode double-quote is 34
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,double-quote,define-variable,loop
     << cursor -- cursor >>
     read-byte
     dup 34 equal? if
       drop
       end
     then
     over set-byte
     add1
     loop
   ; define-function

   : syntax,double-quote,define-variable
     << word:double-quote -- string[address, length] >>
     drop2
     1024 2 mul allocate-local-memory >:buffer
     :buffer
     syntax,double-quote,define-variable,loop
     >:cursor
     :buffer
     :cursor :buffer sub
     make-string
     end
   ; define-function
   #+end_src
** define-variable
   #+begin_src cicada-nymph :tangle core.cn
   : define-variable
     << string[address, length] -- >>
     >::string

     ::string <string> word >::title
     ::string <string> word-tail <string> word >::name
     ::string <string> word-tail <string> word-tail >::body

     ::title " " ::name
     512 allocate-local-memory dup >:buffer
     3 n-string->buffer! >:len
     :buffer :len >::name
     ::title <word>? not if
       ::title >::name
       ::string <string> word-tail >::body
     then

     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot* >:old-snapshot

     jo word:double-quote?
     jo syntax,double-quote,define-variable
     *rule-set,basic-REPL* add-rule

     ::body eval-string

     jo word:double-quote?
     jo syntax,double-quote,define-variable
     *rule-set,basic-REPL* sub-rule

     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot* >:new-snapshot

     :new-snapshot :old-snapshot sub

     dup negative? if
       negate *jo-size* div
       "* (define-variable) fail to define variable : " .s ::name .s .l
       "  because after eval the following body" .s .l
       "  the stack is " .s .i " below what it use to be" .s .l
       ::body .s .l
       end
     then
     dup zero? if
       drop
       "* (define-variable) fail to define variable : " .s ::name .s .l
       "  because after eval the following body" .s .l
       "  the stack is still where it use to be" .s .l
       ::body .s .l
       end
     then

     *jo-size* div >:length

     ::name make-string >::name

     ::name *link* 0
     make-link >:link

     :link address *link* set

     *explainer,variable* 0
     make-jo-head >:jo

     :jo :link link,set-jo

     :link name-hash-table,record-jo,by-link

     :length
     :jo jo,set-length

     *jojo-area,current-free-address*
     :length
     n-set

     :length *jo-size* mul
     address *jojo-area,current-free-address*
     add-set
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : *numbers:define-variable*
     1 2 3
   ; define-variable
   *numbers:define-variable* . . . << 3 2 1 >>
   address *numbers:define-variable* get . << 1 >>

   : *string:define-variable*
     "define-variable"
   ; define-variable
   *string:define-variable* .s << define-variable >>

   : <test-title> *numbers:define-variable*
     1 2 3
   ; define-variable
   <test-title> *numbers:define-variable* . . . << 3 2 1 >>

   : <test-title> *string:define-variable*
     "define-variable"
   ; define-variable
   <test-title> *string:define-variable* .s << define-variable >>

   << error >>
   : kkk
     1 . 2 . 3 .
   ; define-variable

   << error >>
   1 2 3
   : kkk
     . . .
   ; define-variable
   #+end_src
* constant of system
** note *linux*
** init-syscall-number                :32bit:
   #+begin_src cicada-nymph :tangle core.cn
   *jo-size* 4 equal? if
     5   : :syscall-number,open:       ; define-variable,with-tos
     6   : :syscall-number,close:      ; define-variable,with-tos
     3   : :syscall-number,read:       ; define-variable,with-tos
     4   : :syscall-number,write:      ; define-variable,with-tos
     9   : :syscall-number,link:       ; define-variable,with-tos
     10  : :syscall-number,unlink:     ; define-variable,with-tos
     39  : :syscall-number,mkdir:      ; define-variable,with-tos
     40  : :syscall-number,rmdir:      ; define-variable,with-tos
     141 : :syscall-number,getdents:   ; define-variable,with-tos
     220 : :syscall-number,getdents64: ; define-variable,with-tos
     106 : :syscall-number,stat:       ; define-variable,with-tos
     1   : :syscall-number,exit:       ; define-variable,with-tos
     43  : :syscall-number,times:      ; define-variable,with-tos
     20  : :syscall-number,getpid:     ; define-variable,with-tos
     183 : :syscall-number,getcwd:     ; define-variable,with-tos
     12  : :syscall-number,chdir:      ; define-variable,with-tos
   then
   #+end_src
** init-syscall-number                :64bit:
   #+begin_src cicada-nymph :tangle core.cn
   *jo-size* 8 equal? if
     2   : :syscall-number,open:       ; define-variable,with-tos
     3   : :syscall-number,close:      ; define-variable,with-tos
     0   : :syscall-number,read:       ; define-variable,with-tos
     1   : :syscall-number,write:      ; define-variable,with-tos
     86  : :syscall-number,link:       ; define-variable,with-tos
     87  : :syscall-number,unlink:     ; define-variable,with-tos
     83  : :syscall-number,mkdir:      ; define-variable,with-tos
     84  : :syscall-number,rmdir:      ; define-variable,with-tos
     78  : :syscall-number,getdents:   ; define-variable,with-tos
     217 : :syscall-number,getdents64: ; define-variable,with-tos
     4   : :syscall-number,stat:       ; define-variable,with-tos
     60  : :syscall-number,exit:       ; define-variable,with-tos
     100 : :syscall-number,times:      ; define-variable,with-tos
     39  : :syscall-number,getpid:     ; define-variable,with-tos
     79  : :syscall-number,getcwd:     ; define-variable,with-tos
     80  : :syscall-number,chdir:      ; define-variable,with-tos
   then
   #+end_src
** error-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : error-code->string
     << error-code -- string[address, length] >>
     dup -1  equal? if drop  << EPERM   >>   "Operation not permitted " end then
     dup -2  equal? if drop  << ENOENT  >>   "No such file or directory " end then
     dup -3  equal? if drop  << ESRCH   >>   "No such process " end then
     dup -4  equal? if drop  << EINTR   >>   "Interrupted system call " end then
     dup -5  equal? if drop  << EIO     >>   "I/O error " end then
     dup -6  equal? if drop  << ENXIO   >>   "No such device or address " end then
     dup -7  equal? if drop  << E2BIG   >>   "Argument list too long " end then
     dup -8  equal? if drop  << ENOEXEC >>   "Exec format error " end then
     dup -9  equal? if drop  << EBADF   >>   "Bad file number " end then
     dup -10 equal? if drop  << ECHILD  >>   "No child processes " end then
     dup -11 equal? if drop  << EAGAIN  >>   "Try again " end then
     dup -12 equal? if drop  << ENOMEM  >>   "Out of memory " end then
     dup -13 equal? if drop  << EACCES  >>   "Permission denied " end then
     dup -14 equal? if drop  << EFAULT  >>   "Bad address " end then
     dup -15 equal? if drop  << ENOTBLK >>   "Block device required " end then
     dup -16 equal? if drop  << EBUSY   >>   "Device or resource busy " end then
     dup -17 equal? if drop  << EEXIST  >>   "File exists " end then
     dup -18 equal? if drop  << EXDEV   >>   "Cross-device link " end then
     dup -19 equal? if drop  << ENODEV  >>   "No such device " end then
     dup -20 equal? if drop  << ENOTDIR >>   "Not a directory " end then
     dup -21 equal? if drop  << EISDIR  >>   "Is a directory " end then
     dup -22 equal? if drop  << EINVAL  >>   "Invalid argument " end then
     dup -23 equal? if drop  << ENFILE  >>   "File table overflow " end then
     dup -24 equal? if drop  << EMFILE  >>   "Too many open files " end then
     dup -25 equal? if drop  << ENOTTY  >>   "Not a typewriter " end then
     dup -26 equal? if drop  << ETXTBSY >>   "Text file busy " end then
     dup -27 equal? if drop  << EFBIG   >>   "File too large " end then
     dup -28 equal? if drop  << ENOSPC  >>   "No space left on device " end then
     dup -29 equal? if drop  << ESPIPE  >>   "Illegal seek " end then
     dup -30 equal? if drop  << EROFS   >>   "Read-only file system " end then
     dup -31 equal? if drop  << EMLINK  >>   "Too many links " end then
     dup -32 equal? if drop  << EPIPE   >>   "Broken pipe " end then
     dup -33 equal? if drop  << EDOM    >>   "Math argument out of domain of func " end then
     dup -34 equal? if drop  << ERANGE  >>   "Math result not representable " end then
     "unknow error-code : " .s .i .l
     "* (error-code->string) fail" << to balance the argument-stack >>
     end
   ; define-function
   #+end_src
** file-type-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : file-type-code->string
     << file-type-code -- string[address, length] >>
     dup 1  equal?  << DT_FIFO  >>  if drop "named pipe i.e. FIFO"  end then
     dup 2  equal?  << DT_CHR   >>  if drop "Character device"      end then
     dup 4  equal?  << DT_DIR   >>  if drop "directory"             end then
     dup 6  equal?  << DT_BLK   >>  if drop "block device"          end then
     dup 8  equal?  << DT_REG   >>  if drop "regular file"          end then
     dup 10 equal?  << DT_LNK   >>  if drop "symbolic link"         end then
     dup 12 equal?  << DT_SOCK  >>  if drop "UNIX domain socket"    end then
     drop
     "unknow file type"
     end
   ; define-function
   #+end_src
* port
** note
*** syscall with string arguments
    * for syscall the arguments in stack look like
      << ..., arg3, arg2, arg1 >>
      so
      for read(port, buffer, size)
      we need
      << size, buffer, port >>
      but the interface (<port> read) in cicada-nymph is
      << buffer, size, port >>
      thus we need a swap here
      and
      we should be careful
      for other interface functions in cicada-nymph
*** linux header
    * 8 base number :
      O_ACCMODE          0003
      O_RDONLY             00
      O_WRONLY             01
      O_RDWR               02
      O_CREAT            0100  Not fcntl
      O_EXCL             0200  Not fcntl
      O_NOCTTY           0400  Not fcntl
      O_TRUNC           01000  Not fcntl
      O_APPEND          02000
      O_NONBLOCK        04000
      O_NDELAY     O_NONBLOCK
      O_SYNC         04010000
      O_FSYNC          O_SYNC
      O_ASYNC          020000
      O_LARGEFILE     0100000
      O_DIRECTORY     0200000
      O_NOFOLLOW      0400000
      O_CLOEXEC      02000000
      O_DIRECT         040000
      O_NOATIME      01000000
      O_PATH        010000000
      O_DSYNC          010000
      O_TMPFILE     020200000
*** 關於輸入輸出
    * 接口設計分兩個層次
      1. 底層的以 port 爲基礎的接口
         這裏應該如何設計還不確定
         可能會模仿操作系統所提供的接口
      2. 高層的以 path 爲基礎的接口
         這裏將抽象掉 port 這個概念
         也就是每次簡單的讀寫都伴隨兩個對 port 的操作
         這樣接口就很簡單 但是速度可能會非常慢
*** interface
    * open to read
    * create and update to write
      |--------+-----------------------|
      | create | fail if already exist |
      | update | fail if nor exist     |
      |--------+-----------------------|
    * one should always know if a file exist or not
      when open it as output-port
      predicates are provided to help you to do so
** open
   #+begin_src cicada-nymph :tangle core.cn
   : <port> open
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     2 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** create
   #+begin_src cicada-nymph :tangle core.cn
   : <port> create
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1102 <<
     O_RDWR   0002
     O_CREAT  0100
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** update
   #+begin_src cicada-nymph :tangle core.cn
   : <port> update
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     110100100b
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** close
   #+begin_src cicada-nymph :tangle core.cn
   : <port> close
     << port
        -- true
        -- error-code, false >>
     :syscall-number,close:
     1 syscall
     dup
     negative? if
       false
       end
     then
     drop true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     "kkk~" <port> create if
       <port> close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test

   : test
     << -- >>
     "kkk~" <port> update if
       <port> close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test
   #+end_src
** read
   #+begin_src cicada-nymph :tangle core.cn
   : <port> read
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** write
   #+begin_src cicada-nymph :tangle core.cn
   : <port> write
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     64 allocate-local-memory
     dup
     "kkk~" <port> open if
       64 swap <port> read if
         .s .l
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test
   #+end_src
* file
** note file-tree
*** interface
    * file-tree
      two types of nodes
      1. file
      2. directory
      a leaf must be a file
    * the following interface is provided
      * they use path as an argument
      * they print error message on error
        instead of return error info
        or rise exception
      * the concept of port is
        completely removed from the interface
      --------------------------------
      * file
        1. create
        2. write
        3. read
        4. remove
      * directory
        1. create
        2. remove
        3. empty?
        4. list-file
        5. list-directory
        6. find-file
        7. find-directory
*** 錯誤處理
    * 兩種風格
      IO 相關的函數在出錯時
      1. 立即報錯
      2. 返回出錯信息
    * 第一種很簡單
      它假設了所有的錯誤都是不可忽略的
*** 元數據
    * 訪問管理
      1. 誰有權訪問這個文件
      2. 他的權利是什麼
    * 文件類型
      [linux 沒有]
    * 文件大小
    * 文件使用註釋
      [linux 沒有]
** <file> create
   #+begin_src cicada-nymph :tangle core.cn
   : <file> create
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#0200
     8#0100 bit-or <<
     O_EXCL   0200
     O_CREAT  0100
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (<file> create) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     <port> close if
       end
     then
     "* (<file> create) fail to close port for the following path :" .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** <file> write
   #+begin_src cicada-nymph :tangle core.cn
   : <file> write
     << string[address, length], path[address, length] -- >>
     >::path
     >::string
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (<file> write) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     ::string swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       "* (<file> write) fail to write port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:counter << bytes been written >>
     :port
     <port> close if
       end
     then
     "* (<file> write) fail to close port for the following path : " .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** <file> read
   #+begin_src cicada-nymph :tangle core.cn
   : <file> read
     << string[address, max-length], path[address, length] -- counter >>
     >::path
     >::string
     ::path
     string->syscall-string
     >:syscall-path
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     2 syscall
     dup
     negative? if
       "* (<file> read) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       0
       end
     then
     >:port
     ::string swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       "* (<file> read) fail to read port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       0
       end
     then
     >:counter << bytes been readed >>
     :port
     <port> close if
       :counter
       end
     then
     "* (<file> read) fail to close port for the following path : " .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     0
     end
   ; define-function
   #+end_src
** <file> remove
   #+begin_src cicada-nymph :tangle core.cn
   : <file> remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,unlink:
     1 syscall
     dup
     negative? if
       "* (<file> remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     "kkk~" <file> create
     "core" <file> create
     end
   ; define-function
   test

   : test
     << -- >>
     "kkk~" <file> create
     "kkk took my baby away !!!" "kkk~" <file> write
     end
   ; define-function
   test

   : test
     << -- >>
     "............................" >::string
     ::string "kkk~" <file> read .i .l
     ::string .s
     end
   ; define-function
   test

   : test
     << -- >>
     "kkk~" <file> remove
     "play" <file> remove
     end
   ; define-function
   test
   #+end_src
* directory
** <directory> create
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> create
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#755 <<
     2#111101101
     >>
     :syscall-path
     :syscall-number,mkdir:
     2 syscall
     dup
     negative? if
       "* (<directory> create) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** <directory> remove
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,rmdir:
     1 syscall
     dup
     negative? if
       "* (<directory> remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "play" <directory> create
   "play" <directory> remove
   #+end_src
** getdents64 structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +getdents64,d_ino+        ; define-variable,with-tos
   0 : +getdents64,d_off+        ; define-variable,with-tos
   0 : +getdents64,d_reclen+     ; define-variable,with-tos
   0 : +getdents64,d_type+       ; define-variable,with-tos
   0 : +getdents64,d_name+       ; define-variable,with-tos
   0 : +getdents64,end+          ; define-variable,with-tos

   : init,getdents64
     << offset -- >>
     *jo-size* 4 equal? if
       dup address +getdents64,d_ino+    set    8 add
       dup address +getdents64,d_off+    set    8 add
       dup address +getdents64,d_reclen+ set    2 add
       dup address +getdents64,d_type+   set    1 add
       dup address +getdents64,d_name+   set    256 add
           address +getdents64,end+      set
       end
     then
     *jo-size* 8 equal? if
       dup address +getdents64,d_ino+    set    8 add
       dup address +getdents64,d_off+    set    8 add
       dup address +getdents64,d_reclen+ set    2 add
       dup address +getdents64,d_type+   set    1 add
       dup address +getdents64,d_name+   set    256 add
           address +getdents64,end+      set
       end
     then
     end
   ; define-function

   0 init,getdents64
   +getdents64,end+ : +getdents64,length+ ; define-variable,with-tos
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,getdents64,print
     << -- >>
     "+getdents64,d_ino+ : "    .s +getdents64,d_ino+     get . .l
     "+getdents64,d_off+ : "    .s +getdents64,d_off+     get . .l
     "+getdents64,d_reclen+ : " .s +getdents64,d_reclen+  get-two-bytes . .l
     "+getdents64,d_type+ : "   .s
     +getdents64,d_type+
     get-byte file-type-code->string .s .l
     "+getdents64,d_name+ : "   .s
     +getdents64,d_name+
     dup 256
     0 <string> find-byte
     drop  << drop 0 >>
     over sub .s .l
     .l
     end
   ; define-function

   : test,getdents64,loop,structure
     << end, cursor -- >>
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     :cursor init,getdents64
     test,getdents64,print
     :cursor +getdents64,d_reclen+ get-two-bytes add
     loop
   ; define-function

   : test,getdents64,loop
     << port -- >>
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     "* syscall returns : " .s dup .i .l
     dup negative? if
       error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     test,getdents64,loop,structure
     :port
     loop
   ; define-function

   : test,getdents64
     << path[address, length] -- >>
     >::path
     ::path <port> open if
     else
       "* (test,getdents64) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port test,getdents64,loop
     :port <port> close if
       end
     then
     "* (test,getdents64) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function

   "play" test,getdents64
   "play/kkk" test,getdents64
   "." test,getdents64
   "/" test,getdents64
   #+end_src
** <directory> empty?
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> empty?
     << path[address, length] -- bool >>
     >::path
     ::path <port> open if
     else
       "* (<directory> empty?) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       false
       end
     then
     >:port
     128 allocate-local-memory >:getdents64-structure-list
     128
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     48 equal? << this call to equal? returns the needed bool >>
     :port <port> close if
       end
     then
     "* (<directory> empty?) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     false
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "play" <directory> empty? . .l
   "play/kkk" <directory> empty? . .l
   "play/aaa" <directory> empty? . .l
   "." <directory> empty? . .l
   "/" <directory> empty? . .l
   #+end_src
** <directory> map
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> map,loop,execute
     << end, cursor, function -- >>
     >:function
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     >:end
     :cursor init,getdents64
     :function apply
     :end
     :cursor +getdents64,d_reclen+ get-two-bytes add
     :function
     loop
   ; define-function

   : <directory> map,loop
     << port, function -- >>
     >:function
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     dup negative? if
       "* (<directory> map,loop) syscall fail" .s .l
       "  " .s error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     :function
     <directory> map,loop,execute
     :port
     :function
     loop
   ; define-function

   : <directory> map
     << directory-path[address, length],
        function
        -- true
        -- false >>
     >:function
     >::directory-path
     ::directory-path <port> open if
     else
       "* (<directory> map) fail to open : " .s ::directory-path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port :function <directory> map,loop
     :port <port> close if
       end
     then
     "* (<directory> map) fail to close : " .s ::directory-path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,function
     << -- >>
     +getdents64,d_type+ get-byte
     8 equal? if
       "  " .s
       +getdents64,d_name+
       dup 256
       0 <string> find-byte
       drop  << drop 0 >>
       over sub .s .l
     then
     end
   ; define-function

   "play" jo test,function <directory> map
   #+end_src
** <directory> list-file
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> list-file
     << directory-path[address, length] -- >>
     [ << -- >>
       +getdents64,d_type+ get-byte
       8 equal? if
         "  " .s
         +getdents64,d_name+
         dup 256
         0 <string> find-byte
         drop  << drop 0 >>
         over sub .s .l
       then
       end ]
     <directory> map
     end
   ; define-function
   #+end_src
** <directory> list-directory
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> list-directory
     << directory-path[address, length] -- >>
     [ << -- >>
       +getdents64,d_type+ get-byte
       4 equal? if
         +getdents64,d_name+
         dup 256
         0 <string> find-byte
         drop  << drop 0 >>
         over sub >::name
         ".." ::name <string> equal? if
           end
         then
         "." ::name <string> equal? if
           end
         then
         "  " .s ::name .s .l
         end
       then
       end ]
     <directory> map
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "play" dup2
   <directory> list-file
   <directory> list-directory

   "play/kkk" dup2
   <directory> list-file
   <directory> list-directory

   "." dup2
   <directory> list-file
   <directory> list-directory

   "/" dup2
   <directory> list-file
   <directory> list-directory
   #+end_src
** <directory> find-file
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> find-file
     << directory-path[address, length], file-name[address, length] -- bool >>
     xx|swap|xx
     false
     xx|swap|x
     [ << file-name[address, length], bool --
          file-name[address, length], bool >>
       +getdents64,d_type+ get-byte 8 equal? not if
         end
       then
       >:bool
       >:file-name,lenght
       >:file-name,address
       :file-name,lenght +getdents64,d_name+ add
       get-byte zero? not if
         :file-name,address
         :file-name,lenght
         :bool
         end
       then
       :file-name,address :file-name,lenght
       +getdents64,d_name+ :file-name,lenght
       <string> equal? if
         :file-name,address
         :file-name,lenght
         true
         end
       then
       :file-name,address
       :file-name,lenght
       :bool
       end ]
     <directory> map
     xx|swap|x drop2
     end
   ; define-function
   #+end_src
** <directory> find-directory
   #+begin_src cicada-nymph :tangle core.cn
   : <directory> find-directory
     << directory-path[address, length], file-name[address, length] -- bool >>
     xx|swap|xx
     false
     xx|swap|x
     [ << file-name[address, length], bool --
          file-name[address, length], bool >>
       +getdents64,d_type+ get-byte 4 equal? not if
         end
       then
       >:bool
       >:file-name,lenght
       >:file-name,address
       :file-name,lenght +getdents64,d_name+ add
       get-byte zero? not if
         :file-name,address
         :file-name,lenght
         :bool
         end
       then
       :file-name,address :file-name,lenght
       +getdents64,d_name+ :file-name,lenght
       <string> equal? if
         :file-name,address
         :file-name,lenght
         true
         end
       then
       :file-name,address
       :file-name,lenght
       :bool
       end ]
     <directory> map
     xx|swap|x drop2
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     "play" "cn" <directory> find-file .
     "play" "kkk" <directory> find-file .
     "play" "no" <directory> find-file .
     .l
     "playlay" "no" <directory> find-file .
     .l
     end
   ; define-function
   test

   : test
     << -- >>
     "play" "cn" <directory> find-directory .
     "play" "kkk" <directory> find-directory .
     "play" "no" <directory> find-directory .
     .l
     "playlay" "no" <directory> find-directory .
     .l
     end
   ; define-function
   test
   #+end_src
* system environment
** note *linux*
*** one directory
    * all files about cicada
      are stored in
      "/home/<user>/.cicada"
*** pid
    * pid is the key to all the linux system environment
    * command-line
      /proc/<pid>/cmdline
    * environment-variable-list
      /proc/<pid>/environ
** [init|get]-pid
   #+begin_src cicada-nymph :tangle core.cn
   0 : *pid* ; define-variable,with-tos

   : init-pid
     << -- >>
     :syscall-number,getpid:
     0 syscall
     address *pid* set
     end
   ; define-function

   : get-pid
     << -- pid >>
     *pid*
     end
   ; define-function
   #+end_src
** [init|get]-command-line
   #+begin_src cicada-nymph :tangle core.cn
   512 allocate-memory
   : *address,command-line*
   ; define-variable,with-tos

   512
   : *length,command-line*
   ; define-variable,with-tos

   : init-command-line
     << -- >>
     64 allocate-local-memory >:path-buffer
     :path-buffer >:cursor

     get-pid write-number,fill-buffer >::pid-string

     "/proc/" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     ::pid-string dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     "/cmdline" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     :path-buffer
     :cursor :path-buffer sub dup2 >::path
     <port> open if
     else
       "* (init-command-line) fail to open : " .s ::path .s .l
       end
     then
     >:port

     *address,command-line*
     *length,command-line*
     :port
     <port> read if
     else
       "* (init-command-line) fail to read : " .s ::path .s .l
       end
     then
     address *length,command-line* set
     end
   ; define-function

   : get-command-line
     << -- string[address, length] >>
     *address,command-line* *length,command-line*
     end
   ; define-function
   #+end_src
** [init|get]-environment-variable-list
   * the size of /proc/<pid>/environ is limited to 4k
   #+begin_src cicada-nymph :tangle core.cn
   1024 4 mul allocate-memory
   : *address,environment-variable-list*
   ; define-variable,with-tos

   1024 4 mul
   : *length,environment-variable-list*
   ; define-variable,with-tos

   : init-environment-variable-list
     << -- >>
     64 allocate-local-memory >:path-buffer
     :path-buffer >:cursor

     get-pid write-number,fill-buffer >::pid-string

     "/proc/" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     ::pid-string dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     "/environ" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     :path-buffer
     :cursor :path-buffer sub dup2 >::path
     <port> open if
     else
       "* (init-environment-variable-list) fail to open : " .s ::path .s .l
       end
     then
     >:port

     *address,environment-variable-list*
     *length,environment-variable-list*
     :port
     <port> read if
     else
       "* (init-environment-variable-list) fail to read : " .s ::path .s .l
       end
     then
     address *length,environment-variable-list* set
     end
   ; define-function

   : get-environment-variable-list
     << -- string[address, length] >>
     *address,environment-variable-list*
     *length,environment-variable-list*
     end
   ; define-function
   #+end_src
** find-environment-variable
   * the string used to find an environment-variable
     can not contain "="
     no error handling on this
   #+begin_src cicada-nymph :tangle core.cn
   : find-environment-variable,loop
     << string[address, length], cursor
        -- string[address, length], true
        -- false >>
     dup
     get-environment-variable-list add
     greater-than? if
       drop drop2
       false
       end
     then
     >:cursor
     >:length
     >:address
     :address :cursor :length
     compare-buffer not if
       :address :length
       :cursor 0 cursor->next-matching-byte add1
       loop
     then
     :cursor :length add get-byte
     "=" <string> byte
     equal? not if
       :address :length
       :cursor 0 cursor->next-matching-byte add1
       loop
     then
     :cursor :length add add1 << over "=" >>
     >:find-address
     :find-address 0 cursor->next-matching-byte
     :find-address sub >:find-length
     :find-address
     :find-length
     end
   ; define-function

   : find-environment-variable
     << string[address, length]
        -- string[address, length], true
        -- false >>
     get-environment-variable-list drop
     find-environment-variable,loop
     end
   ; define-function
   #+end_src
** initialize system environment
   #+begin_src cicada-nymph :tangle core.cn
   init-pid
   init-command-line
   init-environment-variable-list
   #+end_src
** *home-directory*
   #+begin_src cicada-nymph :tangle core.cn
   : *home-directory*
     "HOME" find-environment-variable
   ; define-variable
   #+end_src
** <report> environment-variable
   #+begin_src cicada-nymph :tangle core.cn
   : <report> environment-variable,loop
     << environment-variable-list[address, length]-- >>
     dup2 <string> space? if
       drop2
       end
     then

     >:length
     >:address

     :address :length 0 <string> find-byte drop add1 >:cursor
     :cursor :address sub >:length-of-one-variable

     :address
     :length-of-one-variable sub1 .s .l

     :cursor
     :length :length-of-one-variable sub
     loop
   ; define-function

   : <report> environment-variable
     << -- >>
     get-environment-variable-list
     <report> environment-variable,loop
     end
   ; define-function
   #+end_src
** <report> command-line
   #+begin_src cicada-nymph :tangle core.cn
   : <report> command-line,loop
     << command-line[address, length] -- >>
     dup2 <string> space? if
       drop2
       end
     then
     dup2 <string> word .s 32 .b
     <string> word-tail
     loop
   ; define-function

   : <report> command-line
     << -- >>
     get-command-line
     <report> command-line,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   <report> environment-variable
   <report> command-line
   #+end_src
** work-directory
*** get-work-directory
    #+begin_src cicada-nymph :tangle core.cn
    512 allocate-memory
    : *buffer,work-directory*
    ; define-variable,with-tos

    : get-work-directory
      << -- directory[address, length] >>
      512
      *buffer,work-directory*
      :syscall-number,getcwd:
      2 syscall
      dup negative? if
        "* (get-work-directory) fail" .s .l
        "  " .s error-code->string .s .l
        end
      then
      *buffer,work-directory*
      swap
      sub1 << for the ending zero >>
      end
    ; define-function
    #+end_src
*** change-work-directory
    #+begin_src cicada-nymph :tangle core.cn
    : change-work-directory
      << directory-path[address, length] -- >>
      >::directory-path
      ::directory-path
      string->syscall-string
      :syscall-number,chdir:
      1 syscall
      dup negative? if
        "* (change-work-directory) fail" .s .l
        "  can not change the work directory into : " .s ::directory-path .s .l
        "  " .s error-code->string .s .l
        end
      then
      drop
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    get-work-directory .s
    "/home" change-work-directory
    get-work-directory .s
    "/////home/xyh////cicada/play" change-work-directory
    get-work-directory .s
    "//././/home/xyh/././cicada/./" change-work-directory
    get-work-directory .s
    #+end_src
* path
** stat structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +stat,st_dev+        ; define-variable,with-tos
   0 : +stat,st_ino+        ; define-variable,with-tos
   0 : +stat,st_mode+       ; define-variable,with-tos
   0 : +stat,st_nlink+      ; define-variable,with-tos
   0 : +stat,st_uid+        ; define-variable,with-tos
   0 : +stat,st_gid+        ; define-variable,with-tos
   0 : +stat,st_rdev+       ; define-variable,with-tos
   0 : +stat,st_size+       ; define-variable,with-tos
   0 : +stat,st_blksize+    ; define-variable,with-tos
   0 : +stat,st_blocks+     ; define-variable,with-tos
   0 : +stat,st_atime+      ; define-variable,with-tos
   0 : +stat,st_atime_nsec+ ; define-variable,with-tos
   0 : +stat,st_mtime+      ; define-variable,with-tos
   0 : +stat,st_mtime_nsec+ ; define-variable,with-tos
   0 : +stat,st_ctime+      ; define-variable,with-tos
   0 : +stat,st_ctime_nsec+ ; define-variable,with-tos
   0 : +stat,__unused4+     ; define-variable,with-tos
   0 : +stat,__unused5+     ; define-variable,with-tos
   0 : +stat,end+           ; define-variable,with-tos

   : init,stat
     << offset -- >>
     *jo-size* 4 equal? if
       dup address +stat,st_dev+        set *jo-size* add
       dup address +stat,st_ino+        set *jo-size* add
       dup address +stat,st_mode+       set 2 add
       dup address +stat,st_nlink+      set 2 add
       dup address +stat,st_uid+        set 2 add
       dup address +stat,st_gid+        set 2 add
       dup address +stat,st_rdev+       set *jo-size* add
       dup address +stat,st_size+       set *jo-size* add
       dup address +stat,st_blksize+    set *jo-size* add
       dup address +stat,st_blocks+     set *jo-size* add
       dup address +stat,st_atime+      set *jo-size* add
       dup address +stat,st_atime_nsec+ set *jo-size* add
       dup address +stat,st_mtime+      set *jo-size* add
       dup address +stat,st_mtime_nsec+ set *jo-size* add
       dup address +stat,st_ctime+      set *jo-size* add
       dup address +stat,st_ctime_nsec+ set *jo-size* add
       dup address +stat,__unused4+     set *jo-size* add
       dup address +stat,__unused5+     set *jo-size* add
           address +stat,end+           set
       end
     then
     *jo-size* 8 equal? if
       dup address +stat,st_dev+        set *jo-size* add
       dup address +stat,st_ino+        set *jo-size* add
       <<
       note the following order changing
       this is linux' bad
       >>
       dup address +stat,st_nlink+      set 8 add
       dup address +stat,st_mode+       set 4 add

       dup address +stat,st_uid+        set 4 add
       dup address +stat,st_gid+        set 4 add
                                             4 add << padding >>
       dup address +stat,st_rdev+       set *jo-size* add
       dup address +stat,st_size+       set *jo-size* add
       dup address +stat,st_blksize+    set *jo-size* add
       dup address +stat,st_blocks+     set *jo-size* add
       dup address +stat,st_atime+      set *jo-size* add
       dup address +stat,st_atime_nsec+ set *jo-size* add
       dup address +stat,st_mtime+      set *jo-size* add
       dup address +stat,st_mtime_nsec+ set *jo-size* add
       dup address +stat,st_ctime+      set *jo-size* add
       dup address +stat,st_ctime_nsec+ set *jo-size* add
       dup address +stat,__unused4+     set *jo-size* add
       dup address +stat,__unused5+     set *jo-size* add
           address +stat,end+           set
       end
     then
     end
   ; define-function

   0 init,stat
   +stat,end+ : +stat,length+ ; define-variable,with-tos
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,stat
     << path[address, length] -- >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       dup .
       error-code->string .s .l
       end
     then
     drop
     :stat-structure init,stat
     "+stat,st_dev+ : " .s +stat,st_dev+        get . .l
     "+stat,st_ino+ : " .s +stat,st_ino+        get . .l
     *jo-size* 4 equal? if
     "+stat,st_mode+ : " .s +stat,st_mode+       get-two-bytes  . .l
     "+stat,st_nlink+ : " .s +stat,st_nlink+      get-two-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        get-two-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        get-two-bytes  . .l
     then
     *jo-size* 8 equal? if
     "+stat,st_nlink+ : " .s +stat,st_nlink+      get  . .l
     "+stat,st_mode+ : " .s +stat,st_mode+       get-four-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        get-four-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        get-four-bytes  . .l
     then
     "+stat,st_rdev+ : " .s +stat,st_rdev+       get . .l
     "+stat,st_size+ : " .s +stat,st_size+       get . .l
     "+stat,st_blksize+ : " .s +stat,st_blksize+    get . .l
     "+stat,st_blocks+ : " .s +stat,st_blocks+     get . .l
     "+stat,st_atime+ : " .s +stat,st_atime+      get . .l
     "+stat,st_atime_nsec+ : " .s +stat,st_atime_nsec+ get . .l
     "+stat,st_mtime+ : " .s +stat,st_mtime+      get . .l
     "+stat,st_mtime_nsec+ : " .s +stat,st_mtime_nsec+ get . .l
     "+stat,st_ctime+ : " .s +stat,st_ctime+      get . .l
     "+stat,st_ctime_nsec+ : " .s +stat,st_ctime_nsec+ get . .l
     "+stat,__unused4+ : " .s +stat,__unused4+     get . .l
     "+stat,__unused5+ : " .s +stat,__unused5+     get . .l
     end
   ; define-function

   "cn" test,stat
   "no" test,stat
   #+end_src
** note predicate
   * to use predicate to know more about the file-tree
     before calling a function that makes action on the file-tree
** path,nothing?
   #+begin_src cicada-nymph :tangle core.cn
   : path,nothing?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     -2 equal?
     end
   ; define-function
   #+end_src
** path,file?
   #+begin_src cicada-nymph :tangle core.cn
   : path,file?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       get-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       get-four-bytes
     then
     12 bit-right
     8#0010
     equal?
     <<
     0170000
     S_IFDIR       0040000 /* Directory.  */
     S_IFCHR       0020000 /* Character device.  */
     S_IFBLK       0060000 /* Block device.  */
     S_IFREG       0100000 /* Regular file.  */
     S_IFIFO       0010000 /* FIFO.  */
     S_IFLNK       0120000 /* Symbolic link.  */
     S_IFSOCK      0140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** path,directory?
   #+begin_src cicada-nymph :tangle core.cn
   : path,directory?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       get-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       get-four-bytes
     then
     12 bit-right
     8#0004
     equal?
     <<
     0170000
     S_IFDIR       00040000 /* Directory.  */
     S_IFCHR       00020000 /* Character device.  */
     S_IFBLK       00060000 /* Block device.  */
     S_IFREG       00100000 /* Regular file.  */
     S_IFIFO       00010000 /* FIFO.  */
     S_IFLNK       00120000 /* Symbolic link.  */
     S_IFSOCK      00140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "cn" path,nothing? . << 0 >>
   "core" path,nothing? . << 0 >>
   "ai" path,nothing? . << 1 >>

   "cn" path,file? . << 1 >>
   "core" path,file? . << 0 >>
   "ai" path,file? . << 0 >>

   "cn" path,directory? . << 0 >>
   "core" path,directory? . << 1 >>
   "ai" path,directory? . << 0 >>
   #+end_src
** 記 字符串的謂詞
   * 下面這兩個函數
     其實是在用遞歸函數實現正則表達式對字符串的匹配效果
   * 是否應該設計 正則表達式 子語言 ?
     還是總是直接使用遞歸函數 ?
** 記 unix 路徑格式
   * "/" 相當於 空格
     連續的 "//" 相當於 連續的空格
     這種空格使用在字符串開頭時 代表這是一個 絕對路徑
   * "." 相當於 空格
     連續的 ".." 不算 連續的空格 有別的語義
     但是在這種空格使用在最前面的時候 標誌這個
     這種空格使用在字符串開頭時 代表這是一個 相對路徑
   * 而對於下面的兩個函數我簡單地要求
     1. relative-path
        不以 "/" 開頭 的字符串
     2. full-path
        以 "/" 開頭 的字符串
     3. 並且在這裏我允許 path 內 出現空格
        保留對這種路徑的處理能力
        只不過 我不使用這種路徑而已
** relative-path?
   * in ASCII "/" is 47
   #+begin_src cicada-nymph :tangle core.cn
   : relative-path?
     << string[address, length] -- bool >>
     dup zero? if
       drop2
       false
       end
     then
     <string> byte
     47 equal? not
     end
   ; define-function
   #+end_src
** full-path?
   * in ASCII "/" is 47
   #+begin_src cicada-nymph :tangle core.cn
   : full-path?
     << string[address, length] -- bool >>
     dup zero? if
       drop2
       false
       end
     then
     <string> byte
     47 equal?
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "/home" relative-path? .
   "/home" full-path? .
   "home" relative-path? .
   "home" full-path? .
   #+end_src
* poi
** 記
   * poi 是利用文件系統所實現的登記機制
     所登記的 path 信息爲 path-syntax 所用
   * module 也是用文件系統所實現的登記機制
     所登記的 path 信息爲 module 機制所用
** note
   * poi denotes path-organizer
     it can give a name to a path
     one path one name
   * a path as a string must not contain any space bytes
   * a name should only consist of number or letter or "-"
** *poi-directory*
   * one directory to store the name path record
     "/home/<user>/.cicada/poi"
   #+begin_src cicada-nymph :tangle core.cn
   : *poi-directory,user,address*
     512 allocate-memory
   ; define-variable

   : *poi-directory*
     *home-directory* "/.cicada/poi"
     *poi-directory,user,address*
     2 n-string->buffer!
     *poi-directory,user,address* swap
   ; define-variable
   #+end_src
** <poi> find
   * note that
     this function uses *circular-string-area*
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> find
     << name[address, length]
        -- path[address, length], true
        -- false >>
     >::name
     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     :buffer :length
     path,file? not if
       false
       end
     then

     512 allocate-local-memory >:read-buffer
     :read-buffer 512
     :buffer :length
     <file> read >:read-length

     *circular-string-area,current-free-address*
     >:path-address

     :read-buffer :read-length
     circular-string-area,stay

     :path-address
     :read-length
     true
     end
   ; define-function
   #+end_src
** <poi> add
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> add
     << name[address, length], relative-path[address, length] -- >>
     >::relative-path
     >::name

     ::relative-path relative-path? not if
       "* (<poi> add) the argument must be a relative-path" .s .l
       "  but the following is not : " .s ::relative-path .s .l
       end
     then

     ::relative-path path,directory? not if
       "* (<poi> add) the argument must be a relative-path to a existing directory" .s .l
       "  but the following path is not to a directory : " .s ::relative-path .s .l
       end
     then

     ::name <poi> find if
       "* (<poi> add) can not add" .s .l
       "  for the following poi already exist : " .s ::name .s .l
       "  name is use as the following directory's name : " .s .s .l
       end
     then

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name
     :buffer
     3 n-string->buffer!
     >:length
     :buffer :length
     <directory> create

     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer!
     >:length
     :buffer :length
     <file> create

     512 allocate-local-memory >:address,full-path
     get-work-directory "/" ::relative-path
     :address,full-path
     3 n-string->buffer! >:length,full-path

     :address,full-path :length,full-path
     :buffer :length
     <file> write
     end
   ; define-function
   #+end_src
** <poi> sub
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> sub
     << name[address, length] -- >>
     >::name

     ::name <poi> find not if
       "* (<poi> sub) can not sub" .s .l
       "  for the following poi does not exist : " .s ::name .s .l
       end
     then
     >::named-directory

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     :buffer :length
     <file> remove

     *poi-directory* "/" ::name
     :buffer
     3 n-string->buffer!
     >:length
     :buffer :length
     <directory> remove
     end
   ; define-function
   #+end_src
** <poi> up
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> up
     << name[address, length], relative-path[address, length] -- >>
     >::relative-path
     >::name

     ::relative-path relative-path? not if
       "* (<poi> up) the argument must be a relative-path" .s .l
       "  but the following is not : " .s ::relative-path .s .l
       end
     then

     ::relative-path path,directory? not if
       "* (<poi> up) the argument must be a relative-path to a existing directory" .s .l
       "  but the following directory is not exist : " .s ::relative-path .s .l
       end
     then

     ::name <poi> find not if
       "* (<poi> up) can not up" .s .l
       "  for the following poi does not exist : " .s ::name .s .l
       end
     then
     >::named-directory

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     512 allocate-local-memory >:address,full-path
     get-work-directory "/" ::relative-path
     :address,full-path
     3 n-string->buffer! >:length,full-path

     :address,full-path :length,full-path
     :buffer :length
     <file> write
     end
   ; define-function
   #+end_src
** <poi> list
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> list
     << -- >>
     *poi-directory*
     [ << -- >>
       +getdents64,d_type+ get-byte
       4 equal? if
         512 allocate-local-memory >:path-buffer
         +getdents64,d_name+
         dup 256
         0 <string> find-byte
         drop  << drop 0 >>
         over sub >::name

         ".." ::name <string> equal? if
           end
         then

         "." ::name <string> equal? if
           end
         then

         "  * " .s ::name .s .l
         "      " .s

         *poi-directory* "/" ::name "/path"
         :path-buffer
         4 n-string->buffer! >:path-length

         512 allocate-local-memory >:reading-buffer
         :reading-buffer 512
         :path-buffer :path-length
         <file> read >:reading-length

         :reading-buffer :reading-length
         .s .l
       then
       end ]
     <directory> map
     end
   ; define-function
   #+end_src
** <poi> help
   #+begin_src cicada-nymph :tangle core.cn
   : <poi> help
     << -- >>
     "* (<poi> help)" .s .l
     "  * cn poi add  <new-name> <relative-path-to-existing-directory>" .s .l
     "  * cn poi sub  <old-name>" .s .l
     "  * cn poi up   <old-name> <relative-path-to-existing-directory>" .s .l
     "  * cn poi find <old-name>" .s .l
     "  * cn poi list" .s .l
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "test-cicada-play" "./play" <poi> add
   "test-cicada-play" <poi> find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play-2" "./play-2" <poi> add
   "test-cicada-play-2" <poi> find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play" "./contribution" <poi> up
   "test-cicada-play" <poi> find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play" <poi> sub
   "test-cicada-play" <poi> find
   if .s .l
   else "not found" .s .l
   then

   <poi> list

   <poi> help
   #+end_src
* path syntax
** +word+?
   #+begin_src cicada-nymph :tangle core.cn
   : +word+?
     << string[address, length] -- bool >>
     dup 1 less-or-equal? if
       drop2
       false
       end
     then
     over get-byte
     "+" <string> byte equal? not if
       drop2
       false
       end
     then
     add sub1 get-byte
     "+" <string> byte equal?
     end
   ; define-function
   #+end_src
** +word+->word
   #+begin_src cicada-nymph :tangle core.cn
   : +word+->word
     << +word+[address, length] -- name[address, length] >>
     sub2 swap
     add1 swap
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "+work+" +word+? .
   "work" +word+? .
   #+end_src
** note
   * path syntax can be implemented by a new *rule-set*
     but in the following
     I just simply implemented it
     as a rule in *rule-set,basic-REPL*
** note format
   #+begin_src cicada-nymph
   <<
   the following 4 poi are built in
   +root+
   +home+
   +work+
   +back+
   >>

   path: +root+ home xyh cicada core core.cn ;
   path: +home+ cicada core core.cn ;
   "/home/xyh/cicada/core/core.cn"

   path: +back+ cicada core core.cn ;
   "../cicada/core/core.cn"

   path: +work+ core core.cn ;
   path: core core.cn ;


   path: +library+ hi.cn ;
   "/home/xyh/cicada/library/hi.cn"
   #+end_src
** !bad-path-syntax-word
   #+begin_src cicada-nymph :tangle core.cn
   : bad-path-syntax-word,loop
     << -- >>
     read-word
     dup2 ";" <string> equal? if
       .s 32 .b
       end
     then
     .s 32 .b
     loop
   ; define-function

   : !bad-path-syntax-word
     << word -- >>
     "* (!bad-path-syntax-word) the following word is of bad syntax : " .s .l
     "    " .s .s .l
     exception-reset-stack
     << -- >>
     "  the rest of the words in path syntax is as following :" .s .l
     "    " .s bad-path-syntax-word,loop .l
     end
   ; define-exception
   #+end_src
** path-syntax-word->path
   #+begin_src cicada-nymph :tangle core.cn
   : path-syntax-word->path
     << word[address, length] -- path[address, length] >>
     >::word
     ::word "+root+" <string> equal? if
       "/"
       end
     then
     ::word "+work+" <string> equal? if
       get-work-directory
       end
     then
     ::word "+home+" <string> equal? if
       *home-directory*
       end
     then
     ::word "+back+" <string> equal? if
       ".."
       end
     then
     ::word +word+? not if
       ::word
       end
     then
     ::word +word+->word <poi> find if
       end
     then
     ::word
     !bad-path-syntax-word
   ; define-function
   #+end_src
** <basic-REPL-syntax> path
   #+begin_src cicada-nymph :tangle core.cn
   : <basic-REPL-syntax> path,loop
     << cursor -- cursor >>
     >:cursor
     read-word >::word

     ";" ::word <string> equal? if
       :cursor
       end
     then

     ::word path-syntax-word->path dup >:length
     :cursor
     string->buffer!

     :cursor :length add
       dup
       "/" <string> byte
       swap
       set-byte
     add1
     loop
   ; define-function

   : <basic-REPL-syntax> path
     << word:path: -- path[address, length] >>
     drop2

     prepare-for
       !bad-path-syntax-word
       end

     512 allocate-local-memory >:buffer
     :buffer <basic-REPL-syntax> path,loop >:cursor

     :cursor :buffer sub >:length

     *circular-string-area,current-free-address*
     >:address

     :buffer
     :length
     circular-string-area,stay

     :address
     :length
     end
   ; define-function
   #+end_src
** more,rule-set,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,basic-REPL
     << -- >>
     ["path:" <string> equal? end]
     jo <basic-REPL-syntax> path
     *rule-set,basic-REPL* add-rule
     end
   ; define-function
   more,rule-set,basic-REPL
   #+end_src
** test
   #+begin_src cicada-nymph
   path: +root+ home xyh cicada core core.cn ; .s
   path: +home+ cicada core core.cn ; .s

   path: +back+ cicada core core.cn ; .s

   path: +work+ core core.cn ; .s
   path: core core.cn ; .s

   "library" "library" <poi> add
   path: +library+ hi.cn ; .s
   "library" <poi> sub
   << error >>
   path: +library+ hi.cn ;
   #+end_src
* <string>
** <string> full-of-the-same-byte?
   #+begin_src cicada-nymph :tangle core.cn
   : <string> full-of-the-same-byte?
     << string[address, length], byte -- bool >>
     >:byte
     >::string
     ::string dup zero? if
       drop2
       true
       end
     then
     <string> byte :byte equal? not if
       false
       end
     then
     ::string <string> byte-tail
     :byte
     loop
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "aaa" "a" <string> byte <string> full-of-the-same-byte?
   "aba" "a" <string> byte <string> full-of-the-same-byte?
   #+end_src
** <string> any-word
   #+begin_src cicada-nymph :tangle core.cn
   : <string> any-word
     << string[address, length]
        function : < word[address, length] -- bool >
        -- bool >>
     >:function
     >::string
     ::string <string> space? if
       false
       end
     then
     ::string <string> word :function apply if
       true
       end
     then
     ::string <string> word-tail
     :function
     loop
   ; define-function
   #+end_src
** <string> every-word
   #+begin_src cicada-nymph :tangle core.cn
   : <string> every-word
     << string[address, length]
        function : < word[address, length] -- bool >
        -- bool >>
     >:function
     >::string
     ::string <string> space? if
       true
       end
     then
     ::string <string> word :function apply not if
       false
       end
     then
     ::string <string> word-tail
     :function
     loop
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     "no no name no" ["name" <string> equal? end] <string> any-word . << 1 >>
     "name name name" ["name" <string> equal? end] <string> every-word . << 1 >>
     .l
     "name name name" ["name" <string> equal? not end] <string> every-word . << 0 >>
     "no no name no" ["name" <string> equal? end] <string> every-word . << 0 >>
     .l
     end
   ; define-function
   test
   #+end_src
** <string> word-end-back
   #+begin_src cicada-nymph :tangle core.cn
   : <string> word-end-back
     << string[address, length] -- string[address, length] >>
     dup zero? if
       <<
       no error handling
       the same empty-string is returned
       >>
       end
     then
     dup2 <string> byte-back
     <string> byte space-byte? not if
       end
     then
     <string> byte-back
     loop
   ; define-function
   #+end_src
** <string> word-begin-back
   #+begin_src cicada-nymph :tangle core.cn
   : <string> word-begin-back,loop
     << string[address, length] -- string[address, length] >>
     dup zero? if
       <<
       no error handling
       the current empty-string is returned
       >>
       end
     then
     dup2 <string> byte-back
     <string> byte space-byte? if
       end
     then
     dup2 <string> byte-back
     <string> byte bar-ket-byte? if
       end
     then
     <string> byte-back
     loop
   ; define-function

   : <string> word-begin-back
     << string[address, length] -- string[address, length] >>
     dup zero? if
       <<
       no error handling
       the same empty-string is returned
       >>
       end
     then
     dup2 <string> byte-back
     <string> byte bar-ket-byte? if
       <string> byte-back
       end
     then
     <string> word-begin-back,loop
     end
   ; define-function
   #+end_src
** <string> word-back
   #+begin_src cicada-nymph :tangle core.cn
   : <string> word-back
     << string[address, length] -- string[address, length] >>
     <string> word-end-back
     <string> word-begin-back
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "   aaa   aaa   aaa"
   <string> word-tail dup2 .s << "   aaa   aaa" >>
   <string> word-back dup2 .s << "aaa   aaa   aaa" >>
   <string> word .s << "aaa" >>
   #+end_src
* reading-stack
** unread-word
   #+begin_src cicada-nymph :tangle core.cn
   : unread-word
     << -- >>
     pop-reading-stack
     <string> word-back
     push-reading-stack
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test
     << -- >>
     read-word "* read-word : " .s .s .l
     unread-word
     read-word "* read-word again : " .s .s .l
     end
   ; define-function
   test
   #+end_src
* ><>< module
** 記
*** 元數據 之 語法
    * 舉例
      #+begin_src cicada-nymph
      :::::::::
      import: combinator math
      module: assembler
      do: "assembler loaded" .s .l
      =========
      #+end_src
    * 元數據中所包含的信息應該只和如何運行這個程序有關
      因爲其他信息可能會在各個文件中重複
      這些可能重複的信息應該另行保存
    * 有了 元數據 之後
      就可以對文件實現相對豐富的謂詞
    * 元數據 中 所能包含的信息類型
      還有聲明這些信息的語法
      都是可以擴展的
    * 語法關鍵詞都形如 "word:"
      每次通過找下一個 "word:" 來確定其截止位置
    * 遇不被識別的 "word:"
      就忽略 而找到下一個 "word:"
*** 減載
    * 或者說 撤銷加載 (unload)
      它利用 (undo) 來實現
*** 加載棧
    * 加載棧 記錄
      1. 所有被加載的模塊的信息[模塊元數據字符串]
      2. 模塊被加載的順序
      3. 被加載的模塊是被直接加載還是間接加載
      4. 時間 路徑 等等 其他根系統狀態有關的元數據
    * (import) 就利用了這些信息
      用以聞訊
      同時
      這些信息 也可以幫助實現詳細的 report
*** 模塊命名棧 與 全局命名棧
    * 應該用兩種 命名棧
      全局命名棧[global-naming-stack] 所有名字都沒有 模塊前綴
      模塊命名棧[module-naming-stack] 所有名字都有 模塊前綴
    * 加載模塊時入 global-naming-stack
      之後統一移到 module-naming-stack
      這樣就不必更改 定義者 的接口了
      定義者 只要向 global-naming-stack 中入值 就行了
      根 module-naming-stack 有關的操作 由其他函數 另行完成
*** 模塊與文件一一對應
    * 要求 模塊與文件一一對應
      這種 對應關係影響對模塊機制的使用
    * 在啓動時
      解釋器不會加載 core 之外的任何 module
    * 所加載者 爲模塊 而非文件
      不用路徑來加載模塊
      而預先登記其路徑 然後直接通過模塊名來加載
    * 我提供 命令行函數 來幫助在啓動時加載模塊
*** 循環引入
    * 爲了處理循環引入
      我需要一個 importing-stack
      用以記錄 模塊之網中 由一點之引入所形成的有向路
      只要在增添新的有向邊的時候 不要形成圈 就行了
** module-naming-stack
*** note module-naming-stack
    * (define-*) push
      (undo) pop
*** note name-record
    * *module-naming-stack* contain name-record
    * structure
      | name-record | old-jo |
      |             | name   |
      |             | new-jo |
*** *module-naming-stack*
    #+begin_src cicada-nymph :tangle core.cn
    100 1024 mul
    : *module-naming-stack,size*
    ; define-variable,with-tos

    3 *jo-size* mul
    : *module-naming-stack,unit*
    ; define-variable,with-tos

    *module-naming-stack,size*
    *module-naming-stack,unit* mul allocate-memory
    : *module-naming-stack*
    ; define-variable,with-tos

    *module-naming-stack*
    : *module-naming-stack,pointer*
    ; define-variable,with-tos
    #+end_src
** <moi>
*** note
    * like <poi>
*** *module-directory*
    * one directory to store the name path record
      "/home/<user>/.cicada/module"
    #+begin_src cicada-nymph :tangle core.cn
    : *module-directory,user,address*
      512 allocate-memory
    ; define-variable

    : *module-directory*
      *home-directory* "/.cicada/moi"
      *module-directory,user,address*
      2 n-string->buffer!
      *module-directory,user,address* swap
    ; define-variable
    #+end_src
*** <moi> find
    * note that
      this function uses *circular-string-area*
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> find
      << name[address, length]
         -- path[address, length], true
         -- false >>
      >::name
      512 allocate-local-memory >:buffer
      *module-directory* "/" ::name "/path"
      :buffer
      4 n-string->buffer! >:length

      :buffer :length
      path,file? not if
        false
        end
      then

      512 allocate-local-memory >:read-buffer
      :read-buffer 512
      :buffer :length
      <file> read >:read-length

      *circular-string-area,current-free-address*
      >:path-address

      :read-buffer :read-length
      circular-string-area,stay

      :path-address
      :read-length
      true
      end
    ; define-function
    #+end_src
*** <moi> add
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> add
      << name[address, length], relative-path[address, length] -- >>
      >::relative-path
      >::name

      ::relative-path relative-path? not if
        "* (<moi> add) the argument must be a relative-path" .s .l
        "  but the following is not : " .s ::relative-path .s .l
        end
      then

      ::relative-path path,file? not if
        "* (<moi> add) the argument must be a relative-path to a existing file" .s .l
        "  but the following path is not to a file : " .s ::relative-path .s .l
        end
      then

      ::name <moi> find if
        "* (<moi> add) can not add" .s .l
        "  for the following module already exist : " .s ::name .s .l
        "  name is use as the following directory's name : " .s .s .l
        end
      then

      512 allocate-local-memory >:buffer
      *module-directory* "/" ::name
      :buffer
      3 n-string->buffer!
      >:length
      :buffer :length
      <directory> create

      *module-directory* "/" ::name "/path"
      :buffer
      4 n-string->buffer!
      >:length
      :buffer :length
      <file> create

      512 allocate-local-memory >:address,full-path
      get-work-directory "/" ::relative-path
      :address,full-path
      3 n-string->buffer! >:length,full-path

      :address,full-path :length,full-path
      :buffer :length
      <file> write
      end
    ; define-function
    #+end_src
*** <moi> sub
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> sub
      << name[address, length] -- >>
      >::name

      ::name <moi> find not if
        "* (<moi> sub) can not sub" .s .l
        "  for the following module does not exist : " .s ::name .s .l
        end
      then
      >::named-directory

      512 allocate-local-memory >:buffer
      *module-directory* "/" ::name "/path"
      :buffer
      4 n-string->buffer! >:length

      :buffer :length
      <file> remove

      *module-directory* "/" ::name
      :buffer
      3 n-string->buffer!
      >:length
      :buffer :length
      <directory> remove
      end
    ; define-function
    #+end_src
*** <moi> up
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> up
      << name[address, length], relative-path[address, length] -- >>
      >::relative-path
      >::name

      ::relative-path relative-path? not if
        "* (<moi> up) the argument must be a relative-path" .s .l
        "  but the following is not : " .s ::relative-path .s .l
        end
      then

      ::relative-path path,file? not if
        "* (<moi> up) the argument must be a relative-path to a existing file" .s .l
        "  but the following file is not exist : " .s ::relative-path .s .l
        end
      then

      ::name <moi> find not if
        "* (<moi> up) can not up" .s .l
        "  for the following module does not exist : " .s ::name .s .l
        end
      then
      >::named-directory

      512 allocate-local-memory >:buffer
      *module-directory* "/" ::name "/path"
      :buffer
      4 n-string->buffer! >:length

      512 allocate-local-memory >:address,full-path
      get-work-directory "/" ::relative-path
      :address,full-path
      3 n-string->buffer! >:length,full-path

      :address,full-path :length,full-path
      :buffer :length
      <file> write
      end
    ; define-function
    #+end_src
*** <moi> list
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> list
      << -- >>
      *module-directory*
      [ << -- >>
        +getdents64,d_type+ get-byte
        4 equal? if
          512 allocate-local-memory >:path-buffer
          +getdents64,d_name+
          dup 256
          0 <string> find-byte
          drop  << drop 0 >>
          over sub >::name

          ".." ::name <string> equal? if
            end
          then

          "." ::name <string> equal? if
            end
          then

          "  * " .s ::name .s .l
          "      " .s

          *module-directory* "/" ::name "/path"
          :path-buffer
          4 n-string->buffer! >:path-length

          512 allocate-local-memory >:reading-buffer
          :reading-buffer 512
          :path-buffer :path-length
          <file> read >:reading-length

          :reading-buffer :reading-length
          .s .l
        then
        end ]
      <directory> map
      end
    ; define-function
    #+end_src
*** <moi> help
    #+begin_src cicada-nymph :tangle core.cn
    : <moi> help
      << -- >>
      "* (<moi> help)" .s .l
      "  * cn module add  <new-name> <relative-path-to-existing-directory>" .s .l
      "  * cn module sub  <old-name>" .s .l
      "  * cn module up   <old-name> <relative-path-to-existing-directory>" .s .l
      "  * cn module find <old-name>" .s .l
      "  * cn module list" .s .l
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "test-cicada-play" "./play" <moi> add
    "test-cicada-play" <moi> find
    if .s .l
    else "not found" .s .l
    then

    "test-cicada-play-2" "./play-2" <moi> add
    "test-cicada-play-2" <moi> find
    if .s .l
    else "not found" .s .l
    then

    "test-cicada-play" "./contribution" <moi> up
    "test-cicada-play" <moi> find
    if .s .l
    else "not found" .s .l
    then

    "test-cicada-play" <moi> sub
    "test-cicada-play" <moi> find
    if .s .l
    else "not found" .s .l
    then

    <moi> list

    <moi> help
    #+end_src
** <module-stack> & <module-info>
*** *module-stack*
    #+begin_src cicada-nymph :tangle core.cn
    10 1024 mul
    : *module-stack,size*
    ; define-variable,with-tos

    5 *jo-size* mul
    : *module-stack,unit*
    ; define-variable,with-tos

    *module-stack,size*
    *module-stack,unit* mul allocate-memory
    : *module-stack*
    ; define-variable,with-tos

    *module-stack*
    : *module-stack,pointer*
    ; define-variable,with-tos
    #+end_src
*** note <module-info>
    * *module-stack* contain module-info
    * structure
      | module-info | meta-string address |
      |             | meta-string length  |
      |             | name                |
      |             | name-record-begin   |
      |             | name-record-end     |
*** <module-info> [get|set]-meta-string
    #+begin_src cicada-nymph :tangle core.cn
    : <module-info> get-meta-string
      << module-info -- meta-string[address, length] >>
      2 n-get
      end
    ; define-function

    : <module-info> set-meta-string
      << meta-string[address, length], module-info -- >>
      xx|swap|x make-string x|swap|xx
      2 n-set
      end
    ; define-function
    #+end_src
*** <module-info> [get|set]-name
    #+begin_src cicada-nymph :tangle core.cn
    : <module-info> get-name
      << module-info -- name >>
      *jo-size* 2 mul add
      get
      end
    ; define-function

    : <module-info> set-name
      << name, module-info -- >>
      *jo-size* 2 mul add
      set
      end
    ; define-function
    #+end_src
*** <module-info> [get|set]-name-record-begin
    #+begin_src cicada-nymph :tangle core.cn
    : <module-info> get-name-record-begin
      << module-info -- name >>
      *jo-size* 3 mul add
      get
      end
    ; define-function

    : <module-info> set-name-record-begin
      << name, module-info -- >>
      *jo-size* 3 mul add
      set
      end
    ; define-function
    #+end_src
*** <module-info> [get|set]-name-record-end
    #+begin_src cicada-nymph :tangle core.cn
    : <module-info> get-name-record-end
      << module-info -- name >>
      *jo-size* 4 mul add
      get
      end
    ; define-function

    : <module-info> set-name-record-end
      << name, module-info -- >>
      *jo-size* 4 mul add
      set
      end
    ; define-function
    #+end_src
*** <module-stack> find
    #+begin_src cicada-nymph :tangle core.cn
    : <module-stack> find,loop
      << name[index], cursor
         -- module-info, true
         -- false >>
      dup *module-stack,pointer* equal? if
        drop2
        false
        end
      then
      >:cursor
      >:name
      :cursor <module-info> get-name
      :name equal? if
        :cursor
        true
        end
      then
      :name
      :cursor *module-stack,unit* add
      loop
    ; define-function

    : <module-stack> find
      << name[index]
         -- module-info, true
         -- false >>
      *module-stack*
      <module-stack> find,loop
      end
    ; define-function
    #+end_src
** <importing-stack> & <importing-record>
*** *importing-stack*
    #+begin_src cicada-nymph :tangle core.cn
    10 1024 mul
    : *importing-stack,size*
    ; define-variable,with-tos

    1 *jo-size* mul
    : *importing-stack,unit*
    ; define-variable,with-tos

    *importing-stack,size*
    *importing-stack,unit* mul allocate-memory
    : *importing-stack*
    ; define-variable,with-tos

    *importing-stack*
    : *importing-stack,pointer*
    ; define-variable,with-tos
    #+end_src
*** note <importing-record>
    * structure
      | importing-record | name |
*** <importing-record> [get|set]-name
    #+begin_src cicada-nymph :tangle core.cn
    : <importing-record> get-name
      << module-info -- name >>
      get
      end
    ; define-function

    : <importing-record> set-name
      << name, module-info -- >>
      set
      end
    ; define-function
    #+end_src
*** <importing-stack> find
    #+begin_src cicada-nymph :tangle core.cn
    : <importing-stack> find,loop
      << name[index], cursor
         -- importing-record, true
         -- false >>
      dup *importing-stack,pointer* equal? if
        drop2
        false
        end
      then
      >:cursor
      >:name
      :cursor <importing-record> get-name
      :name equal? if
        :cursor
        true
        end
      then
      :name
      :cursor *importing-stack,unit* add
      loop
    ; define-function

    : <importing-stack> find
      << name[index]
         -- importing-record, true
         -- false >>
      *importing-stack*
      <importing-stack> find,loop
      end
    ; define-function
    #+end_src
*** <importing-record> drop
    #+begin_src cicada-nymph :tangle core.cn
    : <importing-record> drop
      << -- >>
      *importing-stack,unit* address *importing-stack,pointer* sub-set
      end
    ; define-function
    #+end_src
** module-meta-word?
   #+begin_src cicada-nymph :tangle core.cn
   : module-meta-word?
     << string[address, length] -- bool >>
     dup 1 less-or-equal? if
       drop2
       false
       end
     then
     >:length
     >:address
     :address :length add get-byte >:last-byte
     :address :length add sub1 get-byte >:the-byte-before-last-byte
     :last-byte
     ":" <string> byte equal? not if
       false
       end
     then
     :the-byte-before-last-byte
     ":" <string> byte equal? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** <pre-module>
*** meta-word:import?
    #+begin_src cicada-nymph :tangle core.cn
    : meta-word:import?
      << word[address, length] -- bool >>
      "import:" <string> equal?
      end
    ; define-function
    #+end_src
*** ><>< <pre-module-syntax> import
    #+begin_src cicada-nymph :tangle core.cn
    : <pre-module-syntax> import
      << -- >>

      end
    ; define-function
    #+end_src
*** ><>< <pre-module-syntax> unknow-meta-word
    #+begin_src cicada-nymph :tangle core.cn
    : <pre-module-syntax> unknow-meta-word
      << meta-word -- >>

      end
    ; define-function
    #+end_src
*** <pre-module-syntax> begin
    #+begin_src cicada-nymph :tangle core.cn
    : <pre-module-syntax> begin
      << -- >>
      jo meta-word:import?
      jo <pre-module-syntax> import
      <basic-REPL> *rule-set* add-rule

      jo module-meta-word?
      jo <pre-module-syntax> unknow-meta-word
      <basic-REPL> *rule-set* add-rule
      end
    ; define-function
    #+end_src
*** <pre-module-syntax> end
    #+begin_src cicada-nymph :tangle core.cn
    : <pre-module-syntax> end
      << -- >>
      jo meta-word:import?
      jo <pre-module-syntax> import
      <basic-REPL> *rule-set* sub-rule

      jo module-meta-word?
      jo <pre-module-syntax> unknow-meta-word
      <basic-REPL> *rule-set* sub-rule
      end
    ; define-function
    #+end_src
** <post-module>
*** meta-word:do?
    #+begin_src cicada-nymph :tangle core.cn
    : meta-word:do?
      << word[address, length] -- bool >>
      "do:" <string> equal?

      end
    ; define-function
    #+end_src
*** ><>< <post-module-syntax> do
    #+begin_src cicada-nymph :tangle core.cn

    #+end_src
** <module-buffer>
*** <string> module-meta-begin?
    #+begin_src cicada-nymph :tangle core.cn
    : <string> module-meta-begin?
      << string[address, length] -- bool >>
      dup 6 less-than? if
        drop2
        false
        end
      then
      ":" <string> byte
      <string> full-of-the-same-byte?
      end
    ; define-function
    #+end_src
*** <string> module-meta-end?
    #+begin_src cicada-nymph :tangle core.cn
    : <string> module-meta-end?
      << string[address, length] -- bool >>
      dup 6 less-than? if
        drop2
        false
        end
      then
      "=" <string> byte
      <string> full-of-the-same-byte?
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "::::::" <string> module-meta-begin? . << 1 >>
    "======" <string> module-meta-end? . << 1 >>

    ":::::" <string> module-meta-begin? . << 0 >>
    "=====" <string> module-meta-end? . << 0 >>

    ":::><:::" <string> module-meta-begin? . << 0 >>
    "===><===" <string> module-meta-end? . << 0 >>
    #+end_src
*** 記 謂詞
    * 作用於 module-buffer 的函數
      均假設 module-buffer 格式良好
      在調用它們之前
      應該利用有關謂詞保證其格式良好
    * 謂詞是針對 module-buffer 的
      [即 針對字符串的]
      而不是針對文件的
      否則就會重複閱讀文件
*** <module-buffer> good-format?
    #+begin_src cicada-nymph :tangle core.cn
    : <module-buffer> good-format?
      << module-buffer[address, length] -- bool >>
      dup2 <string> space? if
        drop2
        false
        end
      then
      dup2 <string> word
      <string> module-meta-begin? not if
        drop2
        false
        end
      then
      jo <string> module-meta-end? <string> any-word
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "
    :::::::::
    import: combinator math
    module: assembler
    =========
    hi
    kkk took my baby away!
    "
    <module-buffer> good-format? . << 1 >>

    "
    :::::::::
    import: combinator math
    module: assembler
    hi
    kkk took my baby away!
    "
    <module-buffer> good-format? . << 0 >>
    #+end_src
*** <module-buffer> get-code-string
    #+begin_src cicada-nymph :tangle core.cn
    : <module-buffer> get-code-string
      << module-buffer[address, length] -- meta-string[address, length] >>
      dup2 <string> word
      <string> module-meta-end? if
        <string> word-tail
        end
      then
      <string> word-tail
      loop
    ; define-function
    #+end_src
*** <module-buffer> get-meta-string
    #+begin_src cicada-nymph :tangle core.cn
    : <module-buffer> get-meta-string,loop
      << module-buffer[address, length] -- cursor >>
      dup2 <string> word
      <string> module-meta-end? if
        drop
        end
      then
      <string> word-tail
      loop
    ; define-function

    : <module-buffer> get-meta-string
      << module-buffer[address, length] -- meta-string[address, length] >>
      <string> word-tail
      dup2 <module-buffer> get-meta-string,loop >:cursor
      drop >:address
      :address
      :cursor :address sub
      end
    ; define-function
    #+end_src
*** test
    #+begin_src cicada-nymph
    "
    :::::::::
    import: combinator math
    module: assembler
    =========
    hi
    kkk took my baby away!
    "
    <module-buffer> get-code-string .s
    #+end_src
** exception
*** >< !fail-to-load
    #+begin_src cicada-nymph

    #+end_src
*** >< !circular-import
    #+begin_src cicada-nymph

    #+end_src
** 記 避免相互遞歸函數
   * 沒有相互遞歸函數 (load) (import) 不可相互調用
     加載[load] 不是遞歸函數 它等待 exception 而不調用 exception
     引入[import] 是遞歸函數 它調用 exception 而不等待 exception
   * 分析一下遞歸函數
     每次分析遞歸函數 就是要知道
     1. 如何展開 每個遞歸調用就是展開
        展開就是
        返回棧增加一珠珠
        分配內存給局部數據
     2. 如何收回 每次函數退出就是收回
     3. 比如
        pre-function
        recur
        post-function
        end
        其中 pre-function 是展開過程中調用的函數 調用它們的順序是 珠珠 入棧的順序
        而 post-function 是收回過程中調用的函數 調用它們的順序是 珠珠 出棧的順序
        考錄 返回棧 之變化情況就很清楚啦
     這次
     1. 展開
        入 引入棧
     2. 遞歸
        遞歸發生在 對語法關鍵詞 "import:" 的處理過程中
     3. 返回
        入 加載棧
        解釋代碼
** <global-naming-stack> & <module-naming-stack>
*** ---------------------------------
*** 記 接口
    * 每個 模塊 都對應於 module-naming-stack 中的兩個 name-record
      一個開始
      一個結束
      因此接口就要圍繞這對值來設計
    * undo 中關於 global-naming-stack 和 module-naming-stack 的部分
      可以利用這裏的接口
    * (clear-naming)
      name-record-begin <-- name-record-end
      (prefix-naming)
      name-record-begin --> name-record-end
      (expose-naming)
      name-record-begin --> name-record-end
*** ---------------------------------
*** <module-naming-stack> record-jo
    #+begin_src cicada-nymph :tangle core.cn
    : <module-naming-stack> record-jo
      << jo, name -- >>
      dup name,get-jo
      *module-naming-stack,pointer* name-record,set-old-jo
      dup2 name,set-jo
      *module-naming-stack,pointer* name-record,set-name
      *module-naming-stack,pointer* name-record,set-new-jo
      *module-naming-stack,unit* address *module-naming-stack,pointer* add-set
      end
    ; define-function
    #+end_src
*** <module-naming-stack> delete-last-record
    #+begin_src cicada-nymph :tangle core.cn
    : <module-naming-stack> delete-last-record
      << -- >>
      *module-naming-stack,unit*
      address *module-naming-stack,pointer*
      sub-set
      *module-naming-stack,pointer* name-record,get-old-jo
      *module-naming-stack,pointer* name-record,get-name
      name,set-jo
      end
    ; define-function
    #+end_src
*** ---------------------------------
*** <global-naming-stack> clear-naming
    #+begin_src cicada-nymph :tangle core.cn
    : <global-naming-stack> clear-naming
      << name-record-begin, name-record-end -- >>
      dup2 equal? if
        drop2
        end
      then
      *global-naming-stack,unit* sub
      dup >:name-record
      :name-record <name-record> get-old-jo
      :name-record <name-record> get-name
      name,set-jo
      loop
    ; define-function
    #+end_src
*** <module-naming-stack> clear-naming
    #+begin_src cicada-nymph :tangle core.cn
    : <module-naming-stack> clear-naming
      << name-record-begin, name-record-end -- >>
      dup2 equal? if
        drop2
        end
      then
      *module-naming-stack,unit* sub
      dup >:name-record
      :name-record <name-record> get-old-jo
      :name-record <name-record> get-name
      name,set-jo
      loop
    ; define-function
    #+end_src
*** ---------------------------------
*** <global-naming-stack> prefix-naming
    #+begin_src cicada-nymph :tangle core.cn
    : <global-naming-stack> prefix-naming
      << name-record-begin, name-record-end, prefix[name-index] -- >>
      >:prefix
      >:end
      >:begin
      :end :begin equal? if
        end
      then

      512 allocate-local-memory >:buffer
      :prefix name->string " " :begin <name-record> get-name name->string
      :buffer 3 n-string->buffer! >:length

      :begin <name-record> get-new-jo
      :buffer :length string->name
      <module-naming-stack> record-jo

      :begin *global-naming-stack,unit* add
      :end
      :prefix
      loop
    ; define-function
    #+end_src
*** <module-naming-stack> expose-naming
    #+begin_src cicada-nymph :tangle core.cn
    : <module-naming-stack> expose-naming
      << name-record-begin, name-record-end -- >>
      >:end
      >:begin
      :end :begin equal? if
        end
      then

      :begin <name-record> get-new-jo
      :begin <name-record> get-name
      name->string
      <string> word-tail <string> byte-tail
      string->name
      <global-naming-stack> record-jo

      :begin *module-naming-stack,unit* add
      :end
      loop
    ; define-function
    #+end_src
*** ---------------------------------
** name->module-prefix
   #+begin_src cicada-nymph :tangle core.cn
   : name->module-prefix
     << name[index] -- module-prefix[index] >>
     >:name

     512 allocate-local-memory >:buffer

     "|" :name name->string "|"
     :buffer
     3 n-string->buffer! >:length

     :buffer
     :length
     string->name
     end
   ; define-function
   #+end_src
** ><>< import
   * 遞歸調用發生在 處理 語法關鍵詞 import 時
     那時需要做兩件事
     一是 引入
     二是 化名
   #+begin_src cicada-nymph :tangle core.cn
   : import
     << module-name-string[address, length] -- >>
     >::module-name-string
     ::module-name-string string->name >:module-name-index
     :module-name-index name->module-prefix >:module-prefix

     :module-name-index <module-stack> find if
       drop
       end
     then

     :module-name-index <importing-stack> find if
       "* (import) circular import of : " .s ::module-name-string .s .l
       end
     then

     ::module-name-string <moi> find not if
       "* (import) can not find module : " .s ::module-name-string .s .l
       end
     then
     >::module-path

     64 1024 mul allocate-local-memory >:buffer

     :buffer
     64 1024 mul
     ::module-path
     <file> read >:length

     :buffer :length <module-buffer> good-format? not if
       "* (import) fail to import module : " .s ::module-name-string .s .l
       "  for the file is not well formated cicada-nymph source code" .s .l
       end
     then

     :buffer :length <module-buffer> get-meta-string >::meta-string
     :buffer :length <module-buffer> get-code-string >::code-string

     *importing-stack,pointer* >:importing-record
     *importing-stack,unit* address *importing-stack,pointer* add-set

     :module-name-index
     :importing-record
     <importing-record> set-name

     <<
     <pre-module-syntax> begin
     ::meta-string eval-string
     <pre-module-syntax> end
     >>

     *global-naming-stack,pointer* >:global-name-record-begin
     ::code-string eval-string
     *global-naming-stack,pointer* >:global-name-record-end

     <<
     <post-module-syntax> begin
     ::meta-string eval-string
     <post-module-syntax> end
     >>

     <importing-record> drop

     *module-naming-stack,pointer* >:module-name-record-begin
     :global-name-record-begin
     :global-name-record-end
     :module-prefix
     <global-naming-stack> prefix-naming
     *module-naming-stack,pointer* >:module-name-record-end

     :global-name-record-begin
     :global-name-record-end
     <global-naming-stack> clear-naming

     *module-stack,pointer* >:module-info
     *module-stack,unit* address *module-stack,pointer* add-set

     :module-name-record-begin
     :module-info
     <module-info> set-name-record-begin

     :module-name-record-end
     :module-info
     <module-info> set-name-record-end

     ::meta-string
     :module-info
     <module-info> set-meta-string

     :module-name-index
     :module-info
     <module-info> set-name
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   << in system shell
   cn moi add hihi play/hi.cn
   >>
   "hihi" import

   hihi << undefined >>

   : *test-module-info*
     name hihi <module-stack> find if
     else
       "* can not found hihi" .s .l
     then
   ; define-variable

   *test-module-info* <module-info> get-meta-string .s .l
   *test-module-info* <module-info> get-name name->string .s .l

   *test-module-info* <module-info> get-name-record-begin
   *test-module-info* <module-info> get-name-record-end
   <module-naming-stack> expose-naming

   hihi
   #+end_src
** >< load
   #+begin_src cicada-nymph
   : load
     << module-name-string[address, length] -- >>
     prepare-for
       !kkk
       end
     import
     end
   ; define-function
   #+end_src
* undo
** 記 撤銷
   * 因爲 name-hash-table 的存在
     導致我實現 undo 這個特性的機制
     必須是去記錄差別 而不能是記錄歷史
   * 具體地
     在每個 undo-point 之後
     所有對 jo 的 redefine 都需要被記錄
     在需要退回到這個 undo-point 之時
     恢復這些被從 name-hash-table 中踢出去的 jo
   * 這樣
     每一個 jo 被踢出 name-hash-table 時
     會存入 jo name 的對子在 undo-stack 中
   * 注意
     每一次重新定義都對應一次恢復
     * 缺點是
       這樣 在兩個 undo-point 之間 對一個 jo 的多次重複定義
       就帶來了一些沒必要的恢復
     * 優點是
       這樣就避免了對 多次重複定義的 jo 的特殊處理
       不論是在效率上
       還是實現的簡潔性上
       這種實現方式都是更優的
** note global states
   * jojo-area
   * string-area
   * name-hash-table
   * global-naming-stack
   * module-naming-stack
   * syntax-backup-area
   * syntax-stack
     and rule-set in it
** *undo-stack*
   #+begin_src cicada-nymph :tangle core.cn
   60 1024 mul
   : *undo-stack,size*
   ; define-variable,with-tos

   6 *jo-size* mul
   : *undo-stack,unit*
   ; define-variable,with-tos

   *undo-stack,size*
   *undo-stack,unit* mul allocate-memory
   : *undo-stack*
   ; define-variable,with-tos

   *undo-stack*
   : *undo-stack,pointer*
   ; define-variable,with-tos
   #+end_src
** note undo-point
   * *undo-stack* contain undo-point
   * structure
     | undo-point | jojo-area           |
     |            | string-area         |
     |            | global-naming-stack |
     |            | module-naming-stack |
     |            | syntax-backup-area  |
     |            | number of rule-sets |
   * the undo-point used to undo
     will be used to reset the pointer of undo-stack
     [the current-free-address of undo-stack]
** interface of <undo-point>
*** <undo-point> [get|set]-jojo-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-jojo-area
      << undo-point -- jojo-area current-free-address >>
      get
      end
    ; define-function

    : <undo-point> set-jojo-area
      << jojo-area current-free-address, undo-point -- >>
      set
      end
    ; define-function
    #+end_src
*** <undo-point> [get|set]-string-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-string-area
      << undo-point -- jojo-area current-free-address >>
      *jo-size* add get
      end
    ; define-function

    : <undo-point> set-string-area
      << jojo-area current-free-address, undo-point -- >>
      *jo-size* add set
      end
    ; define-function
    #+end_src
*** <undo-point> [get|set]-global-naming-stack
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-global-naming-stack
      << undo-point -- jojo-area current-free-address >>
      *jo-size* 2 mul add get
      end
    ; define-function

    : <undo-point> set-global-naming-stack
      << jojo-area current-free-address, undo-point -- >>
      *jo-size* 2 mul add set
      end
    ; define-function
    #+end_src
*** <undo-point> [get|set]-module-naming-stack
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-module-naming-stack
      << undo-point -- jojo-area current-free-address >>
      *jo-size* 3 mul add get
      end
    ; define-function

    : <undo-point> set-module-naming-stack
      << jojo-area current-free-address, undo-point -- >>
      *jo-size* 3 mul add set
      end
    ; define-function
    #+end_src
*** <undo-point> [get|set]-syntax-backup-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-syntax-backup-area
      << undo-point -- jojo-area current-free-address >>
      *jo-size* 4 mul add get
      end
    ; define-function

    : <undo-point> set-syntax-backup-area
      << jojo-area current-free-address, undo-point -- >>
      *jo-size* 4 mul add set
      end
    ; define-function
    #+end_src
*** <undo-point> [get|set]-number-of-rule-sets
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> get-number-of-rule-sets
      << undo-point -- jojo-area current-free-address >>
      *jo-size* 5 mul add get
      end
    ; define-function

    : <undo-point> set-number-of-rule-sets
      << jojo-area current-free-address, undo-point -- >>
      *jo-size* 5 mul add set
      end
    ; define-function
    #+end_src
** *syntax-backup-area*
   #+begin_src cicada-nymph :tangle core.cn
   20 1024 mul
   *jo-size* mul
   : *syntax-backup-area,size*
   ; define-variable,with-tos

   *syntax-backup-area,size* allocate-memory
   : *syntax-backup-area*
   ; define-variable,with-tos

   *syntax-backup-area*
   : *syntax-backup-area,current-free-address*
   ; define-variable,with-tos
   #+end_src
** <undo-point> create
*** 記
    * 將 undo-point 這個數據結構入 undo-stack
      並返回剛入棧的數據結構的地址
*** <undo-point> create,copy-syntax,one-rule-set
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> create,copy-syntax,one-rule-set
      << rule-set -- >>
      >:rule-set
      :rule-set rule-set,get-border >:border
      :border :rule-set sub
      *jo-size* div >:n

      :rule-set
      *syntax-backup-area,current-free-address* set
      *jo-size* address *syntax-backup-area,current-free-address* add-set

      :n
      *syntax-backup-area,current-free-address* set
      *jo-size* address *syntax-backup-area,current-free-address* add-set

      :rule-set
      :n n-get
      *syntax-backup-area,current-free-address*
      :n n-set
      *jo-size* :n mul
      address *syntax-backup-area,current-free-address* add-set
      end
    ; define-function
    #+end_src
*** <undo-point> create,copy-syntax
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> create,copy-syntax
      << cursor -- >>
      dup *syntax-stack,pointer* equal? if
        drop
        end
      then
      dup get <undo-point> create,copy-syntax,one-rule-set
      *jo-size* add
      loop
    ; define-function
    #+end_src
*** <undo-point> create
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> create
      << -- undo-point >>
      *undo-stack,pointer*
      >:undo-point

      *undo-stack,unit*
      address *undo-stack,pointer*
      add-set

      *jojo-area,current-free-address*
      :undo-point
      <undo-point> set-jojo-area

      *string-area,current-free-address*
      :undo-point
      <undo-point> set-string-area

      *global-naming-stack,pointer*
      :undo-point
      <undo-point> set-global-naming-stack

      *module-naming-stack,pointer*
      :undo-point
      <undo-point> set-module-naming-stack

      *syntax-backup-area,current-free-address*
      :undo-point
      <undo-point> set-syntax-backup-area

      *syntax-stack,address*
      <undo-point> create,copy-syntax

      *syntax-stack,pointer*
      *syntax-stack,address* sub
      *jo-size* div
      :undo-point
      <undo-point> set-number-of-rule-sets

      :undo-point
      end
    ; define-function
    #+end_src
** <undo-point> restore
*** <undo-point> restore-jojo-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-jojo-area
      << undo-point -- >>
      <undo-point> get-jojo-area
      address *jojo-area,current-free-address*
      set
      end
    ; define-function
    #+end_src
*** <undo-point> restore-string-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-string-area
      << undo-point -- >>
      <undo-point> get-string-area
      address *string-area,current-free-address*
      set
      end
    ; define-function
    #+end_src
*** <undo-point> restore-global-naming-stack
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-global-naming-stack
      << undo-point -- >>
      <undo-point> get-global-naming-stack >:old-record

      :old-record
      *global-naming-stack,pointer*
      <global-naming-stack> clear-naming

      :old-record address *global-naming-stack,pointer* set
      end
    ; define-function
    #+end_src
*** <undo-point> restore-module-naming-stack
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-module-naming-stack
      << undo-point -- >>
      <undo-point> get-module-naming-stack >:old-record

      :old-record
      *module-naming-stack,pointer*
      <module-naming-stack> clear-naming

      :old-record address *module-naming-stack,pointer* set
      end
    ; define-function
    #+end_src
*** 記 語法棧的備份
    * 複製出去的時候 從頭到尾[從棧底到棧頂]掃描 語法棧
      複製回來的時候 從頭到尾掃描 語法備份區
    * 規則集 本身做爲數據結構的存在是
      |          | border    |
      |----------+-----------|
      | rule-set | predicate |
      |          | function  |
      |----------+-----------|
      |          | predicate |
      |          | function  |
      |----------+-----------|
      |          | ...       |
    * 語法棧中的每一個 規則集 在備份中的存在是
      | address |
      | length  |
      | jo      |
      | jo      |
      | ...     |
      此處把 jo 按順序複製回 address 所代表的 規則集
      然後重置 current-free-address 就行了
      並不必知道 jo 的語義
*** <undo-point> restore-syntax-backup-area,set-syntax
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-syntax-backup-area,set-syntax
      << cursor, rule-set-copy, number-of-rule-sets -- cursor >>
      dup zero? if
        drop2
        end
      then
      >:number-of-rule-sets
      >:rule-set-copy
      >:cursor

      :rule-set-copy get >:rule-set
      :rule-set-copy *jo-size* add get >:n

      :rule-set :cursor set

      :rule-set-copy *jo-size* 2 mul add
      :n n-get
      :rule-set
      :n n-set

      *jo-size*
      :n mul
      :rule-set add
      :rule-set rule-set,set-border

      :cursor *jo-size* add
      :rule-set-copy *jo-size* :n 2 add mul add
      :number-of-rule-sets sub1
      loop
    ; define-function
    #+end_src
*** <undo-point> restore-syntax-backup-area
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-syntax-backup-area
      << undo-point -- >>
      >:undo-point
      :undo-point <undo-point> get-syntax-backup-area >:old-address
      :undo-point <undo-point> get-number-of-rule-sets >:number-of-rule-sets

      *syntax-stack,address*
      :old-address
      :number-of-rule-sets
      <undo-point> restore-syntax-backup-area,set-syntax >:cursor

      :cursor
      address *syntax-stack,pointer*
      set

      :old-address
      address *syntax-backup-area,current-free-address*
      set
      end
    ; define-function
    #+end_src
*** <undo-point> restore-undo-stack
    #+begin_src cicada-nymph :tangle core.cn
    : <undo-point> restore-undo-stack
      << undo-point -- >>
      address *undo-stack,pointer*
      set
      end
    ; define-function
    #+end_src
** undo
   #+begin_src cicada-nymph :tangle core.cn
   : undo
     << undo-point -- >>
     >:undo-point
     :undo-point <undo-point> restore-jojo-area
     :undo-point <undo-point> restore-string-area
     :undo-point <undo-point> restore-global-naming-stack
     :undo-point <undo-point> restore-module-naming-stack
     :undo-point <undo-point> restore-syntax-backup-area
     :undo-point <undo-point> restore-undo-stack
     end
   ; define-function
   #+end_src
** test undo
   #+begin_src cicada-nymph
   <undo-point> create
   : *undo-point*
   ; define-variable,with-tos

   : test,undo
     << -- >>
     "testing undo" .s .l
     end
   ; define-function

   test,undo << testing undo >>

   *undo-point* undo

   test,undo << undefined >>

   *undo-point* << undefined >>


   << with global-naming-stack >>

   <undo-point> create
   : *undo-point*
   ; define-variable,with-tos

   : test,undo
     << -- >>
     "before undo" .s .l
     end
   ; define-function

   test,undo << before undo >>

   : test,undo
     << -- >>
     "after undo" .s .l
     end
   ; define-function

   test,undo << after undo >>

   *undo-point* undo

   test,undo << undefined >>

   *undo-point* << undefined >>
   #+end_src
** test undo with syntax-stack
   #+begin_src cicada-nymph
   <undo-point> create
   : *undo-point*
   ; define-variable,with-tos

   jo integer-string?
   jo hi
   *rule-set,basic-REPL* add-rule

   *rule-set,basic-REPL* push-syntax-stack

   123 drop2 << hi >>

   *syntax-stack,pointer*
   *syntax-stack,address* sub
   *jo-size* div . << 2 >>

   <<
   <report> syntax
   >>

   *undo-point* undo

   123 . << 123 >>

   *syntax-stack,pointer*
   *syntax-stack,address* sub
   *jo-size* div . << 1 >>

   <<
   <report> syntax
   >>
   #+end_src
** test undo with alias
   #+begin_src cicada-nymph
   <undo-point> create
   : *undo-point*
   ; define-variable,with-tos

   : test,undo
     << -- >>
     "testing undo" .s .l
     end
   ; define-function

   "t,u" "test,undo" alias

   test,undo << testing undo >>
   t,u << testing undo >>

   *undo-point* undo

   test,undo << undefined >>
   t,u << undefined >>

   *undo-point* << undefined >>


   << with global-naming-stack >>

   <undo-point> create
   : *undo-point*
   ; define-variable,with-tos

   : test,undo
     << -- >>
     "before undo" .s .l
     end
   ; define-function

   "t,u" "test,undo" alias

   test,undo << before undo >>
   t,u  << before undo >>

   : test,undo
     << -- >>
     "after undo" .s .l
     end
   ; define-function

   test,undo << after undo >>

   t,u  << before undo >>

   "t,u" "test,undo" alias

   t,u  << after undo >>

   *undo-point* undo


   test,undo << undefined >>
   t,u  << undefined >>

   *undo-point* << undefined >>
   #+end_src
* >< test framework
** 記 測試
   * 測試是被條件執行的代碼
   * 它們定義一些函數穿插在被加載的代碼之中
     並且有一些頂層的代碼來執行這些測試
   * load 一個 code 的時候 可以指明是否帶有 test
     如果不帶有 test
     那麼上面所定義的函數會被忽略 並且頂層的代碼也被忽略
   * 測試做爲函數的特點還在於
     它們需要以適合閱讀的格式打印出報告以說明測試的效果
     有一組輔助函數幫助完成這種打印
   * 上面的這些特性組合在一起就形成了測試框架
   * 命令行接口中提供機制 以幫測試
   * 在 factor 中 有
     [ "Hello world" ]
     [ "Hello " "world" append ]
     unit-test
     但是
     因爲沒有類型編碼
     所以在 cicada-nymph 中
     所斷言的只能是數值的相等
     除非我引入更多的關於等詞的機制
* -----------------------------------
* report
** <report> memory
   #+begin_src cicada-nymph :tangle core.cn
   : <report> memory
     << -- >>
     "* *un-initialized-memory*" .s .l
     "  * size : " .s
          *un-initialized-memory,size*
          . .l
     "  * used : " .s
          *un-initialized-memory,current-free-address*
          *un-initialized-memory*
          sub . .l
     "  * free : " .s
          *un-initialized-memory,size*
          *un-initialized-memory,current-free-address*
          *un-initialized-memory*
          sub sub . .l
     "* *string-area*" .s .l
     "  * size : " .s
          *string-area,size*
          . .l
     "  * used : " .s
          *string-area,current-free-address*
          *string-area*
          sub . .l
     "  * free : " .s
          *string-area,size*
          *string-area,current-free-address*
          *string-area*
          sub sub . .l
     "* *jojo-area*" .s .l
     "  * size : " .s
          *jojo-area,size* . .l
     "  * used : " .s
          *jojo-area,current-free-address*
          *jojo-area*
          sub . .l
     "  * free : " .s
          *jojo-area,size*
          *jojo-area,current-free-address*
          *jojo-area*
          sub sub . .l
     end
   ; define-function
   #+end_src
** <report> platform
   #+begin_src cicada-nymph :tangle core.cn
   : <report> platform
     << -- >>
     "* platform : " .s
     platform .s
     .l
     end
   ; define-function
   #+end_src
** <report> jo-size
   #+begin_src cicada-nymph :tangle core.cn
   : <report> jo-size
     << -- >>
     "* jo-size : " .s
     *jo-size* write-number
     " bytes" .s
     .l
     end
   ; define-function
   #+end_src
** <report> machine-word-size
   #+begin_src cicada-nymph :tangle core.cn
   : <report> machine-word-size
     << -- >>
     "* machine-word-size : " .s
     *jo-size* 8 mul write-number
     " bits" .s
     .l
     end
   ; define-function
   #+end_src
** <report> syntax
   #+begin_src cicada-nymph :tangle core.cn
   : <report> syntax
     << -- >>
     "* *rule-set,make-jojo* :" .s .l
        *rule-set,make-jojo* list-rule
     "* *rule-set,basic-REPL* :" .s .l
        *rule-set,basic-REPL* list-rule
     "* tos-syntax-stack :" .s .l
        tos-syntax-stack list-rule
     end
   ; define-function
   #+end_src
** <global-naming-stack> list-by-jo-predicate
   * 最後寫到珠典裏的 被最先打印出來
   #+begin_src cicada-nymph :tangle core.cn
   : <global-naming-stack> list-by-jo-predicate,loop
     << jo-predicate, counter, cursor -- >>
     dup *global-naming-stack,pointer* equal? if
       drop
       drop
       drop
       end
     then
     >:cursor
     >:counter
     >:jo-predicate
     :cursor <name-record> get-new-jo
     :jo-predicate apply if
       "  " .s
       :counter .i ". " .s :counter add1 >:counter
       :cursor <name-record> get-name name->string .s
       .l
     then
     :jo-predicate
     :counter
     :cursor *global-naming-stack,unit* add
     loop
   ; define-function

   : <global-naming-stack> list-by-jo-predicate
     << jo-predicate -- >>
     1
     *global-naming-stack*
     <global-naming-stack> list-by-jo-predicate,loop
     end
   ; define-function
   #+end_src
** <report> global-naming-stack
   * different types of words in link
     are showed separately
   #+begin_src cicada-nymph :tangle core.cn
   : <report> global-naming-stack
     << -- >>
     "* all primitive-function in global-naming-stack :" .s .l
     jo primitive-function-jo?
     <global-naming-stack> list-by-jo-predicate

     "* all function in global-naming-stack :" .s .l
     jo function-jo?
     <global-naming-stack> list-by-jo-predicate

     "* all exception in global-naming-stack :" .s .l
     jo exception-jo?
     <global-naming-stack> list-by-jo-predicate

     "* all variable in global-naming-stack :" .s .l
     jo variable-jo?
     <global-naming-stack> list-by-jo-predicate
     end
   ; define-function
   #+end_src
** <report> system
   #+begin_src cicada-nymph :tangle core.cn
   : <report> system
     << -- >>
     <report> platform
     <report> machine-word-size
     <report> jo-size
     end
   ; define-function
   #+end_src
* hi
** welcome
   #+begin_src cicada-nymph :tangle core.cn
   : welcome
     << -- >>
     "* welcome to cicada-nymph" .s .l
     end
   ; define-function
   #+end_src
** hi
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *hi,random-base*
   ; define-variable,with-tos

   : hi,random
     << -- random-number >>
     0 :syscall-number,times:
     1 syscall
     13 mod
     <<
      *hi,random-base*
      *hi,random-base* add1 13 mod
      address *hi,random-base* set
     >>
     end
   ; define-function

   : hi,say
     << number -- >>
     dup 0 equal? if drop "  cica cica da yaya !!!" .s .l end then
     dup 1 equal? if drop "  hi ^-^" .s .l end then
     dup 2 equal? if drop "  hello :)" .s .l end then
     dup 3 equal? if drop "  hey *^-^*" .s .l end then
     dup 4 equal? if drop "  hiya \^o^/" .s .l end then
     dup 5 equal? if drop "  I wish you a lovely day" .s .l end then
     dup 6 equal? if drop "  I wish you a lovely day { or night :P }" .s .l end then
     dup 7 equal? if drop "  o.o" .s .l end then
     dup 8 equal? if drop "  O.o" .s .l end then
     dup 9 equal? if drop "  o.O" .s .l end then
                     drop "  lovely ^3^" .s .l end
   ; define-function

   : hi
     << -- >>
     hi,random
     hi,say
     end
   ; define-function
   #+end_src
** help
   #+begin_src cicada-nymph :tangle core.cn
   : help
     << -- >>
     "* helpful documentations will be written soon" .s .l
     "  please wait ^-^" .s .l
     end
   ; define-function
   #+end_src
* command-function
** unknow-function
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> unknow-function
     << -- >>
     "* (cicada-nymph) unknow command-line-function : " .s
     get-command-line
     <string> word-tail
     <string> word .s .l
     "  good bye ^-^/" .s .l
     bye
   ; define-function
   #+end_src
** stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> stack-REPL
     << -- >>
     .l
     welcome hi .l
     <report> system .l
     "* you are in the (stack-REPL)" .s .l
     "  every time after a word is executed" .s .l
     "  the argument-stack get printed" .s .l
     print-argument-stack,pretty
     jo stack-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> basic-REPL
     << -- >>
     .l
     welcome hi .l
     <report> system .l
     "* you are in the (basic-REPL)" .s .l
     "  this REPL does not print any thing automaticly" .s .l
     jo basic-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** poi
   * cn poi add  <name> <relative-path>
   * cn poi sub  <name>
   * cn poi up   <name> <relative-path>
   * cn poi find <name>
   * cn poi list
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> poi
     << -- >>
     get-command-line
     <string> word-tail
     <string> word-tail >::command-line

     ::command-line <string> space? if
       <poi> help
       bye
     then

     ::command-line <string> word >::sub-function-name
     ::command-line <string> word-tail >::command-line-arguments

     ::sub-function-name "help" <string> equal? if
       <poi> help
       bye
     then

     ::sub-function-name "add" <string> equal? if
       ::command-line-arguments <string> word
       ::command-line-arguments <string> word-tail <string> word
       <poi> add
       bye
     then

     ::sub-function-name "sub" <string> equal? if
       ::command-line-arguments <string> word
       <poi> sub
       bye
     then

     ::sub-function-name "up" <string> equal? if
       ::command-line-arguments <string> word
       ::command-line-arguments <string> word-tail <string> word
       <poi> up
       bye
     then

     ::sub-function-name "find" <string> equal? if
       ::command-line-arguments <string> word
       <poi> find if
         .s .l
       else
         "no found" .s .l
       then
       bye
     then

     ::sub-function-name "list" <string> equal? if
       <poi> list
       bye
     then

     "* (poi) meets argument that (poi) can not understand" .s .l
     "  it is the following command-line that is confusing (poi) :" .s .l
     "    " .s <report> command-line .l
     "  to get some help info  you can type :" .s .l
     "    cn poi help" .s .l
     "  good bye ^-^/" .s .l
     bye
   ; define-function
   #+end_src
** module
   * cn module add  <name> <relative-path>
   * cn module sub  <name>
   * cn module up   <name> <relative-path>
   * cn module find <name>
   * cn module list
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> moi
     << -- >>
     get-command-line
     <string> word-tail
     <string> word-tail >::command-line

     ::command-line <string> space? if
       <moi> help
       bye
     then

     ::command-line <string> word >::sub-function-name
     ::command-line <string> word-tail >::command-line-arguments

     ::sub-function-name "help" <string> equal? if
       <moi> help
       bye
     then

     ::sub-function-name "add" <string> equal? if
       ::command-line-arguments <string> word
       ::command-line-arguments <string> word-tail <string> word
       <moi> add
       bye
     then

     ::sub-function-name "sub" <string> equal? if
       ::command-line-arguments <string> word
       <moi> sub
       bye
     then

     ::sub-function-name "up" <string> equal? if
       ::command-line-arguments <string> word
       ::command-line-arguments <string> word-tail <string> word
       <moi> up
       bye
     then

     ::sub-function-name "find" <string> equal? if
       ::command-line-arguments <string> word
       <moi> find if
         .s .l
       else
         "no found" .s .l
       then
       bye
     then

     ::sub-function-name "list" <string> equal? if
       <moi> list
       bye
     then

     "* (module) meets argument that (module) can not understand" .s .l
     "  it is the following command-line that is confusing (module) :" .s .l
     "    " .s <report> command-line .l
     "  to get some help info  you can type :" .s .l
     "    cn module help" .s .l
     "  good bye ^-^/" .s .l
     bye
   ; define-function
   #+end_src
** no-function
   #+begin_src cicada-nymph :tangle core.cn
   : <command-function> no-function
     << -- >>
     <command-function> stack-REPL
     end
   ; define-function
   #+end_src
* command
** dispatch
   #+begin_src cicada-nymph :tangle core.cn
   : <command> dispatch
     << -- >>
     get-command-line
     <string> word-tail
     dup2 <string> space? if
       drop2
       <command-function> no-function
       end
     then
     <string> word
     >::1st-word
     ::1st-word "basic-REPL" <string> equal? if
       <command-function> basic-REPL
       end
     then
     ::1st-word "stack-REPL" <string> equal? if
       <command-function> stack-REPL
       end
     then
     ::1st-word "poi" <string> equal? if
       <command-function> poi
       end
     then
     ::1st-word "moi" <string> equal? if
       <command-function> moi
       end
     then
     <command-function> unknow-function
     end
   ; define-function
   #+end_src
* the-story-begin
  #+begin_src cicada-nymph :tangle core.cn
  : the-story-begin
    << -- >>
    <command> dispatch
    end
  ; define-function

  the-story-begin
  #+end_src
* ===================================
* test report
  #+begin_src cicada-nymph
  <report> memory
  <report> syntax
  <report> global-naming-stack
  #+end_src
* ===================================
