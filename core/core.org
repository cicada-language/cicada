#+TITLE:  小蟬語核 / core of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* syntax about bit-wise operations
  * I need this syntax
    to implement syscalls well
* todo
** 分析局部變元的良好性               :question:
   * 對 包含 >:name 的函數體的純線性處理
     當遇到 if 所形成的分支的時候
     會不會有問題 ???
** about load-file
   * nested load-file
     a stack of allocate buffers in another local-data-heap
     the previous local-data-heap maybe should be called local-data-vector
   * load-file should maintain a list of loaded files
     what else meta data should be maintained ?
     can them make up a well module system ?
** if else then and double-quote in REPL
   * round-heap for string literal in REPL
     * 使用新的語法擴展機制
       這在於對 '"' 這個語關鍵詞的變更
     * 也就是說
       還是要實現這個語法兩次了
     * 也就是說在編譯器開始執行的時候
       會入棧一些編譯器所需要用到的語法
       而運行結束之後
       又把這些語法出棧
** 更好的錯誤處理機制
   1. 當一個 exception 找不到自己在 return-stack 中的退出點時
      應該有更好地處理方式 而不是不處理這種情況
   2. 目前
      當一個 exception 被執行的時候
      調用這個 exception 的函數是沒法傳遞參數給這個 exception 的
      [除非爲這個 exception 中設置全局變量]
      其原因在於
      當 exception 被執行的時候 參數棧已經被重置了
      所以其實解法很簡單
      只要提供一個函數給 exception
      讓每個 exception 用這個函數來以明顯的方式重置參數棧就行了
      這樣當一個 exception 被執行的時候
      它可以
      1. 先以未被重置時的參數棧中的值爲參數
         這些參數可以是調用這個 exception 的函傳遞給 exception 的
      2. 之後再以重置之後的參數棧中的值爲參數
         這些參數是等待 exception 的函爲 exception 所準備的
** little-tester                      :needed:
** home-path & search-path to load files
   * poi denotes path-organizer
   * 實現 條件性的被解釋的代碼
     這樣就能實現
     1. little-tester
     2. 在不同的平臺下執行不同的代碼
** debug-REPL
** [really needed] error handling for io function
   * write-file 可能遇到磁盤滿載的情況
** fixnum in other base
** more design about the command-line-interface
** re-design the color of cicada-nymph-mode and re-write the emacs-lisp code
** [how] variable must be able to store string
** name-hash-table
   * better factoring
   * better naming
** title-name-table
** data-giver
** big number and 同餘方程
   * 爲了玩 hash-table
* ===================================
* note
** notation
   * use ","
** data section in cicada-nymph
* ===================================
* writers
** note name of writers
   * the use of "." as prefix
     is inherited from Forth
   * table
     | .  | pretty_write_integer | assembly |
     | .i | write_integer        | core     |
     | .s | write_string         | assembly |
     | .l | linefeed             | core     |
** .l .i
   #+begin_src cicada-nymph :tangle core.cn
   : .l
     << -- >>
     10 write-byte
     end
   ; define-function

   : .i
     << -- >>
     write-integer
     end
   ; define-function
   #+end_src
* *rule-set,make-jojo* : if & else & then
** 記 條件轉跳
   * one predicate can make two branchs
     three predicates can make four branchs
     three predicates may only make three branchs
     but indeed there must be an invisible branch
** word:[if|else|then]?
   #+begin_src cicada-nymph :tangle core.cn
   : word:if?
     << word[address, length] -- bool >>
     "if" string-equal?
     end
   ; define-function

   : word:else?
     << word[address, length] -- bool >>
     "else" string-equal?
     end
   ; define-function

   : word:then?
     << word[address, length] -- bool >>
     "then" string-equal?
     end
   ; define-function
   #+end_src
** syntax,[if|else|then],make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,make-jojo
     << string[address, length], word:if --
        address, string[address, length] >>
     drop2
     *false?branch* save-into,jo-heap
     *current-free-address,jo-heap* xx|swap|x
     0 save-into,jo-heap
     end
   ; define-function

   : syntax,else,make-jojo
     << address, string[address, length], word:else --
        address, string[address, length] >>
     drop2
     *branch* save-into,jo-heap
     x|swap|xx
     *current-free-address,jo-heap* xxx|swap|x
     0 save-into,jo-heap
     << address, string[address, length], address >>
     *current-free-address,jo-heap*
     over sub *jo-size* div
     swap save
     end
   ; define-function

   : syntax,then,make-jojo
     << address, string[address, length], word:then --
        string[address, length] >>
     drop2
     x|swap|xx
     *current-free-address,jo-heap*
     over sub *jo-size* div
     swap save
     end
   ; define-function
   #+end_src
** test if & else & then
   #+begin_src cicada-nymph
   : kkk
     "kkk took my baby away !" .s
     .l
     end
   ; define-function

   kkk

   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 factorial
     mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function

   : .12
     << 1 2 -- >>
     2 equal? if
       "(^-^)" .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     else
       "     " .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     then
     end
   ; define-function

   : .12,test
     .l
     1 2 .12 .l
     6 2 .12 .l
     1 6 .12 .l
     6 6 .12 .l
     end
   ; define-function


   factorial,test
   .12,test
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
     jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
     jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
* *rule-set,make-jojo* : prepare-for
** 記 異常處理
   * 在語言中設計良好的異常處理
     是鼓勵程序員寫出皮實的程序的關鍵
   * 目前的
     利用 prepare-for 來實現的異常處理機制
     可能還遠遠不夠良好
** word:prepare-for?
   #+begin_src cicada-nymph :tangle core.cn
   : word:prepare-for?
     << word[address, length] -- bool >>
     "prepare-for" string-equal?
     end
   ; define-function
   #+end_src
** syntax,prepare-for,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,prepare-for,make-jojo
     << string[address, length], word:prepare-for --
        string[address, length] >>
     drop2
     *prepare-for*    save-into,jo-heap
     *exception-head* save-into,jo-heap
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:prepare-for?
     jo syntax,prepare-for,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
* number with base
** 記 原理
   * 現在 的 number 就只是 "integer" 而已
     更多的跟數學有關的東西將在 cicada 中設計新的語法來實現
   * 在 "integer" 這個函數中 我將只支持 對四種進位制的 字符串的 閱讀
     * 十進制
       10#1231
       10#-1231
       1231
       -1231
     * 二進制
       2#101001
       2#-101001
       2#-1011_1001
       "-" 和 "_" 的同時存在有點難讀
       此時可以用 2#1011_1001 negate
       也就是說雖然允許用 "-" 來表示負數
       但是不鼓勵這樣做
       之所以允許這樣做
       是因爲在打印負數的時候需要這種表示方式
       不能把 "-123" 打印成 "123 negate"
     * 八進制
       8#712537
       8#-712537
     * 十六進制
       16#f123acb3
       16#-F123ACB3
       大寫小寫字母都可以
   * one can use "_" to separate the number
     to make it more readable
     for example
     2#1111_0101_0001
   * actually, the base can be any 10 based number
     even greater then 36
     but when the base is greater then 36
     not all integer can be represented under this base
     for we only have 36 chars
** remove-char!
   #+begin_src cicada-nymph :tangle core.cn
   : remove-char!,loop
     << cursor, length, char -- cursor >>
     >:char
     >:length
     >:cursor
     :length zero? if
       :cursor
       end
     then
     :cursor fetch-byte :char equal? if
       :cursor add1 :length sub1
       :cursor
       string->buffer!
       :cursor
       :length sub1
       :char
     else
       :cursor add1
       :length sub1
       :char
     then
     <> remove-char!,loop
   ; define-function

   : remove-char!
     << string[address, length], char -- string[address, length] >>
     x|over|xx >:address
     remove-char!,loop >:cursor
     :address
     :cursor :address sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,remove-char!
     << -- >>
     "2#1001_1001"
     "_" string-head,char
     remove-char! .s << 2#1001_1001 >>
     .l
     "___2#1001___1001___"
     "_" string-head,char
     remove-char! .s << 2#1001_1001 >>
     .l
     end
   ; define-function
   test,remove-char!
   #+end_src
** latin-char?
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char?
     << char -- bool >>
     dup "A" string-head,char less-than? false?branch 4
       drop false
       end
     dup "Z" string-head,char less-or-equal? false?branch 4
       drop true
       end
     dup "a" string-head,char less-than? false?branch 4
       drop false
       end
     dup "z" string-head,char less-or-equal? false?branch 4
       drop true
       end
     drop false
     end
   ; define-function
   #+end_src
** latin-char->number
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char->number
     << latin-char -- number >>
     dup "A" string-head,char less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'A' : " .s
       .i .l
       end
     then
     dup "Z" string-head,char less-or-equal? if
       "A" string-head,char
       sub
       10 add
       end
     then
     dup "a" string-head,char less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'a' but greater-then 'Z' : " .s
       .i .l
       end
     then
     dup "z" string-head,char less-or-equal? if
       "a" string-head,char
       sub
       10 add
       end
     then
     "* (latin-char->number) the argument must be a latin-char" .s .l
     "  but the following char is greater-then 'z' : " .s
     .i .l
     end
   ; define-function
   #+end_src
** number->latin-char
   #+begin_src cicada-nymph :tangle core.cn
   : number->latin-char
     << number -- latin-char >>
     10 sub
     "a" string-head,char
     add
     end
   ; define-function
   #+end_src
** wild-digit-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-digit-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 true
       end
     then
     over fetch-byte
     dup digit-char?
     swap latin-char?
     or if
       string-tail,char
       <> wild-digit-string?
     then
     drop2
     false
     end
   ; define-function
   #+end_src
** wild-integer-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 false
       end
     then
     dup2 string-head,char
     "-" string-head,char
     equal? if
       string-tail,char
       wild-digit-string?
       end
     then
     wild-digit-string?
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,wild-integer-string?
     << -- >>
     "" wild-integer-string? . << 1 >>
     .l
     " " wild-integer-string? . << 0 >>
     "_asd" wild-integer-string? . << 0 >>
     " asd" wild-integer-string? . << 0 >>
     .l
     "asd" wild-integer-string? . << 1 >>
     "123" wild-integer-string? . << 1 >>
     "123asd" wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,wild-integer-string?
   #+end_src
** empty-string?
   #+begin_src cicada-nymph :tangle core.cn
   : empty-string?
     << string[address, length] -- bool >>
     swap drop
     zero?
     end
   ; define-function
   #+end_src
** base#wild-integer-string?
   * a string for the following format
     is viewed as a base#digit-string
     <digit-string>#[-]<wild-integer-string-string>
     any "_" in the anywhere of the above string
     will be ignored
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string?
     << string[address, length] -- bool >>
     128 allocate-local-memory
     >:string-address
     tuck
     :string-address
     string->buffer!
     :string-address swap
     "_" string-head,char
     remove-char!
     >:new-string-length
     >:new-string-address
     << dup2 .s .l 0 end >>
     :new-string-address
     :new-string-length
     "#" string-head,char
     find-char,string if
     else
       false
       end
     then
     >:address-of-#
     :new-string-address
     :address-of-# :new-string-address sub
     >::base-string
     :address-of-# add1
     :address-of-# :new-string-address sub add1
     :new-string-length swap sub
     >::wild-integer-string
     ::base-string digit-string?
     ::base-string empty-string? not
     and if
     else
       false
       end
     then
     ::wild-integer-string wild-integer-string?
     ::wild-integer-string empty-string? not
     and if
       true
     else
       false
     then
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string?
     << -- >>
     "#" base#wild-integer-string? . << 0 >>
     "##" base#wild-integer-string? . << 0 >>
     "#___#" base#wild-integer-string? . << 0 >>
     "   " base#wild-integer-string? . << 0 >>
     "______#__1______" base#wild-integer-string? . << 0 >>
     "___2___#__1___c29bf210019___漢字" base#wild-integer-string? . << 0 >>
     .l
     "1#1" base#wild-integer-string? . << 1 >>
     "123#1c29bf219g42" base#wild-integer-string? . << 1 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string?
   #+end_src
** base#wild-integer-string->base-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->base-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,char
     find-char,string if
     else
       "* (base#wild-integer-string->base-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address
     :address-of-# :address sub
     end
   ; define-function
   #+end_src
** base#wild-integer-string->wild-integer-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->wild-integer-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,char
     find-char,string if
     else
       "* (base#wild-integer-string->wild-integer-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address-of-# add1
     :address-of-# :address sub add1
     :length swap sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->base-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->base-string
     .l
     "1#1" base#wild-integer-string->base-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->base-string .s .l << 123 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->base-string .s .l << ___2___ >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->base-string

   : test,base#wild-integer-string->wild-integer-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->wild-integer-string
     .l
     "1#1" base#wild-integer-string->wild-integer-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->wild-integer-string .s .l << 1c29bf219g42 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->wild-integer-string .s .l << __1___c29bf210019___g42 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->wild-integer-string
   #+end_src
** wild-integer-string->integer,with-base
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string->integer,with-base,loop
     << string[address, length], base, sum, counter -- integer >>
     >:counter
     >:sum
     >:base
     >:length
     >:address
     :length zero? if
       :sum
       end
     then
     :address fetch-byte >:char
     :char digit-char? if
       :char digit-char->number
     then
     :char latin-char? if
       :char latin-char->number
     then
     :base :counter power
     mul
     :sum add
     >:sum
     :address add1
     :length sub1
     :base
     :sum
     :counter add1
     <> wild-integer-string->integer,with-base,loop
   ; define-function

   : wild-integer-string->integer,with-base
     << string[address, length], base -- integer >>
     >:base
     dup zero? if
       drop2
       0
       end
     then
     dup2 string-head,char
     "-" string-head,char
     equal? if
       string-tail,char
       -1 >:sign
     else
       1 >:sign
     then
     >::string
     ::string string-reverse!
     :base
     0 0 wild-integer-string->integer,with-base,loop
     :sign mul
     ::string string-reverse!
     drop2
     end
   ; define-function
   #+end_src
** base#wild-integer-string->integer
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->integer
     << string[address, length] -- integer >>
     128 allocate-local-memory
       >:address
     tuck :address string->buffer!
       >:length
     :address :length
     "_" string-head,char remove-char!
       >::string
     ::string
     base#wild-integer-string->base-string
       >::base-string
     ::string
     base#wild-integer-string->wild-integer-string
       >::wild-integer-string
     ::base-string
     digit-string->nature-number
       >:base
     ::wild-integer-string
     :base
     wild-integer-string->integer,with-base
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->integer
     << -- >>
     "0#111" base#wild-integer-string->integer .
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add .
     .l
     "1#111" base#wild-integer-string->integer .
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add .
     .l
     "10#123" base#wild-integer-string->integer .
     "_1_0__#_1__2_3_" base#wild-integer-string->integer .
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add .
     .l
     "2#1000" base#wild-integer-string->integer .
     "2#_1000_" base#wild-integer-string->integer .
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add .
     .l
     "2#1111_1111" base#wild-integer-string->integer .
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add .
     "16#f_f" base#wild-integer-string->integer .
     16 0 power 15 mul
     16 1 power 15 mul add .
     .l
     "100#111" base#wild-integer-string->integer .
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add .
     .l
     "64#zzz" base#wild-integer-string->integer .
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add .
     .l
     "36#zzzz" base#wild-integer-string->integer .
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add .
     .l
     end
   ; define-function
   test,base#wild-integer-string->integer
   #+end_src
** note writers
   * a general function
     and three special ones
   * they all writer integer
   * I will implemented them by syntax when needed
** .#
   #+begin_src cicada-nymph :tangle core.cn
   : .#,loop
     << nature-number, base, cursor -- cursor >>
     >:cursor
     >:base
     >:nature-number
     :nature-number zero? if
       :cursor
       end
     then
     :nature-number
     :base
     divmod >:mod >:div
     :mod 10 less-than? if
       :mod number->digit-char
     else
       :mod number->latin-char
     then
     :cursor
     save-byte
     :div
     :base
     :cursor add1
     <> .#,loop
   ; define-function

   : .#
     << integer, base -- >>
     dup 36 greater-than?
     over 2 less-than?
     or if
       "* (.#) the base " .s .i " is not valid to write a number" .s .l
       "  a base should in between 2 and 36 includingly" .s .l
       "  the integer to be written is " .s .i .l
       end
     then
     dup .i
     "#" .s
     over negative? if
       swap negate swap
       "-" .s
     then
     128 allocate-local-memory >:buffer
     :buffer
     .#,loop >:cursor
     :buffer
     :cursor :buffer sub
     string-reverse! .s
     end
   ; define-function
   #+end_src
** .#2 .#8 .#16
   #+begin_src cicada-nymph :tangle core.cn
   : .#2  2  .# " " .s end ; define-function
   : .#8  8  .# " " .s end ; define-function
   : .#16 16 .# " " .s end ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111        0  .#
   1#111        1  .#
   10#123       10 .#
   2#1000       2  .#
   2#1111_1111  2  .#
   16#f_f       16 .#
   36#zzzz      36 .#

   2#1111_1111  .#2
   8#123        .#8
   16#fff       .#16
   #+end_src
* *rule-set,make-jojo* : number with base
** syntax,base#wild-integer-string,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,base#wild-integer-string,make-jojo
     << string[address, length], word[address, length] --
        string[address, length] >>
     *literal* save-into,jo-heap
     base#wild-integer-string->integer
     save-into,jo-heap
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo base#wild-integer-string?
     jo syntax,base#wild-integer-string,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,syntax,base#wild-integer-string,make-jojo
     << -- >>
     0#111
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add
     . . .l

     1#111
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add
     . . .l

     10#123
     _1_0__#_1__2_3_
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add
     . . .l .

     2#1000
     2#_1000_
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add
     . . .l .

     2#1111_1111
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add
     . . .l

     16#f_f
     16 0 power 15 mul
     16 1 power 15 mul add
     . . .l

     100#111
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add
     . . .l

     64#zzz
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add
     . . .l

     36#zzzz
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add
     . . .l

     end
   ; define-function

   test,syntax,base#wild-integer-string,make-jojo
   #+end_src
* allocate
** note
   * an interface of *un-initialized-memory*
** clear-memory [not using]
   * this kinds of functions
     must be implemented in assembly code
   #+begin_src cicada-nymph
   : clear-memory
     << size, address -- >>
     over zero? if
       drop2
       end
     then
     0 over save
     add1 swap
     sub1 swap
     <> clear-memory
   ; define-function
   #+end_src
** allocate-memory
   #+begin_src cicada-nymph :tangle core.cn
   : allocate-memory
     << size -- address >>
     dup *current-free-address,un-initialized-memory* clear-memory
     *current-free-address,un-initialized-memory* swap << address as return value >>
     address *current-free-address,un-initialized-memory* add-save
     end
   ; define-function
   #+end_src
* basic-REPL                          :redefine:
** *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   1024 *jo-size* mul
   : *size,rule-set,basic-REPL*
   ; define-variable

   << for cursor >>
   *jo-size* allocate-memory drop

   *size,rule-set,basic-REPL*
   allocate-memory
   : *rule-set,basic-REPL*
   ; define-variable

   *rule-set,basic-REPL*
   *rule-set,basic-REPL* *jo-size* sub
   save
   #+end_src
** execute-word
   * to protect exception-jo from be called from basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : execute-word
     << word[address, length] -- unknown >>
     dup2
     find if
       dup exception-jo? if
         drop
         "* (execute-word) can not execute exception directly : " .s
         .s .l
         end
       then
       << function & primitive-function & variable >>
       xx|swap|x drop2
       execute-jo
       end
     else
     "* (execute-word) meets undefined word : " .s
     .s .l
     then
     end
   ; define-function
   #+end_src
** word:bye?
   #+begin_src cicada-nymph :tangle core.cn
   : word:bye?
     << word[address, length] -- bool >>
     "bye" string-equal?
     end
   ; define-function
   #+end_src
** !bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : !bye,basic-REPL
     << -- >>
     drop-syntax-stack
     end
   ; define-exception
   #+end_src
** syntax,bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,bye,basic-REPL
     << word:bye -- >>
     drop2
     !bye,basic-REPL
   ; define-function
   #+end_src
** init,rule-set,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : init,rule-set,basic-REPL
     << -- >>
     jo integer-string? jo string->integer       *rule-set,basic-REPL* add-rule
     jo word:bye?       jo syntax,bye,basic-REPL *rule-set,basic-REPL* add-rule

     jo base#wild-integer-string? jo base#wild-integer-string->integer *rule-set,basic-REPL* add-rule
     end
   ; define-function

   init,rule-set,basic-REPL
   #+end_src
** basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : basic-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     <> basic-REPL,loop
   ; define-function

   : basic-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     basic-REPL,loop
     end
   ; define-function

   basic-REPL
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111
   0 0 power 1 mul
   0 1 power 1 mul add
   0 2 power 1 mul add
   . .

   1#111
   1 0 power 1 mul
   1 1 power 1 mul add
   1 2 power 1 mul add
   . .

   10#123
   _1_0__#_1__2_3_
   10 0 power 3 mul
   10 1 power 2 mul add
   10 2 power 1 mul add
   . . .

   2#1000
   2#_1000_
   2 0 power 0 mul
   2 1 power 0 mul add
   2 2 power 0 mul add
   2 3 power 1 mul add
   . . .

   2#1111_1111
   2 0 power 1 mul
   2 1 power 1 mul add
   2 2 power 1 mul add
   2 3 power 1 mul add
   2 4 power 1 mul add
   2 5 power 1 mul add
   2 6 power 1 mul add
   2 7 power 1 mul add
   . .

   16#f_f
   16 0 power 15 mul
   16 1 power 15 mul add
   . .

   100#111
   100 0 power 1 mul
   100 1 power 1 mul add
   100 2 power 1 mul add
   . .

   64#zzz
   64 0 power 35 mul
   64 1 power 35 mul add
   64 2 power 35 mul add
   . .

   36#zzzz
   36 0 power 35 mul
   36 1 power 35 mul add
   36 2 power 35 mul add
   36 3 power 35 mul add
   . .
   #+end_src
* stack-REPL
** note
   * print argument-stack in every loop
** print-argument-stack
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,loop
     << address, counter -- >>
     dup zero? if
       drop2
       end
     then
     sub1 swap
       dup fetch .
     *jo-size* add
     swap
     <> print-argument-stack,loop
   ; define-function

   : print-argument-stack
     << -- >>
     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     *the-stack* greater-or-equal? if
       *the-stack*   << address as return value >>
       *the-stack-pointer-snapshot* *the-stack* sub
       *jo-size* div << counter as return value >>
       print-argument-stack,loop
       end
     then
     "below the stack " .s
     end
   ; define-function
   #+end_src
** print-argument-stack,pretty
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,pretty
     << -- >>
     snapshot-the-stack-pointer
     .l
     " * " .s
        *the-stack-pointer-snapshot*
        *the-stack* sub
        << ad hoc for the BUG of div >>
        dup negative? if
          negate
          *jo-size* div
          negate
        else
          *jo-size* div
        then
        .i
     " * " .s
     " -- " .s
       print-argument-stack
     "--" .s
     .l
     end
   ; define-function
   #+end_src
** stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : stack-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     print-argument-stack,pretty
     <> stack-REPL,loop
   ; define-function

   : stack-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     stack-REPL,loop
     end
   ; define-function
   #+end_src
* constant for linux                  :linux:
** init-syscall-number
   #+begin_src cicada-nymph :tangle core.cn
   0 : :syscall-number,open:  ; define-variable
   0 : :syscall-number,close: ; define-variable
   0 : :syscall-number,read:  ; define-variable
   0 : :syscall-number,write: ; define-variable
   0 : :syscall-number,stat:  ; define-variable
   0 : :syscall-number,exit:  ; define-variable
   0 : :syscall-number,times: ; define-variable

   : init-syscall-number
     << -- >>
     *jo-size* 4 equal? if
       5   address :syscall-number,open:  save
       6   address :syscall-number,close: save
       3   address :syscall-number,read:  save
       4   address :syscall-number,write: save
       106 address :syscall-number,stat:  save
       1   address :syscall-number,exit:  save
       43  address :syscall-number,times: save
       end
     then
     *jo-size* 8 equal? if
       2   address :syscall-number,open:  save
       3   address :syscall-number,close: save
       0   address :syscall-number,read:  save
       1   address :syscall-number,write: save
       4   address :syscall-number,stat:  save
       60  address :syscall-number,exit:  save
       100 address :syscall-number,times: save
       end
     then
     end
   ; define-function

   init-syscall-number
   #+end_src
** error-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : error-code->string
     << error-code -- string[address, length] >>
     dup -1  equal? if drop "EPERM    Operation not permitted " end then
     dup -2  equal? if drop "ENOENT   No such file or directory " end then
     dup -3  equal? if drop "ESRCH    No such process " end then
     dup -4  equal? if drop "EINTR    Interrupted system call " end then
     dup -5  equal? if drop "EIO      I/O error " end then
     dup -6  equal? if drop "ENXIO    No such device or address " end then
     dup -7  equal? if drop "E2BIG    Argument list too long " end then
     dup -8  equal? if drop "ENOEXEC  Exec format error " end then
     dup -9  equal? if drop "EBADF    Bad file number " end then
     dup -10 equal? if drop "ECHILD   No child processes " end then
     dup -11 equal? if drop "EAGAIN   Try again " end then
     dup -12 equal? if drop "ENOMEM   Out of memory " end then
     dup -13 equal? if drop "EACCES   Permission denied " end then
     dup -14 equal? if drop "EFAULT   Bad address " end then
     dup -15 equal? if drop "ENOTBLK  Block device required " end then
     dup -16 equal? if drop "EBUSY    Device or resource busy " end then
     dup -17 equal? if drop "EEXIST   File exists " end then
     dup -18 equal? if drop "EXDEV    Cross-device link " end then
     dup -19 equal? if drop "ENODEV   No such device " end then
     dup -20 equal? if drop "ENOTDIR  Not a directory " end then
     dup -21 equal? if drop "EISDIR   Is a directory " end then
     dup -22 equal? if drop "EINVAL   Invalid argument " end then
     dup -23 equal? if drop "ENFILE   File table overflow " end then
     dup -24 equal? if drop "EMFILE   Too many open files " end then
     dup -25 equal? if drop "ENOTTY   Not a typewriter " end then
     dup -26 equal? if drop "ETXTBSY  Text file busy " end then
     dup -27 equal? if drop "EFBIG    File too large " end then
     dup -28 equal? if drop "ENOSPC   No space left on device " end then
     dup -29 equal? if drop "ESPIPE   Illegal seek " end then
     dup -30 equal? if drop "EROFS    Read-only file system " end then
     dup -31 equal? if drop "EMLINK   Too many links " end then
     dup -32 equal? if drop "EPIPE    Broken pipe " end then
     dup -33 equal? if drop "EDOM     Math argument out of domain of func " end then
     dup -34 equal? if drop "ERANGE   Math result not representable " end then
     "unknow error-code : " .s
     .i .l
     end
   ; define-function
   #+end_src
* report
** report-dictionary
*** 記
    * 最後寫到珠典裏的
      被最先打印出來
*** report-dictionary,primitive-function
    #+begin_src cicada-nymph :tangle core.cn
    : report-dictionary,primitive-function,loop
      << counter, jo -- total >>
      dup zero? if
        drop
        end
      then
      dup primitive-function-jo? false? if
        jo->pre-jo
        <> report-dictionary,primitive-function,loop
      then
      swap
        "  " .s
        add1 dup .
      swap
      dup jo->name
      dup2 space-string? if
        drop2
        " un-named " .s .l
      else
        .s .l
      then
      jo->pre-jo
      <> report-dictionary,primitive-function,loop
    ; define-function

    : report-dictionary,primitive-function
      << -- >>
      "* all primitive-function in dictionary :" .s .l
      0 *first-jo-in-dictionary*
      report-dictionary,primitive-function,loop
      end
    ; define-function
    #+end_src
*** report-dictionary,function
    #+begin_src cicada-nymph :tangle core.cn
    : report-dictionary,function,loop
      << counter, jo -- total >>
      dup zero? if
        drop
        end
      then
      dup function-jo? false? if
        jo->pre-jo
        <> report-dictionary,function,loop
      then
      swap
        "  " .s
        add1 dup .
      swap
      dup jo->name
      dup2 space-string? if
        drop2
        " un-named " .s .l
      else
        .s .l
      then
      jo->pre-jo
      <> report-dictionary,function,loop
    ; define-function

    : report-dictionary,function
      << -- >>
      "* all function in dictionary :" .s .l
      0 *first-jo-in-dictionary*
      report-dictionary,function,loop
      end
    ; define-function
    #+end_src
*** report-dictionary,exception
    #+begin_src cicada-nymph :tangle core.cn
    : report-dictionary,exception,loop
      << counter, jo -- total >>
      dup zero? if
        drop
        end
      then
      dup exception-jo? false? if
        jo->pre-jo
        <> report-dictionary,exception,loop
      then
      swap
        "  " .s
        add1 dup .
      swap
      dup jo->name
      dup2 space-string? if
        drop2
        " un-named " .s .l
      else
        .s .l
      then
      jo->pre-jo
      <> report-dictionary,exception,loop
    ; define-function

    : report-dictionary,exception
      << -- >>
      "* all exception in dictionary :" .s .l
      0 *first-jo-in-dictionary*
      report-dictionary,exception,loop
      end
    ; define-function
    #+end_src
*** report-dictionary,variable
    #+begin_src cicada-nymph :tangle core.cn
    : report-dictionary,variable,loop
      << counter, jo -- total >>
      dup zero? if
        drop
        end
      then
      dup variable-jo? false? if
        jo->pre-jo
        <> report-dictionary,variable,loop
      then
      swap
        "  " .s
        add1 dup .
      swap
      dup jo->name
      dup2 space-string? if
        drop2
        " un-named " .s .l
      else
        .s .l
      then
      jo->pre-jo
      <> report-dictionary,variable,loop
    ; define-function

    : report-dictionary,variable
      << -- >>
      "* all variable in dictionary :" .s .l
      0 *first-jo-in-dictionary*
      report-dictionary,variable,loop
      end
    ; define-function
    #+end_src
*** report-dictionary
    * different types of words in dictionary
      are showed separately
    #+begin_src cicada-nymph :tangle core.cn
    : report-dictionary
      << -- >>
      report-dictionary,primitive-function
      report-dictionary,function add
      report-dictionary,exception add
      report-dictionary,variable add
      "* totally : " .s
      .i .l
      end
    ; define-function
    #+end_src
** report-memory
   #+begin_src cicada-nymph :tangle core.cn
   : report-memory
     << -- >>
     "* *un-initialized-memory*" .s .l
     "  * size : " .s
          *size,un-initialized-memory*
          . .l
     "  * used : " .s
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub . .l
     "  * free : " .s
          *size,un-initialized-memory*
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub sub . .l
     "* *primitive-string-heap*" .s .l
     "  * size : " .s
          *size,primitive-string-heap*
          . .l
     "  * used : " .s
          *current-free-address,primitive-string-heap*
          *primitive-string-heap*
          sub . .l
     "  * free : " .s
          *size,primitive-string-heap*
          *current-free-address,primitive-string-heap*
          *primitive-string-heap*
          sub sub . .l
     "* *jo-heap*" .s .l
     "  * size : " .s
          *size,jo-heap* . .l
     "  * used : " .s
          *current-free-address,jo-heap*
          *jo-heap*
          sub . .l
     "  * free : " .s
          *size,jo-heap*
          *current-free-address,jo-heap*
          *jo-heap*
          sub sub . .l
     end
   ; define-function
   #+end_src
** report-platform
   #+begin_src cicada-nymph :tangle core.cn
   : report-platform
     << -- >>
     "* platform : " .s
     platform .s
     .l
     end
   ; define-function
   #+end_src
** report-jo-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-jo-size
     << -- >>
     "* jo-size : " .s
     *jo-size* write-nature-number
     " bytes" .s
     .l
     end
   ; define-function
   #+end_src
** report-machine-word-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-machine-word-size
     << -- >>
     "* machine-word-size : " .s
     *jo-size* 8 mul write-nature-number
     " bits" .s
     .l
     end
   ; define-function
   #+end_src
** list-rule
   * 最後寫到規則集合裏的
     被最先打印出來
   #+begin_src cicada-nymph :tangle core.cn
   : list-rule,loop
     << rule-set, cursor, counter -- >>
     xx|over|x equal? if
       drop drop2
       end
     then
     "  " .s
     add1 dup .
     swap
       dup cursor->predicate
       jo->name .s
       "  " .s
       dup cursor->function
       jo->name .s .l
       *jo-size* sub *jo-size* sub
     swap
     <> list-rule,loop
   ; define-function

   : list-rule
     << rule-set -- >>
     dup rule-set,fetch-cursor
     0 list-rule,loop
     end
   ; define-function
   #+end_src
** report-syntax
   #+begin_src cicada-nymph :tangle core.cn
   : report-syntax
     << -- >>
     "* *rule-set,make-jojo* :" .s .l
      *rule-set,make-jojo* list-rule
     "* *rule-set,basic-REPL* :" .s .l
      *rule-set,basic-REPL* list-rule
     "* tos-syntax-stack :" .s .l
      tos-syntax-stack list-rule
     end
   ; define-function
   #+end_src
** report-loaded-core-file
   #+begin_src cicada-nymph :tangle core.cn
   : report-loaded-core-file
     << -- >>
     "* loaded-core-file : " .s
     get-path,loaded-core-file .s .l
     end
   ; define-function
   #+end_src
** initial-report
   #+begin_src cicada-nymph :tangle core.cn
   : initial-report
     << -- >>
     "* initial-report : " .s .l
     "  " .s report-loaded-core-file
     "  " .s report-platform
     "  " .s report-machine-word-size
     "  " .s report-jo-size
     end
   ; define-function
   #+end_src
* hi
** welcome
   #+begin_src cicada-nymph :tangle core.cn
   : welcome
     << -- >>
     "* welcome to cicada-nymph ^-^" .s .l
     end
   ; define-function
   #+end_src
** hi
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *hi,random-base*
   ; define-variable

   : hi,random
     << -- random-number >>
     0 :syscall-number,times:
     1 syscall
     13 mod
     <<
      *hi,random-base*
      *hi,random-base* add1 13 mod
      address *hi,random-base* save
     >>
     end
   ; define-function

   : hi,say
     << number -- >>
     dup 0 equal? if drop "* do not forget to eat good good coder !" .s .l end then
     dup 1 equal? if drop "* me wile moku e pona moku ^-^" .s .l end then
     dup 2 equal? if drop "* cica cica da yaya !!!" .s .l end then
     dup 3 equal? if drop "* hi ^-^" .s .l end then
     dup 4 equal? if drop "* hello :)" .s .l end then
     dup 5 equal? if drop "* hey *^-^*" .s .l end then
     dup 6 equal? if drop "* hiya \^o^/" .s .l end then
     dup 7 equal? if drop "* I wish you a lovely day" .s .l end then
     dup 8 equal? if drop "* I wish you a lovely day { or night :P }" .s .l end then
     dup 9 equal? if drop "* o.o" .s .l end then
     drop "* lovely ^3^" .s .l end
   ; define-function

   : hi
     << -- >>
     hi,random
     hi,say
     end
   ; define-function
   #+end_src
** help
   #+begin_src cicada-nymph :tangle core.cn
   : help
     << -- >>
     "* helpful documentations will be written soon" .s .l
     "  please wait ^-^" .s .l
     end
   ; define-function
   #+end_src
* -----------------------------------
* port
** 記 關於輸入輸出
   * 接口設計分兩個層次
     1. 底層的以 port 爲基礎的接口
        這裏應該如何設計還不確定
        可能會模仿操作系統所提供的接口
     2. 高層的以 path 爲基礎的接口
        這裏將抽象掉 port 這個概念
        也就是每次簡單的讀寫都伴隨兩個對 port 的操作
        這樣接口就很簡單 但是速度可能會非常慢
** open-input-port
   #+begin_src cicada-nymph :tangle core.cn
   : open-input-port
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     0
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** open-output-port,[creat|update]
   * interface
     |--------+-----------------------|
     | creat  | fail if already exist |
     | update | fail if nor exist     |
     |--------+-----------------------|
   * one should always know if a file exist or not
     when open it as output-port
     predicates are provided to help you to do so
   #+begin_src cicada-nymph :tangle core.cn
   : open-output-port,creat
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1102 <<
     O_RDWR  0002h 0002o
     O_CREAT 0100h 0100o
     O_TRUNC 0800h 1000o
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function

   : open-output-port,update
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     110100100b
     >>
     8#1002 <<
     O_RDWR  0002h 0002o
     O_TRUNC 0800h 1000o
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** close-port
   #+begin_src cicada-nymph :tangle core.cn
   : close-port
     << port
        -- true
        -- error-code, false >>
     :syscall-number,close:
     1 syscall
     dup
     negative? if
       false
       end
     then
     drop true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,open-output-port,creat
     << -- >>
     "kkk~" open-output-port,creat if
       close-port if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,open-output-port,creat

   : test,open-output-port,update
     << -- >>
     "kkk~" open-output-port,update if
       close-port if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,open-output-port,update
   #+end_src
** read-port
   #+begin_src cicada-nymph :tangle core.cn
   : read-port
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** write-port
   #+begin_src cicada-nymph :tangle core.cn
   : write-port
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,read-port
     << -- >>
     64 allocate-local-memory
     dup
     "kkk~" open-input-port if
       64 swap read-port if
         .s .l
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,read-port
   #+end_src
* path
** 記 syntax about path
   * 利用了系統的路徑格式
     同時又把系統的路徑格式抽象掉了
   #+begin_src cicada-nymph
   {path: home xyh cicada core.cn}
   "/home/xyh/cicada/core.cn"

   {path: home xyh cicada}
   "/home/xyh/cicada"

   {path: +working+ core.cn}
   "./core.cn"

   {path: +parent+ cicada core.cn}
   "../cicada/core.cn"

   {path: +library+ kkk main.cn}
   "/home/xyh/.cicada/library/kkk/main.cn"
   #+end_src
** >< relative-path?
** >< full-path?
** stat structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +stat,st_dev+        ; define-variable
   0 : +stat,st_ino+        ; define-variable
   0 : +stat,st_mode+       ; define-variable
   0 : +stat,st_nlink+      ; define-variable
   0 : +stat,st_uid+        ; define-variable
   0 : +stat,st_gid+        ; define-variable
   0 : +stat,st_rdev+       ; define-variable
   0 : +stat,st_size+       ; define-variable
   0 : +stat,st_blksize+    ; define-variable
   0 : +stat,st_blocks+     ; define-variable
   0 : +stat,st_atime+      ; define-variable
   0 : +stat,st_atime_nsec+ ; define-variable
   0 : +stat,st_mtime+      ; define-variable
   0 : +stat,st_mtime_nsec+ ; define-variable
   0 : +stat,st_ctime+      ; define-variable
   0 : +stat,st_ctime_nsec+ ; define-variable
   0 : +stat,__unused4+     ; define-variable
   0 : +stat,__unused5+     ; define-variable
   0 : +stat,end+           ; define-variable

   : init,stat
     << offset -- >>
     *jo-size* 4 equal? if
       dup address +stat,st_dev+        save *jo-size* add
       dup address +stat,st_ino+        save *jo-size* add
       dup address +stat,st_mode+       save 2 add
       dup address +stat,st_nlink+      save 2 add
       dup address +stat,st_uid+        save 2 add
       dup address +stat,st_gid+        save 2 add
       dup address +stat,st_rdev+       save *jo-size* add
       dup address +stat,st_size+       save *jo-size* add
       dup address +stat,st_blksize+    save *jo-size* add
       dup address +stat,st_blocks+     save *jo-size* add
       dup address +stat,st_atime+      save *jo-size* add
       dup address +stat,st_atime_nsec+ save *jo-size* add
       dup address +stat,st_mtime+      save *jo-size* add
       dup address +stat,st_mtime_nsec+ save *jo-size* add
       dup address +stat,st_ctime+      save *jo-size* add
       dup address +stat,st_ctime_nsec+ save *jo-size* add
       dup address +stat,__unused4+     save *jo-size* add
       dup address +stat,__unused5+     save *jo-size* add
           address +stat,end+           save
       end
     then
     *jo-size* 8 equal? if
       dup address +stat,st_dev+        save *jo-size* add
       dup address +stat,st_ino+        save *jo-size* add
       <<
       note the following order changing
       this is linux' bad
       >>
       dup address +stat,st_nlink+      save 8 add
       dup address +stat,st_mode+       save 4 add

       dup address +stat,st_uid+        save 4 add
       dup address +stat,st_gid+        save 4 add
                                             4 add << padding >>
       dup address +stat,st_rdev+       save *jo-size* add
       dup address +stat,st_size+       save *jo-size* add
       dup address +stat,st_blksize+    save *jo-size* add
       dup address +stat,st_blocks+     save *jo-size* add
       dup address +stat,st_atime+      save *jo-size* add
       dup address +stat,st_atime_nsec+ save *jo-size* add
       dup address +stat,st_mtime+      save *jo-size* add
       dup address +stat,st_mtime_nsec+ save *jo-size* add
       dup address +stat,st_ctime+      save *jo-size* add
       dup address +stat,st_ctime_nsec+ save *jo-size* add
       dup address +stat,__unused4+     save *jo-size* add
       dup address +stat,__unused5+     save *jo-size* add
           address +stat,end+           save
       end
     then
     end
   ; define-function

   0 init,stat
   +stat,end+ : +stat,length+ ; define-variable
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,stat
     << -- >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       dup .
       error-code->string .s .l
       end
     then
     drop
     :stat-structure init,stat
     +stat,st_dev+        fetch . "+stat,st_dev+" .s .l
     +stat,st_ino+        fetch . "+stat,st_ino+" .s .l
     *jo-size* 4 equal? if
     +stat,st_mode+       fetch-two-bytes  . "+stat,st_mode+" .s .l
     +stat,st_nlink+      fetch-two-bytes  . "+stat,st_nlink+" .s .l
     +stat,st_uid+        fetch-two-bytes  . "+stat,st_uid+" .s .l
     +stat,st_gid+        fetch-two-bytes  . "+stat,st_gid+" .s .l
     then
     *jo-size* 8 equal? if
     +stat,st_nlink+      fetch  . "+stat,st_nlink+" .s .l
     +stat,st_mode+       fetch-four-bytes  . "+stat,st_mode+" .s .l
     +stat,st_uid+        fetch-four-bytes  . "+stat,st_uid+" .s .l
     +stat,st_gid+        fetch-four-bytes  . "+stat,st_gid+" .s .l
     then
     +stat,st_rdev+       fetch . "+stat,st_rdev+" .s .l
     +stat,st_size+       fetch . "+stat,st_size+" .s .l
     +stat,st_blksize+    fetch . "+stat,st_blksize+" .s .l
     +stat,st_blocks+     fetch . "+stat,st_blocks+" .s .l
     +stat,st_atime+      fetch . "+stat,st_atime+" .s .l
     +stat,st_atime_nsec+ fetch . "+stat,st_atime_nsec+" .s .l
     +stat,st_mtime+      fetch . "+stat,st_mtime+" .s .l
     +stat,st_mtime_nsec+ fetch . "+stat,st_mtime_nsec+" .s .l
     +stat,st_ctime+      fetch . "+stat,st_ctime+" .s .l
     +stat,st_ctime_nsec+ fetch . "+stat,st_ctime_nsec+" .s .l
     +stat,__unused4+     fetch . "+stat,__unused4+" .s .l
     +stat,__unused5+     fetch . "+stat,__unused5+" .s .l
     end
   ; define-function

   : cn ;
   test,stat

   : no ;
   test,stat
   #+end_src
** note predicate
   * to use predicate to know more about the file-tree
     before calling a function that makes action on the file-tree
** path-to-nothing?
   #+begin_src cicada-nymph :tangle core.cn
   : path-to-nothing?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     -2 equal?
     end
   ; define-function
   #+end_src
** path-to-file?
   #+begin_src cicada-nymph :tangle core.cn
   : path-to-file?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       fetch-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       fetch-four-bytes
     then
     <<
     0170000
   __S_IFDIR       0040000 /* Directory.  */
   __S_IFCHR       0020000 /* Character device.  */
   __S_IFBLK       0060000 /* Block device.  */
   __S_IFREG       0100000 /* Regular file.  */
   __S_IFIFO       0010000 /* FIFO.  */
   __S_IFLNK       0120000 /* Symbolic link.  */
   __S_IFSOCK      0140000 /* Socket.  */
   >>
     end
   ; define-function

   #+end_src
** path-to-directory?
   #+begin_src cicada-nymph :tangle core.cn
   : path-to-directory?
     << path[address, length] -- bool >>

     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : cn ; path-to-nothing? . << 0 >>
   : ai ; path-to-nothing? . << 1 >>
   #+end_src
* file-tree
** note
   * file-tree
     two types of nodes
     1. file
     2. directory
     a leaf must be a file
   * the following interface is provided
     * they use path as an argument
     * they print error message on error
       instead of return error info
       or rise exception
     * the concept of port is
       completely removed from the interface
     --------------------------------
     1. creat-file
        creat-directory
        update-file
        update-directory
     2. remove-file
        remove-directory
     3. find-file-in-directory
        list-file-in-directory
        directory-empty?
** 記 錯誤處理
   * 兩種風格
     IO 相關的函數在出錯時
     1. 立即報錯
     2. 返回出錯信息
   * 第一種很簡單
     它假設了所有的錯誤都是不可忽略的
** 記 元數據
   * 訪問管理
     1. 誰有權訪問這個文件
     2. 他的權利是什麼
   * 文件類型
     [linux 沒有]
   * 文件大小
   * 文件使用註釋
     [linux 沒有]
* poi
** note
   * poi denotes path-organizer
     it can give a name to a path
     one path one name
     it is designed for (load-file)
** note two directories
   * two directories to store the name path record
     1. user :
        "/home/<user>/.cicada/poi"
     2. system :
        "/etc/cicada/poi"
   * note that
     these two directories are viewed as one by poi
     no such things like
     user overriding system will happen
     one name can only exist in one of the two directories
     more on this in the following note
** note interface for command-line-function
   * cn poi add  <name> <relative-path>
   * cn poi sub  <name>
   * cn poi up   <name> <relative-path>
   * cn poi show <name>
   * cn poi list
   * <relative-path> is converted to <full-path>
     with the help of working-directory
   * <relative-path> is in the format of
     "./dictionary/file"
     "./dictionary/dictionary"
     note that
     for a <relative-path> of dictionary
     not tailing "/" should be added
** note interface for load-file
   * a path can be a file or a directory
     1. file
        "name" load-file
     2. directory
        "name/file" load-file
        note that
        use "name/file"
        instead of "name/file.cn"
** note interface in cicada-nymph code
   * poi should not be called in cicada-nymph code
** help
   #+begin_src cicada-nymph :tangle core.cn
   : poi,help
     << -- >>

     end
   ; define-function
   #+end_src
** add
   #+begin_src cicada-nymph :tangle core.cn
   : poi,add
     << name[address, length], relative-path[address, length] -- >>

     end
   ; define-function
   #+end_src
** sub
   #+begin_src cicada-nymph :tangle core.cn
   : poi,sub
     << name[address, length] -- >>

     end
   ; define-function
   #+end_src
** up
   * up denotes update
   #+begin_src cicada-nymph :tangle core.cn
   : poi,up
     << name[address, length], relative-path[address, length] -- >>

     end
   ; define-function
   #+end_src
** list
   #+begin_src cicada-nymph :tangle core.cn
   : poi,list
     << -- >>

     end
   ; define-function
   #+end_src
** show
   #+begin_src cicada-nymph :tangle core.cn
   : poi,show
     << name[address, length] -- >>

     end
   ; define-function
   #+end_src
* load-file
** ><
   #+begin_src cicada-nymph :tangle core.cn
   : load-file
     << ??? -- >>

     end
   ; define-function
   #+end_src
* -----------------------------------
* name-hash-table
** note naming & factoring
   * open addressing
     for we do not need to delete
   * math
     * hash
     * probe
   * memory
     * insert
     * search
   * function
     * map
     * reverse
** memory allocation
   * the following are some prime number
     ready to be used
     * 1000003   about 976 k
     * 1000033
     * 1000333
     * 100003    about 97 k
     * 100333
     * 997
     * 499
   #+begin_src cicada-nymph :tangle core.cn
   100333 drop
   13
   : *name-hash-table,size*
   ; define-variable

   *jo-size* 4 mul
   : *name-hash-table,unit*
   ; define-variable

   *name-hash-table,size*
   *name-hash-table,unit* mul
   allocate-memory
   : *name-hash-table*
   ; define-variable

   0
   : *name-hash-table,counter*
   ; define-variable
   #+end_src
** hash
   * prime table size
   * linear probing
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,hash
     << number, counter -- index >>
     add *name-hash-table,size* mod
     end
   ; define-function
   #+end_src
** string->finite-carry-sum
   #+begin_src cicada-nymph :tangle core.cn
   16
   : *max-carry-position*
   ; define-variable

   : string->finite-carry-sum,loop
     << carry-sum, string[address, length], counter -- carry-sum >>
     over zero? if
       drop drop2
       end
     then
     dup *max-carry-position* greater-than? if
       drop 0 << re-start from 0 >>
     then
     xx|over|x
     string-head,char over
     2 swap power
     mul
     x|swap|xxxx add xxx|swap|x
     add1 xx|swap|x
     string-tail,char x|swap|xx
     <> string->finite-carry-sum,loop
   ; define-function

   : string->finite-carry-sum
     << string[address, length] -- carry-sum >>
     0 xx|swap|x << carry-sum >>
     0 << counter >>
     string->finite-carry-sum,loop
     end
   ; define-function
   #+end_src
** name
*** note
    * a name is an index into name-hash-table
    * an entry can be viewed
      1. as a point
      2. as an orbit
    * in a name entry we have the following fields
      |-------------------------------+-------------------------|
      |                               | note                    |
      |-------------------------------+-------------------------|
      | primitive-string              | 0 denotes               |
      | [address]                     | name not used           |
      |-------------------------------+-------------------------|
      | title                         | 0 denotes               |
      | [index into name-title-table] | name not used as title  |
      |-------------------------------+-------------------------|
      | orbit-length                  | as an orbit             |
      | [number]                      | its length gets updated |
      |-------------------------------+-------------------------|
      | orbiton                       | as a point              |
      | [address]                     | it is on an orbit       |
      |-------------------------------+-------------------------|
*** name->address
    #+begin_src cicada-nymph :tangle core.cn
    : name->address
      << name -- address >>
      *name-hash-table,unit* mul
      *name-hash-table* add
      end
    ; define-function
    #+end_src
*** name,used?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used?
      << name -- bool >>
      name->address
      fetch zero? false?
      end
    ; define-function
    #+end_src
*** name,used-as-title?
    #+begin_src cicada-nymph :tangle core.cn
    : name,used-as-title?
      << name -- bool >>
      name->address
      *jo-size* add
      fetch zero?
      end
    ; define-function
    #+end_src
*** name,fetch-string
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-string
      << name -- string[address, length] >>
      name->address
      fetch
      address->primitive-string
      end
    ; define-function
    #+end_src
*** name,fetch-title-index sadsfiljdasd
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-title-index
      << name -- index >>
      name->address
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-orbit-length
      << name -- length >>
      name->address
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,fetch-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,fetch-orbiton
      << name -- address >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      fetch
      end
    ; define-function
    #+end_src
*** name,save-string
    * note that
      primitive-string-heap is used
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-string
      << string[address, length], name -- >>
      *current-free-address,primitive-string-heap*
      xx|swap|xx
      save-into,primitive-string-heap
      swap
      name->address
      save
      end
    ; define-function
    #+end_src
*** name,save-title-index
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-title-index
      << index, name -- >>
      name->address
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbit-length
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-orbit-length
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,save-orbiton
    #+begin_src cicada-nymph :tangle core.cn
    : name,save-orbiton
      << index, name -- >>
      name->address
      *jo-size* add
      *jo-size* add
      *jo-size* add
      save
      end
    ; define-function
    #+end_src
*** name,no-collision?
    #+begin_src cicada-nymph :tangle core.cn
    : name,no-collision?
      << name -- bool >>
      dup name,fetch-orbiton
      equal?
      end
    ; define-function
    #+end_src
** search
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,search,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       :name false
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :name name,fetch-orbit-length
     :counter equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,search,loop
   ; define-function

   : name-hash-table,search
     << string[address, length]
        -- name, true
        -- false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,search,loop
     end
   ; define-function
   #+end_src
** insert
   * I found that (insert) can not re-use (search)
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       ::string :name
       name,save-string
       :orbit :name
       name,save-orbiton
       :counter :orbit
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       :name true
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :counter *name-hash-table,size* equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     <> name-hash-table,insert,loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** string->name & name->string
   * error handling here
   #+begin_src cicada-nymph :tangle core.cn
   : string->name
     << string[address, length] -- name >>
     name-hash-table,insert
     false? if
       "* (string->name) *name-hash-table* is full!" .s .l
       end
     then
     end
   ; define-function

   : name->string
     << name -- string[address, length]] >>
     name,fetch-string
     end
   ; define-function
   #+end_src
** test
   * set *name-hash-table,size* to a small number [for example 13]
     then use the following function
     and (name-hash-table,report) to do test
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,test
     << -- >>
     "a-000" string->name . .l
     "a-111" string->name . .l
     "a-222" string->name . .l
     "a-333" string->name . .l
     "a-444" string->name . .l
     "a-555" string->name . .l
     "a-666" string->name . .l
     "a-777" string->name . .l
     "a-888" string->name . .l
     "a-999" string->name . .l
     "b-000" string->name . .l
     "b-111" string->name . .l
     "b-222" string->name . .l
     "b-333" string->name . .l
     "b-444" string->name . .l
     "b-555" string->name . .l
     "b-666" string->name . .l
     "b-777" string->name . .l
     "b-888" string->name . .l
     "b-999" string->name . .l
     end
   ; define-function
   #+end_src
** note about report
   * report point orbit by orbit
     in the following format
   * {index} string # orbit-lenght
     * {index} string
     * {index} string
     * {index} string
   * if used as title
     add a (AS TITLE) as postfix
** report
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,report,orbit
     << name, counter -- >>
     over name,fetch-orbit-length
     over less-than? if
       drop2
       end
     then
     over name,fetch-string string->finite-carry-sum
     over name-hash-table,hash
     dup name,fetch-orbiton
     << name, counter, new-name, orbiton >>
     x|over|xxx name,fetch-string string->finite-carry-sum
     0 name-hash-table,hash
     equal? if
       "  {" .s
       dup write-nature-number
       "} " .s
       name,fetch-string .s
       .l
     else
       drop
     then
     add1 <> name-hash-table,report,orbit
   ; define-function

   : name-hash-table,report,loop
     << name -- >>
     dup *name-hash-table,size* equal? if
       drop
       end
     then
     dup name,used? if
     dup name,no-collision? if
       << * {index} string # orbit-lenght >>
       "* {" .s
       dup write-nature-number
       "} " .s
       dup name,fetch-string .s
       " # " .s
       dup name,fetch-orbit-length
       write-nature-number
       .l
       dup 1 name-hash-table,report,orbit
     then
     then
     add1 <> name-hash-table,report,loop
   ; define-function

   : name-hash-table,report
     << -- >>
     0 name-hash-table,report,loop
     "* totally : " .s
     *name-hash-table,counter* write-nature-number
     .l
     end
   ; define-function
   #+end_src
* -----------------------------------
* command-line-interface
** note
** command-line,unknow-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,unknow-function
     << -- >>
     "* (cicada-nymph) unknow command-line-function : " .s
     get-command-line
     string-tail,word
     string-head,word .s .l
     "* good bye ^-^/" .s .l
     bye
     end
   ; define-function
   #+end_src
** command-line,stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,stack-REPL
     << -- >>
     welcome
     initial-report
     hi
     "* you are in the (stack-REPL)" .s .l
     "  every time after a word is executed" .s .l
     "  the argument-stack get printed" .s .l
     print-argument-stack,pretty
     jo stack-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,basic-REPL
     << -- >>
     welcome
     initial-report
     hi
     "* you are in the (basic-REPL)" .s .l
     "  this REPL does not print any thing automaticly" .s .l
     jo basic-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,poi
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,poi
     << -- >>
     "* poi byebye" .s .l
     bye
     end
   ; define-function
   #+end_src
** command-line,no-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,no-function
     << -- >>
     <> command-line,stack-REPL
   ; define-function
   #+end_src
** command-line-dispatcher
   #+begin_src cicada-nymph :tangle core.cn
   : command-line-dispatcher
     << -- >>
     get-command-line
     string-tail,word
     dup2 space-string? if
       drop2
       <> command-line,no-function
     then
     string-head,word
     >::1st-word
     ::1st-word "basic-REPL" string-equal? if
       <> command-line,basic-REPL
     then
     ::1st-word "stack-REPL" string-equal? if
       <> command-line,stack-REPL
     then
     ::1st-word "poi" string-equal? if
       <> command-line,poi
     then
       <> command-line,unknow-function
   ; define-function
   #+end_src
* *the-story-begin*
  #+begin_src cicada-nymph :tangle core.cn
  : the-story-begin
    << -- >>
    <> command-line-dispatcher
  ; define-function

  the-story-begin
  #+end_src
* ===================================
* test
** name-hash-table
   #+begin_src cicada-nymph
   name-hash-table,test
   name-hash-table,report
   #+end_src
** report
   #+begin_src cicada-nymph
   report-memory
   report-dictionary
   report-syntax
   #+end_src
* ===================================
