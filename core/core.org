#+TITLE:  小蟬之核 / core of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* let the interface of jo-link be general
* 在 姓 的概念的衝擊下 對整個系統的理解都有所改變了
* 很多術語都用亂了 需要整理
  * 比如 "語義" "語法"
* new way to do data-structure
* un-named function
  * 我發現我已經可以使用 map 了
    爲了實現 un-named function
    有一下兩種方法
    1. 去實現 GC
       同時 還能停止使用 *circular-string-area*
       * 要知道不論如何 爲了實現 cicada-language GC 都是需要的
         而
         就像 現在 *name-hash-table*
         被 cicada-language 和 cicada-nymph 共用一樣
         GC 也是可以被共用的
       * 但是這其實是不可能的
         因爲 cicada-nymph 是沒有數據類型的
    2. 使用 *circular-jojo-area*
       要知道現在的效果是
       string 在 REPL 中出現時 就用 *circular-string-area*
       string 在 make-jojo 中出現時 就用 *string-area*
       這種設計對於函數可能也同樣適用
  * 我使用第二種方式來實現我需要的性狀
    這樣我就能在 cicada-nymph 中實驗 joy 中的組合邏輯語義了
  * 關於具體實現有以下問題需要注意
    即
    局部變量一定要能夠在 匿名的 jojo 中被使用
  * (loop) 和 (recur) 也要能夠在 匿名的 jojo 中被使用
  * cicada-language 還是必要的嘛 ?
    cicada-nymph 就足夠了 ?
    需要回顧一下 cicada-language 的筆記
    調和一下兩個語義的差異
* scope of named-local-variable in function
* loading-stack
* todo
** little-tester [於命令行工具還有 load 相結合] :needed:
** design a way to remove magic numbers [not variable, but file by file like erlang ?]
** need more lib functions about string processing and better factoring for string processing
** debug-REPL                         :maybe:
** language-level support for creating and managing processes :maybe:
* ===================================
* note
** 注意 目前儘量只寫 就實現 cicada-language 而言有用的函數[特性]
   * 也就是說 很多有趣的程序我都推遲再寫
     在這個準則下不被實現的有趣函數[特性]
     1. big number
     2. 同餘方程
     3. data section
   * 而所需要的函數如下
     1. 練習實現匯編器 爲蟬語的 VM 設計做準備
     2. 簡單的將代碼模塊化的系統
     3. GC 和 hash-table 的實驗
** 動態內存管理
   * 我發現不用 GC
     我也能實現對結構化數據的有限的處理
     只要我設計好接口
     那麼 所得到的結構將是很不錯的
* note problem
** 在 string-area 中函數的姓名在被加載到 name-hash-table 時 被重新複製了一遍
** only one error-code->string is not enough
* ===================================
* writers
** note name of writers
   * the use of "." as prefix
     is inherited from Forth
   * table
     | .  | pretty_write_integer | assembly |
     | .i | write_integer        | core     |
     | .s | write_string         | assembly |
     | .l | linefeed             | core     |
     | .b | write-byte           |          |
** .l .i .b
   #+begin_src cicada-nymph :tangle core.cn
   : .l
     << -- >>
     10 write-byte
     end
   ; define-function

   : .i
     << -- >>
     write-integer
     end
   ; define-function

   : .b
     << byte -- >>
     write-byte
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : kkk
     "kkk took my baby away !" .s
     .l
     end
   ; define-function

   kkk
   #+end_src
* -----------------------------------
* *rule-set,make-jojo* : if & else & then
** 記 條件轉跳
   * one predicate can make two branchs
     three predicates can make four branchs
     three predicates may only make three branchs
     but indeed there must be an invisible branch
** word:[if|else|then]?
   #+begin_src cicada-nymph :tangle core.cn
   : word:if?
     << word[address, length] -- bool >>
     "if" string-equal?
     end
   ; define-function

   : word:else?
     << word[address, length] -- bool >>
     "else" string-equal?
     end
   ; define-function

   : word:then?
     << word[address, length] -- bool >>
     "then" string-equal?
     end
   ; define-function
   #+end_src
** syntax,[if|else|then],make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,make-jojo
     << string[address, length], word:if --
        address, string[address, length] >>
     drop2
     jo instruction,false?branch
       save-into,jojo-area
     *current-free-address,jojo-area* xx|swap|x
     0 save-into,jojo-area
     end
   ; define-function

   : syntax,else,make-jojo
     << address, string[address, length], word:else --
        address, string[address, length] >>
     drop2
     jo instruction,branch
        save-into,jojo-area
     x|swap|xx
     *current-free-address,jojo-area* xxx|swap|x
     0 save-into,jojo-area
     << address, string[address, length], address >>
     *current-free-address,jojo-area*
     over sub *jo-size* div
     swap save
     end
   ; define-function

   : syntax,then,make-jojo
     << address, string[address, length], word:then --
        string[address, length] >>
     drop2
     x|swap|xx
     *current-free-address,jojo-area*
     over sub *jo-size* div
     swap save
     end
   ; define-function
   #+end_src
** test if & else & then
   #+begin_src cicada-nymph
   : .12
     << 1 2 -- >>
     2 equal? if
       "(^-^)" .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     else
       "     " .s
       1 equal? if
         "\^o^/" .s
       else
         "     " .s
       then
     then
     end
   ; define-function

   : .12,test
     .l
     1 2 .12 .l
     6 2 .12 .l
     1 6 .12 .l
     6 6 .12 .l
     end
   ; define-function
   .12,test
   #+end_src
** test if & else & then [by factorial]
   #+begin_src cicada-nymph
   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 factorial
     mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function
   factorial,test
   #+end_src
* *rule-set,make-jojo* : prepare-for & exception-reset-stack
** 記 異常處理
   * 在語言中設計良好的異常處理
     是鼓勵程序員寫出皮實的程序的關鍵
   * 目前的
     利用 prepare-for 來實現的異常處理機制
     可能還遠遠不夠良好
** word:prepare-for?
   #+begin_src cicada-nymph :tangle core.cn
   : word:prepare-for?
     << word[address, length] -- bool >>
     "prepare-for" string-equal?
     end
   ; define-function
   #+end_src
** syntax,prepare-for,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,prepare-for,make-jojo
     << string[address, length], word:prepare-for --
        string[address, length] >>
     drop2
     jo instruction,prepare-for
       save-into,jojo-area
     jo instruction,exception-head
       save-into,jojo-area
     end
   ; define-function
   #+end_src
** word:exception-reset-stack?
   #+begin_src cicada-nymph :tangle core.cn
   : word:exception-reset-stack?
     << word[address, length] -- bool >>
     "exception-reset-stack" string-equal?
     end
   ; define-function
   #+end_src
** syntax,exception-reset-stack,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,exception-reset-stack,make-jojo
     << string[address, length], word:exception-reset-stack --
        string[address, length] >>
     drop2
     jo instruction,exception-reset-stack
       save-into,jojo-area
     current-defining-word find-jo,through-jo-link
     drop
       save-into,jojo-area
     end
   ; define-function
   #+end_src
* *rule-set,make-jojo* : save-to
** word:save-to?
   #+begin_src cicada-nymph :tangle core.cn
   : word:save-to?
     << word[address, length] -- bool >>
     "save-to" string-equal?
     end
   ; define-function
   #+end_src
** syntax,save-to,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,save-to,make-jojo
     << string[address, length], word:save-to --
        string[address, length] >>
     <<
     note that
     the following call to (syntax,address,make-jojo)
     will drop word:save-to
     >>
     syntax,address,make-jojo
     jo save
       save-into,jojo-area
     end
   ; define-function
   #+end_src
* *rule-set,make-jojo* : loop
** word:loop?
   #+begin_src cicada-nymph :tangle core.cn
   : word:loop?
     << word[address, length] -- bool >>
     "loop" string-equal?
     end
   ; define-function
   #+end_src
** syntax,loop,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,loop,make-jojo
     << string[address, length], word:loop --
        string[address, length] >>
     drop2
     jo tail-call
       save-into,jojo-area
     current-defining-word find-jo,through-jo-link
     drop
       save-into,jojo-area
     end
   ; define-function
   #+end_src
* *rule-set,make-jojo* : recur
** word:recur?
   #+begin_src cicada-nymph :tangle core.cn
   : word:recur?
     << word[address, length] -- bool >>
     "recur" string-equal?
     end
   ; define-function
   #+end_src
** syntax,recur,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,recur,make-jojo
     << string[address, length], word:recur --
        string[address, length] >>
     drop2
     current-defining-word find-jo,through-jo-link
     drop
       save-into,jojo-area
     end
   ; define-function
   #+end_src
** test recur [by factorial]
   #+begin_src cicada-nymph
   : factorial
     << number -- number >>
     dup
     one? if
       end
     then
     dup sub1 recur mul
     end
   ; define-function

   : factorial,test
     .l
     1 factorial . .l
     2 factorial . .l
     3 factorial . .l
     4 factorial . .l
     5 factorial . .l
     6 factorial . .l
     7 factorial . .l
     8 factorial . .l
     9 factorial . .l
     10 factorial . .l
     11 factorial . .l
     12 factorial . .l
     13 factorial . .l
     14 factorial . .l
     15 factorial . .l
     16 factorial . .l
     17 factorial . .l
     18 factorial . .l
     19 factorial . .l
     20 factorial . .l
     end
   ; define-function

   factorial,test
   #+end_src
* more,rule-set,make-jojo
  #+begin_src cicada-nymph :tangle core.cn
  : more,rule-set,make-jojo
    << -- >>
    jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
    jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
    jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule

    jo word:prepare-for?
    jo syntax,prepare-for,make-jojo
    *rule-set,make-jojo* add-rule
    jo word:exception-reset-stack?
    jo syntax,exception-reset-stack,make-jojo
    *rule-set,make-jojo* add-rule

    jo word:save-to?
    jo syntax,save-to,make-jojo
    *rule-set,make-jojo* add-rule

    jo word:loop?  jo syntax,loop,make-jojo  *rule-set,make-jojo* add-rule
    jo word:recur? jo syntax,recur,make-jojo *rule-set,make-jojo* add-rule
    end
  ; define-function

  more,rule-set,make-jojo
  #+end_src
* -----------------------------------
* allocate
** note
   * an interface of *un-initialized-memory*
** clear-memory [not using]
   * this kinds of functions
     must be implemented in assembly code
   #+begin_src cicada-nymph
   : clear-memory
     << size, address -- >>
     over zero? if
       drop2
       end
     then
     0 over save
     add1 swap
     sub1 swap
     loop
   ; define-function
   #+end_src
** allocate-memory
   #+begin_src cicada-nymph :tangle core.cn
   : allocate-memory
     << size -- address >>
     dup *current-free-address,un-initialized-memory* clear-memory
     *current-free-address,un-initialized-memory* swap << address as return value >>
     address *current-free-address,un-initialized-memory* add-save
     end
   ; define-function
   #+end_src
* *name-hash-table*
** note
   * the name-hash-table
     is used both in cicada-nymph and cicada-language
** memory allocation
   * the following are some prime number
     ready to be used
     * 1000003   about 976 k
     * 1000033
     * 1000333
     * 100003    about 97 k
     * 100333
     * 997
     * 499
   #+begin_src cicada-nymph :tangle core.cn
   100333
   << drop 13 >>
   : *name-hash-table,size*
   ; define-variable,with-tos

   *jo-size* 5 mul
   : *name-hash-table,unit*
   ; define-variable,with-tos

   *name-hash-table,size*
   *name-hash-table,unit* mul allocate-memory
   : *name-hash-table*
   ; define-variable,with-tos

   0
   : *name-hash-table,counter*
   ; define-variable,with-tos
   #+end_src
* name
** note
   * a name is an index into name-hash-table
   * an entry can be viewed
     1. as a point
     2. as an orbit
   * in a name entry we have the following fields
     |-------------------------------+------------------------------|
     |                               | note                         |
     |-------------------------------+------------------------------|
     | name-string                   | 0 denotes                    |
     | [address]                     | name not used                |
     |-------------------------------+------------------------------|
     | title                         | 0 denotes                    |
     | [index into name-title-table] | name not used as title       |
     |-------------------------------+------------------------------|
     | orbit-length                  | as an orbit                  |
     | [number]                      | its length gets updated      |
     |-------------------------------+------------------------------|
     | orbiton                       | as a point                   |
     | [address]                     | it is on an orbit            |
     |-------------------------------+------------------------------|
     | jo                            | 0 denotes                    |
     | [address]                     | name not used as jo in nymph |
     |-------------------------------+------------------------------|
** name->address
   #+begin_src cicada-nymph :tangle core.cn
   : name->address
     << name -- address >>
     *name-hash-table,unit* mul
     *name-hash-table* add
     end
   ; define-function
   #+end_src
** name,used?
   #+begin_src cicada-nymph :tangle core.cn
   : name,used?
     << name -- bool >>
     name->address
     fetch zero? false?
     end
   ; define-function
   #+end_src
** name,used-as-title?
   #+begin_src cicada-nymph :tangle core.cn
   : name,used-as-title?
     << name -- bool >>
     name->address
     *jo-size* add
     fetch zero? not
     end
   ; define-function
   #+end_src
** name,used-as-nymph-jo?
   #+begin_src cicada-nymph :tangle core.cn
   : name,used-as-nymph-jo?
     << name -- bool >>
     name->address
     *jo-size* 4 mul add
     fetch zero? not
     end
   ; define-function
   #+end_src
** name,fetch-string
   #+begin_src cicada-nymph :tangle core.cn
   : name,fetch-string
     << name -- string[address, length] >>
     name->address
     fetch
     address->string
     end
   ; define-function
   #+end_src
** name,fetch-title-index
   #+begin_src cicada-nymph :tangle core.cn
   : name,fetch-title-index
     << name -- title-index >>
     name->address
     *jo-size* add
     fetch
     end
   ; define-function
   #+end_src
** name,fetch-orbit-length
   #+begin_src cicada-nymph :tangle core.cn
   : name,fetch-orbit-length
     << name -- orbit-length >>
     name->address
     *jo-size* 2 mul add
     fetch
     end
   ; define-function
   #+end_src
** name,fetch-orbiton
   #+begin_src cicada-nymph :tangle core.cn
   : name,fetch-orbiton
     << name -- orbiton >>
     name->address
     *jo-size* 3 mul add
     fetch
     end
   ; define-function
   #+end_src
** name,fetch-nymph-jo
   #+begin_src cicada-nymph :tangle core.cn
   : name,fetch-nymph-jo
     << name -- nymph-jo >>
     name->address
     *jo-size* 4 mul add
     fetch
     end
   ; define-function
   #+end_src
** name,save-string
   * note that
     string-area is used
   * currently (name,save-string) is to
     copy string into string-area
     maybe a better interface should be designed for this
     for some strings are already staticly allocated
   #+begin_src cicada-nymph :tangle core.cn
   : name,save-string
     << string[address, length], name -- >>
     *current-free-address,string-area*
     xx|swap|xx
     save-into,string-area
     swap
     name->address
     save
     end
   ; define-function
   #+end_src
** name,save-title-index
   #+begin_src cicada-nymph :tangle core.cn
   : name,save-title-index
     << title-index, name -- >>
     name->address
     *jo-size* add
     save
     end
   ; define-function
   #+end_src
** name,save-orbit-length
   #+begin_src cicada-nymph :tangle core.cn
   : name,save-orbit-length
     << orbit-length, name -- >>
     name->address
     *jo-size* 2 mul add
     save
     end
   ; define-function
   #+end_src
** name,save-orbiton
   #+begin_src cicada-nymph :tangle core.cn
   : name,save-orbiton
     << orbiton, name -- >>
     name->address
     *jo-size* 3 mul add
     save
     end
   ; define-function
   #+end_src
** name,save-nymph-jo
   #+begin_src cicada-nymph :tangle core.cn
   : name,save-nymph-jo
     << nymph-jo, name -- >>
     name->address
     *jo-size* 4 mul add
     save
     end
   ; define-function
   #+end_src
** name,no-collision?
   #+begin_src cicada-nymph :tangle core.cn
   : name,no-collision?
     << name -- bool >>
     dup name,fetch-orbiton
     equal?
     end
   ; define-function
   #+end_src
* name-hash-table
** note interface
   * open addressing
     for we do not need to delete
   * math
     * hash
   * memory
     * insert
     * search
   * function
     * string->name
     * name->string
** name-hash-table,hash
   * prime table size
   * linear probing
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,hash
     << number, counter -- index >>
     add *name-hash-table,size* mod
     end
   ; define-function
   #+end_src
** string->finite-carry-sum
   #+begin_src cicada-nymph :tangle core.cn
   16
   : *max-carry-position*
   ; define-variable,with-tos

   : string->finite-carry-sum,loop
     << carry-sum, string[address, length], counter -- carry-sum >>
     over zero? if
       drop drop2
       end
     then
     dup *max-carry-position* greater-than? if
       drop 0 << re-start from 0 >>
     then
     xx|over|x
     string-head,byte over
     2 swap power
     mul
     x|swap|xxxx add xxx|swap|x
     add1 xx|swap|x
     string-tail,byte x|swap|xx
     loop
   ; define-function

   : string->finite-carry-sum
     << string[address, length] -- carry-sum >>
     0 xx|swap|x << carry-sum >>
     0 << counter >>
     string->finite-carry-sum,loop
     end
   ; define-function
   #+end_src
** name-hash-table,search
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,search,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       :name false
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :name name,fetch-orbit-length
     :counter equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     loop
   ; define-function

   : name-hash-table,search
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,search,loop
     end
   ; define-function
   #+end_src
** name-hash-table,insert
   * I found that (insert) can not re-use (search)
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,insert,loop
     << string[address, length], number, counter
        -- name, true
        -- name, false >>
     >:counter >:number >::string
     :number :counter name-hash-table,hash
     >:name
     :number 0 name-hash-table,hash
     >:orbit
     :name name,used? false? if
       ::string :name
       name,save-string
       :orbit :name
       name,save-orbiton
       :counter :orbit
       name,save-orbit-length
       1 address *name-hash-table,counter* add-save
       :name true
       end
     then
     :name name,fetch-string
     ::string string-equal? if
       :name true
       end
     then
     :counter *name-hash-table,size* equal? if
       :name false
       end
     then
     ::string
     :number :counter add1
     loop
   ; define-function

   : name-hash-table,insert
     << string[address, length]
        -- name, true
        -- name, false >>
     dup2 string->finite-carry-sum
     0 name-hash-table,insert,loop
     end
   ; define-function
   #+end_src
** string->name & name->string
   * error handling here
   #+begin_src cicada-nymph :tangle core.cn
   : string->name
     << string[address, length] -- name >>
     name-hash-table,insert
     false? if
       "* (string->name) *name-hash-table* is full!" .s .l
       end
     then
     end
   ; define-function

   : name->string
     << name -- string[address, length]] >>
     name,fetch-string
     end
   ; define-function
   #+end_src
** note about report
   * report point orbit by orbit
     in the following format
   * {index} string # orbit-lenght
     * {index} string
     * {index} string
     * {index} string
   * if used as title
     add a (AS TITLE) as postfix
** name-hash-table,report
   #+begin_src cicada-nymph :tangle core.cn
   : name-hash-table,report,orbit
     << name, counter -- >>
     over name,fetch-orbit-length
     over less-than? if
       drop2
       end
     then
     over name,fetch-string string->finite-carry-sum
     over name-hash-table,hash
     dup name,fetch-orbiton
     << name, counter, new-name, orbiton >>
     x|over|xxx name,fetch-string string->finite-carry-sum
     0 name-hash-table,hash
     equal? if
       "  {" .s
       dup write-number
       "} " .s
       name,fetch-string .s
       .l
     else
       drop
     then
     add1
     loop
   ; define-function

   : name-hash-table,report,loop
     << name -- >>
     dup *name-hash-table,size* equal? if
       drop
       end
     then
     dup name,used? if
     dup name,no-collision? if
       << * {index} string # orbit-lenght >>
       "* {" .s
       dup write-number
       "} " .s
       dup name,fetch-string .s
       " # " .s
       dup name,fetch-orbit-length
       write-number
       .l
       dup 1 name-hash-table,report,orbit
     then
     then
     add1
     loop
   ; define-function

   : name-hash-table,report
     << -- >>
     0 name-hash-table,report,loop
     "* totally : " .s
     *name-hash-table,counter* write-number
     .l
     end
   ; define-function
   #+end_src
** test
   * set *name-hash-table,size* to a small number [for example 13]
     then use the following function
     and (name-hash-table,report) to do test
   #+begin_src cicada-nymph
   : test,name-hash-table
     << -- >>
     "a-000" string->name . .l
     "a-111" string->name . .l
     "a-222" string->name . .l
     "a-333" string->name . .l
     "a-444" string->name . .l
     "a-555" string->name . .l
     "a-666" string->name . .l
     "a-777" string->name . .l
     "a-888" string->name . .l
     "a-999" string->name . .l
     "b-000" string->name . .l
     "b-111" string->name . .l
     "b-222" string->name . .l
     "b-333" string->name . .l
     "b-444" string->name . .l
     "b-555" string->name . .l
     "b-666" string->name . .l
     "b-777" string->name . .l
     "b-888" string->name . .l
     "b-999" string->name . .l
     end
   ; define-function
   test,name-hash-table

   name-hash-table,report
   #+end_src
* *rule-set,make-jojo* : name
** word:name?
   #+begin_src cicada-nymph :tangle core.cn
   : word:name?
     << word[address, length] -- bool >>
     "name" string-equal?
     end
   ; define-function
   #+end_src
** syntax,name,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,name,make-jojo
     << string[address, length], word[address, length] --
        string[address, length] >>
     drop2
     jo instruction,literal
       save-into,jojo-area
     dup2
     string-head,word
     string->name
       save-into,jojo-area
     string-tail,word
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo word:name?
     jo syntax,name,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,syntax,name,make-jojo
     << -- >>
     name test-test-test name->string .s
     end
   ; define-function
   test,syntax,name,make-jojo
   #+end_src
* -----------------------------------
* jo in name-hash-table
** jo,save-into,name-hash-table
   #+begin_src cicada-nymph :tangle core.cn
   : jo,save-into,name-hash-table
     << jo -- >>
     >:jo
     :jo jo->name string->name >:name
     :jo :name name,save-nymph-jo
     end
   ; define-function
   #+end_src
** find-jo
   * as find-jo in name-hash-table
   #+begin_src cicada-nymph :tangle core.cn
   : find-jo
     << word[address, length]
        -- jo, true
        -- false >>
     name-hash-table,search if
     else
       drop
       false
       end
     then
     dup name,used-as-nymph-jo? if
       name,fetch-nymph-jo
       true
       end
     then
     drop
     false
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "add" find-jo
   #+end_src
* make-jojo                           :redefine:
** make-jojo,dispatch-syntax-word
   #+begin_src cicada-nymph :tangle core.cn
   : make-jojo,dispatch-syntax-word
     << string[address, length], word[address, length] --
        string[address, length] >>
     dup2 find-syntax if
       execute-jo
       end
     then
     dup2 find-jo if
       xx|swap|x drop2
       save-into,jojo-area
       end
     then
     "* (make-jojo) meets undefined word : " .s .s .l
     !undo-make-jojo
   ; define-function
   #+end_src
** make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : make-jojo,loop
     << string[address, length] -- >>
     dup2 space-string? if
       drop2
       end
     then
     dup2
     string-tail,word
     xx|swap|xx
     string-head,word
     make-jojo,dispatch-syntax-word
     loop
   ; define-function

   : make-jojo
     << string[address, length] -- >>
     local-variable-table,clear
     *rule-set,make-jojo*
     push-syntax-stack
     make-jojo,loop
     drop-syntax-stack
     end
   ; define-function
   #+end_src
* define-[function|exception]         :redefine:
** init,name-hash-table,nymph-jo
   * the function should be executed right after
     (define-function) is redefined
   * the function loads a nymph-jo into a entry in the name-hash-table
     only when the entry is not already used as nymph-jo
     thus
     it should only be called once
   * you can see
     how the features above
     make the re-definition of (define-function) hard to test
   #+begin_src cicada-nymph :tangle core.cn
   : init,name-hash-table,nymph-jo,loop
     << jo -- >>
     dup jo->name
     name-hash-table,search if
       name,used-as-nymph-jo? if
         dup last-jo,jo-link? if
           drop
           end
         then
         jo->pre-jo
         loop
       then
     else
       drop
     then

     dup jo,save-into,name-hash-table

     dup last-jo,jo-link? if
       drop
       end
     then
     jo->pre-jo
     loop
   ; define-function

   : init,name-hash-table,nymph-jo
     << -- >>
     *first-jo,jo-link*
     init,name-hash-table,nymph-jo,loop
     end
   ; define-function
   #+end_src
** define-variable,with-tos
   * not undo is needed for define-variable,with-tos
   #+begin_src cicada-nymph :tangle core.cn
   : define-variable,with-tos
     << variable, string[address, length] -- >>
     1 save-into,jojo-area

     *current-free-address,string-area*
       save-into,jojo-area
     dup2 string-head,word
       save-into,string-area

     *first-jo,jo-link*
     jo->link
       save-into,jojo-area

     *current-free-address,jojo-area*
     dup jo,save-into,name-hash-table
     save-to *first-jo,jo-link*

     *explainer,variable*
       save-into,jojo-area

     drop2
     save-into,jojo-area
     end
   ; define-function
   #+end_src
** define-exception
   #+begin_src cicada-nymph :tangle core.cn
   : define-exception
     << string[address, length] -- >>
     *current-free-address,string-area* xx|swap|x
     *current-free-address,jojo-area* xx|swap|x
     *first-jo,jo-link* xx|swap|x
     << *current-free-address,string-area*
        *current-free-address,jojo-area*
        *first-jo,jo-link*
        string[address, length] >>
     prepare-for
       !undo-make-jojo
       end

     0 save-into,jojo-area

     *current-free-address,string-area*
       save-into,jojo-area
     dup2 string-head,word
       save-into,string-area

     *first-jo,jo-link*
     jo->link
       save-into,jojo-area

     *current-free-address,jojo-area*
     dup jo,save-into,name-hash-table
     save-to *first-jo,jo-link*

     *explainer,exception*
       save-into,jojo-area

     dup2
     string-tail,word
     make-jojo

     drop2
     drop
     drop
     drop
     end
   ; define-function
   #+end_src
** define-function
   #+begin_src cicada-nymph :tangle core.cn
   : define-function
     << string[address, length] -- >>
     *current-free-address,string-area* xx|swap|x
     *current-free-address,jojo-area* xx|swap|x
     *first-jo,jo-link* xx|swap|x
     << *current-free-address,string-area*
        *current-free-address,jojo-area*
        *first-jo,jo-link*
        string[address, length] >>
     prepare-for
       !undo-make-jojo
       end

     *current-free-address,string-area*
       save-into,jojo-area
     dup2 string-head,word
       save-into,string-area

     *first-jo,jo-link*
     jo->link
       save-into,jojo-area

     *current-free-address,jojo-area*
     dup jo,save-into,name-hash-table
     save-to *first-jo,jo-link*

     *explainer,function*
       save-into,jojo-area

     dup2
     string-tail,word
     make-jojo

     drop2
     drop
     drop
     drop
     end
   ; define-function
   #+end_src
** to load jo-link into name-hash-table
   #+begin_src cicada-nymph :tangle core.cn
   init,name-hash-table,nymph-jo
   #+end_src
** test
   #+begin_src cicada-nymph
   : k 1 2 3 add add . end ; define-function
   k

   : k 1 2 3 end ; define-function
   k add add .

   : k no end ; define-function
   #+end_src
* -----------------------------------
* note data-structure
  * a data-structure is a pattern of bit [thus byte [thus jo]] in memory
  * a data-structure is referenced by is address in memory
  * what a low level programming language should provide
    is a flexible way [a mechanism]
    to manage the interfaces of all kinds of data-structures
    including
    1. define
    2. allocate & init
    3. fetch & save
    4. equal & copy
    and other operating functions
  * that is to say
    the interface of a data-structure is a set of functions
    what should be managed are
    1. how to define these functions
       maybe to generate these functions group by group
    2. how to apply these functions on their arguments
       i.e. to call these functions
  * the mechanism implemented here is very flexible
    thus
    it usage is not limited to help to form the concept about data-structure
* 記 數據結構總結
** <jo>
   execute {execute-jo}
   size {*jo-size*}
   ->name
   ->link
   ->pre-jo
   ->type
   {primitive-function-jo?}
   {function-jo?}
   {exception-jo?}
   {variable-jo?}
   last-jo? {last-jo,jo-link?}
** <string-area>
   size {*size,string-area*}
   {address->string}
   save-into {save-into,string-area}
** <jo-link>
   list-by-jo-predicate
   report
** <buffer>
   {compare-buffer}
   {cursor->next-matching-byte}
** <string>
   write {write-string}
   pretty-write {pretty-write-string}
   empty? {empty-string?}
   equal? {string-equal?}
   tail,byte {string-tail,byte}
   head,byte {string-head,byte}
   ->buffer!
   reverse! {string-reverse!}
   {char-string?}
   {zero-string?}
   {digit-string?}
   {integer-string?}
   {digit-string->number}
   ->integer
   find-char
   {space-string?}
   tail,word {string-tail,word}
   head,word {string-head,word}
** <word>
   {read-word->buffer}
   {read-word}
   {read-word-for-REPL}
   find-jo,through-jo-link
   execute {execute-word}
   find-jo
** <jojo-area>
   size {*size,jojo-area*}
   current-free-address {*current-free-address,jojo-area*}
   save-into {save-into,jojo-area}
** <syntax-stack>
   push pop
   tos drop
   empty?
   find-syntax
** <rule-set>
   fetch-border save-border
   add-rule sub-rule
   find-rule
   list-rule
** <local-jo>
   local-data-allocate,jo
   n-fetch,local-jo
   n-save,local-jo
** <local-variable-table>
   clear insert find
** <local-byte>
   allocate-local-memory
** <name-hash-table>
   size unit couter
   hash search insert report
** <name>
   ->address
   used? used-as-title? used-as-nymph-jo?
   fetch-string fetch-title-index fetch-orbit-length fetch-nymph-jo
   save-string save-title-index save-orbit-length save-orbiton save-nymph-jo
   no-collision
** <title>
   find-jo,
* 記 姓
** 接口管理器
   * 在 小蟬 中
     姓 可以被理解爲 接口管理器
     或者 名字管理器
     其目的是
     在需要的時候
     將命名過程變得更加正規
   * 姓 的
     1. 編碼數據類型的功能
     2. 簡化函數調用語法的功能
     只有在 有類型的 蟬語 中
     才能實現
   * 接口管理器 可以用來建立 數據結構的概念
     但是 接口管理器 本身的機制是與 數據結構的機制相互分離的
   * 就 name-hash-table 而言在兩個 word 之間加一個空格
   * 就 jo-link 而言
     每個 <title> 在全局的 jo-link 中
     每個 <title> 有一個新的鏈表 用於記錄註冊在其下的函數
** 英文翻譯
   * 姓 被翻譯成 title
* title
** 記 接口
   * (define-title)
     把 <title> 入 jo-link
     可以把被處理的 字符串的格式 設計的複雜一些
     以承載 各種 data-structure 所固有的複雜度
     可以先去實現最簡單的只有一個詞的情形
   * (new)
     直接製作新的東西
     並註冊新的 name 到 <title> 下
     與 (define-function) 完全類似
   * (mix)
     把已有舊的東西
     給一個 name 以註冊到 <title> 下
     可以讓它處理一個列表的東西
     同樣初的版本可以是最簡單的
** note syntax
   * <title> in *rule-set,make-jojo*
     <title> name
     save a jo into *jojo-area*
   * <title> in *rule-set,basic-REPL*
     <title> name
     execute a jo
** 記 注意
   * <title> 本身做爲 word 而被尋找到的 jo
     並不等同與 <title> 出現在
     make-jojo 中
     或 basic-REPL
     時所觸發的語法擴展
** define-title
   * a variable under which is a *current-free-address*
   #+begin_src cicada-nymph :tangle core.cn
   : define-title
     << string[address, length] -- >>

     end
   ; define-function
   #+end_src
** new
   #+begin_src cicada-nymph :tangle core.cn
   : new
     << string[address, length] -- >>

     end
   ; define-function
   #+end_src
** mix
   #+begin_src cicada-nymph :tangle core.cn
   : mix
     << string[address, length] -- >>

     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : <test-title>
   ; define-title

   : <test-title> test-name
     << -- >>
     end
   ; new

   : <test-title> test-name
   ; mix
   #+end_src
** 記 接口管理器管理自身的接口
   * 接口管理器 可以用來管理自身的接口
     是以測試
** test self title
   #+begin_src cicada-nymph

   #+end_src
* data-structure
  #+begin_src cicada-nymph :tangle core.cn

  #+end_src
* -----------------------------------
* number with base
** 記 原理
   * 現在 的 number 就只是 "integer" 而已
     更多的跟數學有關的東西將在 cicada 中設計新的語法來實現
   * 在 "integer" 這個函數中 我將只支持 對四種進位制的 字符串的 閱讀
     * 十進制
       10#1231
       10#-1231
       1231
       -1231
     * 二進制
       2#101001
       2#-101001
       2#-1011_1001
       "-" 和 "_" 的同時存在有點難讀
       此時可以用 2#1011_1001 negate
       也就是說雖然允許用 "-" 來表示負數
       但是不鼓勵這樣做
       之所以允許這樣做
       是因爲在打印負數的時候需要這種表示方式
       不能把 "-123" 打印成 "123 negate"
     * 八進制
       8#712537
       8#-712537
     * 十六進制
       16#f123acb3
       16#-F123ACB3
       大寫小寫字母都可以
   * one can use "_" to separate the number
     to make it more readable
     for example
     2#1111_0101_0001
   * actually, the base can be any 10 based number
     even greater then 36
     but when the base is greater then 36
     not all integer can be represented under this base
     for we only have 36 chars
** remove-char!
   #+begin_src cicada-nymph :tangle core.cn
   : remove-char!,loop
     << cursor, length, char -- cursor >>
     >:char
     >:length
     >:cursor
     :length zero? if
       :cursor
       end
     then
     :cursor fetch-byte :char equal? if
       :cursor add1 :length sub1
       :cursor
       string->buffer!
       :cursor
       :length sub1
       :char
     else
       :cursor add1
       :length sub1
       :char
     then
     loop
   ; define-function

   : remove-char!
     << string[address, length], char -- string[address, length] >>
     x|over|xx >:address
     remove-char!,loop >:cursor
     :address
     :cursor :address sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,remove-char!
     << -- >>
     "2#1001_1001"
     "_" string-head,byte
     remove-char! .s << 2#1001_1001 >>
     .l
     "___2#1001___1001___"
     "_" string-head,byte
     remove-char! .s << 2#1001_1001 >>
     .l
     end
   ; define-function
   test,remove-char!
   #+end_src
** latin-char?
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char?
     << char -- bool >>
     dup "A" string-head,byte less-than? false?branch 4
       drop false
       end
     dup "Z" string-head,byte less-or-equal? false?branch 4
       drop true
       end
     dup "a" string-head,byte less-than? false?branch 4
       drop false
       end
     dup "z" string-head,byte less-or-equal? false?branch 4
       drop true
       end
     drop false
     end
   ; define-function
   #+end_src
** latin-char->number
   #+begin_src cicada-nymph :tangle core.cn
   : latin-char->number
     << latin-char -- number >>
     dup "A" string-head,byte less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'A' : " .s
       .i .l
       end
     then
     dup "Z" string-head,byte less-or-equal? if
       "A" string-head,byte
       sub
       10 add
       end
     then
     dup "a" string-head,byte less-than? if
       "* (latin-char->number) the argument must be a latin-char" .s .l
       "  but the following char is less-than 'a' but greater-then 'Z' : " .s
       .i .l
       end
     then
     dup "z" string-head,byte less-or-equal? if
       "a" string-head,byte
       sub
       10 add
       end
     then
     "* (latin-char->number) the argument must be a latin-char" .s .l
     "  but the following char is greater-then 'z' : " .s
     .i .l
     end
   ; define-function
   #+end_src
** number->latin-char
   #+begin_src cicada-nymph :tangle core.cn
   : number->latin-char
     << number -- latin-char >>
     10 sub
     "a" string-head,byte
     add
     end
   ; define-function
   #+end_src
** wild-digit-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-digit-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 true
       end
     then
     over fetch-byte
     dup digit-char?
     swap latin-char?
     or if
       string-tail,byte
       loop
     then
     drop2
     false
     end
   ; define-function
   #+end_src
** wild-integer-string?
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string?
     << string[address, length] -- bool >>
     dup zero? if
       drop2 false
       end
     then
     dup2 string-head,byte
     "-" string-head,byte
     equal? if
       string-tail,byte
       wild-digit-string?
       end
     then
     wild-digit-string?
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,wild-integer-string?
     << -- >>
     "" wild-integer-string? . << 1 >>
     .l
     " " wild-integer-string? . << 0 >>
     "_asd" wild-integer-string? . << 0 >>
     " asd" wild-integer-string? . << 0 >>
     .l
     "asd" wild-integer-string? . << 1 >>
     "123" wild-integer-string? . << 1 >>
     "123asd" wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,wild-integer-string?
   #+end_src
** base#wild-integer-string?
   * a string for the following format
     is viewed as a base#digit-string
     <digit-string>#[-]<wild-integer-string-string>
     any "_" in the anywhere of the above string
     will be ignored
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string?
     << string[address, length] -- bool >>
     128 allocate-local-memory
     >:string-address
     tuck
     :string-address
     string->buffer!
     :string-address swap
     "_" string-head,byte
     remove-char!
     >:new-string-length
     >:new-string-address
     << dup2 .s .l 0 end >>
     :new-string-address
     :new-string-length
     "#" string-head,byte
     string,find-char if
     else
       false
       end
     then
     >:address-of-#
     :new-string-address
     :address-of-# :new-string-address sub
     >::base-string
     :address-of-# add1
     :address-of-# :new-string-address sub add1
     :new-string-length swap sub
     >::wild-integer-string
     ::base-string digit-string?
     ::base-string empty-string? not
     and if
     else
       false
       end
     then
     ::wild-integer-string wild-integer-string?
     ::wild-integer-string empty-string? not
     and if
       true
     else
       false
     then
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string?
     << -- >>
     "#" base#wild-integer-string? . << 0 >>
     "##" base#wild-integer-string? . << 0 >>
     "#___#" base#wild-integer-string? . << 0 >>
     "   " base#wild-integer-string? . << 0 >>
     "______#__1______" base#wild-integer-string? . << 0 >>
     "___2___#__1___c29bf210019___漢字" base#wild-integer-string? . << 0 >>
     .l
     "1#1" base#wild-integer-string? . << 1 >>
     "123#1c29bf219g42" base#wild-integer-string? . << 1 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string? . << 1 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string?
   #+end_src
** base#wild-integer-string->base-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->base-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,byte
     string,find-char if
     else
       "* (base#wild-integer-string->base-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address
     :address-of-# :address sub
     end
   ; define-function
   #+end_src
** base#wild-integer-string->wild-integer-string
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->wild-integer-string
     << string[address, length] -- string[address, length] >>
     >:length
     >:address
     :address
     :length
     "#" string-head,byte
     string,find-char if
     else
       "* (base#wild-integer-string->wild-integer-string)" .s .l
       "  the argument must be a base#wild-integer-string" .s .l
       "  but the following string does not even have a '#' in it :" .s .l
       "  " .s
       :address :length .s .l
       << to balance the argument-stack or not ??? >>
       << :address :length >>
       end
     then
     >:address-of-#
     :address-of-# add1
     :address-of-# :address sub add1
     :length swap sub
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->base-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->base-string
     .l
     "1#1" base#wild-integer-string->base-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->base-string .s .l << 123 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->base-string .s .l << ___2___ >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->base-string

   : test,base#wild-integer-string->wild-integer-string
     << -- >>
     "___2___ __1___c29bf210019___漢字" base#wild-integer-string->wild-integer-string
     .l
     "1#1" base#wild-integer-string->wild-integer-string .s .l << 1 >>
     "123#1c29bf219g42" base#wild-integer-string->wild-integer-string .s .l << 1c29bf219g42 >>
     "___2___#__1___c29bf210019___g42" base#wild-integer-string->wild-integer-string .s .l << __1___c29bf210019___g42 >>
     .l
     end
   ; define-function
   test,base#wild-integer-string->wild-integer-string
   #+end_src
** wild-integer-string->integer,with-base
   #+begin_src cicada-nymph :tangle core.cn
   : wild-integer-string->integer,with-base,loop
     << string[address, length], base, sum, counter -- integer >>
     >:counter
     >:sum
     >:base
     >:length
     >:address
     :length zero? if
       :sum
       end
     then
     :address fetch-byte >:char
     :char digit-char? if
       :char digit-char->number
     then
     :char latin-char? if
       :char latin-char->number
     then
     :base :counter power
     mul
     :sum add
     >:sum
     :address add1
     :length sub1
     :base
     :sum
     :counter add1
     loop
   ; define-function

   : wild-integer-string->integer,with-base
     << string[address, length], base -- integer >>
     >:base
     dup zero? if
       drop2
       0
       end
     then
     dup2 string-head,byte
     "-" string-head,byte
     equal? if
       string-tail,byte
       -1 >:sign
     else
       1 >:sign
     then
     >::string
     ::string string-reverse!
     :base
     0 0 wild-integer-string->integer,with-base,loop
     :sign mul
     ::string string-reverse!
     drop2
     end
   ; define-function
   #+end_src
** base#wild-integer-string->integer
   #+begin_src cicada-nymph :tangle core.cn
   : base#wild-integer-string->integer
     << string[address, length] -- integer >>
     128 allocate-local-memory
       >:address
     tuck :address string->buffer!
       >:length
     :address :length
     "_" string-head,byte remove-char!
       >::string
     ::string
     base#wild-integer-string->base-string
       >::base-string
     ::string
     base#wild-integer-string->wild-integer-string
       >::wild-integer-string
     ::base-string
     digit-string->number
       >:base
     ::wild-integer-string
     :base
     wild-integer-string->integer,with-base
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,base#wild-integer-string->integer
     << -- >>
     "0#111" base#wild-integer-string->integer .
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add .
     .l
     "1#111" base#wild-integer-string->integer .
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add .
     .l
     "10#123" base#wild-integer-string->integer .
     "_1_0__#_1__2_3_" base#wild-integer-string->integer .
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add .
     .l
     "2#1000" base#wild-integer-string->integer .
     "2#_1000_" base#wild-integer-string->integer .
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add .
     .l
     "2#1111_1111" base#wild-integer-string->integer .
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add .
     "16#f_f" base#wild-integer-string->integer .
     16 0 power 15 mul
     16 1 power 15 mul add .
     .l
     "100#111" base#wild-integer-string->integer .
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add .
     .l
     "64#zzz" base#wild-integer-string->integer .
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add .
     .l
     "36#zzzz" base#wild-integer-string->integer .
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add .
     .l
     end
   ; define-function
   test,base#wild-integer-string->integer
   #+end_src
** note writers
   * a general function
     and three special ones
   * they all writer integer
   * I will implemented them by syntax when needed
** .#
   #+begin_src cicada-nymph :tangle core.cn
   : .#,loop
     << number, base, cursor -- cursor >>
     >:cursor
     >:base
     >:number
     :number zero? if
       :cursor
       end
     then
     :number
     :base
     divmod >:mod >:div
     :mod 10 less-than? if
       :mod number->digit-char
     else
       :mod number->latin-char
     then
     :cursor
     save-byte
     :div
     :base
     :cursor add1
     loop
   ; define-function

   : .#
     << integer, base -- >>
     over zero? if
       drop .i
       end
     then
     dup 36 greater-than?
     over 2 less-than?
     or if
       "* (.#) the base " .s .i " is not valid to write a number" .s .l
       "  a base should in between 2 and 36 includingly" .s .l
       "  the integer to be written is " .s .i .l
       end
     then
     dup .i
     "#" .s
     over negative? if
       swap negate swap
       "-" .s
     then
     128 allocate-local-memory >:buffer
     :buffer
     .#,loop >:cursor
     :buffer
     :cursor :buffer sub
     string-reverse! .s
     end
   ; define-function
   #+end_src
** .#2 .#8 .#16
   #+begin_src cicada-nymph :tangle core.cn
   : .#2  2  .# " " .s end ; define-function
   : .#8  8  .# " " .s end ; define-function
   : .#16 16 .# " " .s end ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111        0  .#
   1#111        1  .#
   10#123       10 .#
   10#0         10 .#
   2#1000       2  .#
   2#1111_1111  2  .#
   16#f_f       16 .#
   36#zzzz      36 .#

   2#1111_1111  .#2
   8#123        .#8
   16#fff       .#16
   #+end_src
** 記 bit-xor
   * 對 bit-xor 的解釋
     1. 對稱地看
        diff
     2. 非對稱地看
        後者是 1 則 求 invert
     結構上 對於同樣的抽象函數
     認識上 可以有不同的理解方式
** 記 gamber
   * gray code 很有趣
     尤其是其生成方式
     即 先取對稱 再加前綴
     是利用 對稱性 和 不變量[不變性] 的典型例子
   * 同樣的一個 0 1 字符串
     比如 "100"
     把它做爲自然編碼的二進制數 其值爲 4 這個是 number
     把它做爲 gray code 編碼的二進制數 其值爲 7 這個我稱之爲 gamber
   * 這樣 我們就有如下兩個函數
     string->number
     string->gamber
     同時這兩個函數還引出了下面兩個函數
     number->gamber
     gamber->number
   * 下面的的算法是通過把數字列表之後
     逐 bit 觀察每列的接連 bit 值的規則而得來的
     比如
     以生成規則爲定義
     然後總結一下所發現的每一列的規律
     就可以得到對下面的算法的有效性的嚴格證明
   * 注意
     兩個方向的運算迥然不同
     還是要以生成方式爲核心來理解這一點
     只要把生成過程中
     每次在做完對稱後
     所添加的 一串前綴 1 看成是一個整體
     就能理解了
     可以把每次的 一串前綴 1 看成是一根棍子
     一根棍子 一根棍子 地 來觀察所生成的列表 就行了
     可以發現
     棍子 其實就是 自然編碼時
     逐 bit 觀察列表時的 接連 bit 值
     那麼就能理解到
     爲什麼 number->gamber 比 gamber->number 容易計算了
   * 另外還要注意
     從最高位向最低位去計算
     是爲了逐步確定數在序關係中的位置
** number->gamber
   #+begin_src cicada-nymph :tangle core.cn
   : number->gamber
     << number -- gamber >>
     dup 1 bit-right
     bit-xor
     end
   ; define-function
   #+end_src
** gamber->number
   #+begin_src cicada-nymph :tangle core.cn
   : gamber->number,loop
     << gamber, number, cursor -- number >>
     dup negative? if
       drop
       swap drop
       end
     then
     >:cursor
     >:number
     >:gamber
     :gamber :cursor get-bit
     :number :cursor add1 get-bit
     xor if
       :number :cursor set-bit >:number
     then
     :gamber
     :number
     :cursor sub1
     loop
   ; define-function

   : gamber->number
     << gamber -- number >>
     dup find-highest-set-bit
     dup negative? if
       drop
       end
     then
     0 over set-bit
     swap sub1
     gamber->number,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,gamber
     << -- >>
     2#0000 number->gamber .#2 .l
     2#0001 number->gamber .#2 .l
     2#0010 number->gamber .#2 .l
     2#0011 number->gamber .#2 .l
     2#0100 number->gamber .#2 .l
     2#0101 number->gamber .#2 .l
     2#0110 number->gamber .#2 .l
     2#0111 number->gamber .#2 .l
     2#1000 number->gamber .#2 .l
     2#1001 number->gamber .#2 .l
     2#1010 number->gamber .#2 .l
     2#1011 number->gamber .#2 .l
     2#1100 number->gamber .#2 .l
     2#1101 number->gamber .#2 .l
     2#1110 number->gamber .#2 .l
     2#1111 number->gamber .#2 .l
     .l
     2#0000 number->gamber gamber->number .#2 .l
     2#0001 number->gamber gamber->number .#2 .l
     2#0010 number->gamber gamber->number .#2 .l
     2#0011 number->gamber gamber->number .#2 .l
     2#0100 number->gamber gamber->number .#2 .l
     2#0101 number->gamber gamber->number .#2 .l
     2#0110 number->gamber gamber->number .#2 .l
     2#0111 number->gamber gamber->number .#2 .l
     2#1000 number->gamber gamber->number .#2 .l
     2#1001 number->gamber gamber->number .#2 .l
     2#1010 number->gamber gamber->number .#2 .l
     2#1011 number->gamber gamber->number .#2 .l
     2#1100 number->gamber gamber->number .#2 .l
     2#1101 number->gamber gamber->number .#2 .l
     2#1110 number->gamber gamber->number .#2 .l
     2#1111 number->gamber gamber->number .#2 .l
     .l
     end
   ; define-function
   test,gamber
   #+end_src
* *rule-set,make-jojo* : number with base
** syntax,base#wild-integer-string,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,base#wild-integer-string,make-jojo
     << string[address, length], word[address, length] --
        string[address, length] >>
     jo instruction,literal
       save-into,jojo-area
     base#wild-integer-string->integer
       save-into,jojo-area
     end
   ; define-function
   #+end_src
** more,rule-set,make-jojo
   #+begin_src cicada-nymph :tangle core.cn
   : more,rule-set,make-jojo
     << -- >>
     jo base#wild-integer-string?
     jo syntax,base#wild-integer-string,make-jojo
     *rule-set,make-jojo* add-rule
     end
   ; define-function

   more,rule-set,make-jojo
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,syntax,base#wild-integer-string,make-jojo
     << -- >>
     0#111
     0 0 power 1 mul
     0 1 power 1 mul add
     0 2 power 1 mul add
     . . .l

     1#111
     1 0 power 1 mul
     1 1 power 1 mul add
     1 2 power 1 mul add
     . . .l

     10#123
     _1_0__#_1__2_3_
     10 0 power 3 mul
     10 1 power 2 mul add
     10 2 power 1 mul add
     . . .l .

     2#1000
     2#_1000_
     2 0 power 0 mul
     2 1 power 0 mul add
     2 2 power 0 mul add
     2 3 power 1 mul add
     . . .l .

     2#1111_1111
     2 0 power 1 mul
     2 1 power 1 mul add
     2 2 power 1 mul add
     2 3 power 1 mul add
     2 4 power 1 mul add
     2 5 power 1 mul add
     2 6 power 1 mul add
     2 7 power 1 mul add
     . . .l

     16#f_f
     16 0 power 15 mul
     16 1 power 15 mul add
     . . .l

     100#111
     100 0 power 1 mul
     100 1 power 1 mul add
     100 2 power 1 mul add
     . . .l

     64#zzz
     64 0 power 35 mul
     64 1 power 35 mul add
     64 2 power 35 mul add
     . . .l

     36#zzzz
     36 0 power 35 mul
     36 1 power 35 mul add
     36 2 power 35 mul add
     36 3 power 35 mul add
     . . .l

     end
   ; define-function

   test,syntax,base#wild-integer-string,make-jojo
   #+end_src
* basic-REPL                          :redefine:
** *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   1024 *jo-size* mul
   : *size,rule-set,basic-REPL*
   ; define-variable,with-tos

   << for cursor >>
   *jo-size* allocate-memory drop

   *size,rule-set,basic-REPL*
   allocate-memory
   : *rule-set,basic-REPL*
   ; define-variable,with-tos

   *rule-set,basic-REPL*
   *rule-set,basic-REPL* *jo-size* sub
   save
   #+end_src
** execute-word
   * to protect exception-jo from be called from basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : execute-word
     << word[address, length] -- unknown >>
     dup2
     find-jo if
       dup exception-jo? if
         drop
         "* (execute-word) can not execute exception directly : " .s
         .s .l
         end
       then
       << function & primitive-function & variable >>
       xx|swap|x drop2
       execute-jo
       end
     else
     "* (execute-word) meets undefined word : " .s
     .s .l
     then
     end
   ; define-function
   #+end_src
** word:bye?
   #+begin_src cicada-nymph :tangle core.cn
   : word:bye?
     << word[address, length] -- bool >>
     "bye" string-equal?
     end
   ; define-function
   #+end_src
** !bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : !bye,basic-REPL
     << -- >>
     exception-reset-stack
     drop-syntax-stack
     end
   ; define-exception
   #+end_src
** syntax,bye,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,bye,basic-REPL
     << word:bye -- >>
     drop2
     !bye,basic-REPL
   ; define-function
   #+end_src
** basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : basic-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     loop
   ; define-function

   : basic-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     basic-REPL,loop
     end
   ; define-function

   basic-REPL
   #+end_src
** test
   #+begin_src cicada-nymph
   0#111
   0 0 power 1 mul
   0 1 power 1 mul add
   0 2 power 1 mul add
   . .

   1#111
   1 0 power 1 mul
   1 1 power 1 mul add
   1 2 power 1 mul add
   . .

   10#123
   _1_0__#_1__2_3_
   10 0 power 3 mul
   10 1 power 2 mul add
   10 2 power 1 mul add
   . . .

   2#1000
   2#_1000_
   2 0 power 0 mul
   2 1 power 0 mul add
   2 2 power 0 mul add
   2 3 power 1 mul add
   . . .

   2#1111_1111
   2 0 power 1 mul
   2 1 power 1 mul add
   2 2 power 1 mul add
   2 3 power 1 mul add
   2 4 power 1 mul add
   2 5 power 1 mul add
   2 6 power 1 mul add
   2 7 power 1 mul add
   . .

   16#f_f
   16 0 power 15 mul
   16 1 power 15 mul add
   . .

   100#111
   100 0 power 1 mul
   100 1 power 1 mul add
   100 2 power 1 mul add
   . .

   64#zzz
   64 0 power 35 mul
   64 1 power 35 mul add
   64 2 power 35 mul add
   . .

   36#zzzz
   36 0 power 35 mul
   36 1 power 35 mul add
   36 2 power 35 mul add
   36 3 power 35 mul add
   . .
   #+end_src
* *rule-set,basic-REPL* : jo
** word:jo?
   #+begin_src cicada-nymph :tangle core.cn
   : word:jo?
     << word[address, length] -- bool >>
     "jo" string-equal?
     end
   ; define-function
   #+end_src
** syntax,jo,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,jo,basic-REPL
     << word:jo -- >>
     drop2
     read-word-for-REPL
     >::word
     ::word find-jo if
       end
     then
     "* (syntax,jo,basic-REPL) meet undefined word after jo : " .s ::word .s .l
     end
   ; define-function
   #+end_src
** init,rule-set,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : init,rule-set,basic-REPL
     << -- >>
     jo integer-string? jo string->integer       *rule-set,basic-REPL* add-rule
     jo word:bye?       jo syntax,bye,basic-REPL *rule-set,basic-REPL* add-rule
     jo word:jo?        jo syntax,jo,basic-REPL  *rule-set,basic-REPL* add-rule
     jo base#wild-integer-string? jo base#wild-integer-string->integer *rule-set,basic-REPL* add-rule
     end
   ; define-function

   init,rule-set,basic-REPL
   #+end_src
* *rule-set,basic-REPL* : if & else & then
** note ending jo
   * you do not need to use ending jo
     in code blocks formed by if else then
     because in a REPL
     things are different from function body
     and there is no such thing as
     the end of a function body in the REPL
** note executing (end) in REPL
   * when executing (end) in REPL
     nothing will happen
     this is because (execute-word) calls (end)
     and the jojo (execute-word) is pop out of return-stack
     just like meet (end) in the function-body of (execute-word)
** syntax,if,basic-REPL,meet-true
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL,meet-true,else
     << -- >>
     read-word-for-REPL
     "then" string-equal? if
       end
     then
     loop
   ; define-function

   : syntax,if,basic-REPL,meet-true
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 "else" string-equal? if
       drop2
       syntax,if,basic-REPL,meet-true,else
       end
     then
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     loop
   ; define-function
   #+end_src
** syntax,if,basic-REPL,meet-false
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL,meet-false,else
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     loop
   ; define-function

   : syntax,if,basic-REPL,meet-false
     << -- >>
     read-word-for-REPL
     dup2 "then" string-equal? if
       drop2
       end
     then
     dup2 "else" string-equal? if
       drop2
       syntax,if,basic-REPL,meet-false,else
       end
     then
     drop2
     loop
   ; define-function
   #+end_src
** syntax,if,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,if,basic-REPL
     << bool, word:if -- >>
     drop2 if
       syntax,if,basic-REPL,meet-true
     else
       syntax,if,basic-REPL,meet-false
     then
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:if? jo syntax,if,basic-REPL *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   one? if
     111 . .l
   then

   one? if
     111 . .l
   else
     666 . .l
   then
   #+end_src
* *circular-string-area*
** note
   * no length in the area anymore
     [not like the string-area]
   * and ending each string here with a 0
** allocate-memory
   #+begin_src cicada-nymph :tangle core.cn
   1024 1024 mul
   : *circular-string-area,size*
   ; define-variable,with-tos


   *circular-string-area,size* allocate-memory
   : *circular-string-area*
   ; define-variable,with-tos

   *circular-string-area*
   : *current-free-address,circular-string-area*
   ; define-variable,with-tos
   #+end_src
* *rule-set,basic-REPL* : double-quote
** save-into,circular-string-area
   #+begin_src cicada-nymph :tangle core.cn
   : save-into,circular-string-area
     << string[address, length] -- >>
     dup *current-free-address,circular-string-area* add
     *circular-string-area,size* *circular-string-area* add
     greater-or-equal? if
       *circular-string-area*
       save-to *current-free-address,circular-string-area*
     then
     tuck
     *current-free-address,circular-string-area*
     string->buffer!
     address *current-free-address,circular-string-area*
     add-save
     0 *current-free-address,circular-string-area*
     save-byte
     1 address *current-free-address,circular-string-area*
     add-save
     end
   ; define-function
   #+end_src
** syntax,double-quote,basic-REPL
   * in ASCII encode double-quote is 34
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,double-quote,basic-REPL,loop
     << cursor -- cursor >>
     read-byte
     dup 34 equal? if
       drop
       end
     then
     over save-byte
     add1
     loop
   ; define-function

   : syntax,double-quote,basic-REPL
     << word:double-quote -- string[address, length] >>
     drop2
     1024 2 mul allocate-local-memory >:buffer
     :buffer
     syntax,double-quote,basic-REPL,loop
     >:cursor
     *current-free-address,circular-string-area* >:address
     :buffer
     :cursor :buffer sub dup >:length
     save-into,circular-string-area
     :address
     :length
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:double-quote? jo syntax,double-quote,basic-REPL *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   one? if
     "111" .s .l
   then

   one? if
     "111" .s .l
   else
     "___" .s .l
   then
   #+end_src
* *rule-set,basic-REPL* : address
** syntax,address,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *syntax,address,basic-REPL,stack-balancer*
   ; define-variable,with-tos

   : syntax,address,basic-REPL
     << word:address -- address >>
     drop2
     read-word-for-REPL
     >::word
     ::word find-jo if
     else
       "* (syntax,address,basic-REPL) meet undefined word : " .s ::word .s .l
       address *syntax,address,basic-REPL,stack-balancer*
       end
     then
     >:jo
     :jo variable-jo? if
     else
       "* (syntax,address,basic-REPL) meet a not variable-jo : " .s ::word .s .l
       address *syntax,address,basic-REPL,stack-balancer*
       end
     then
     :jo *jo-size* add
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:address?
   jo syntax,address,basic-REPL
   *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   666
   address *syntax,address,basic-REPL,stack-balancer* save
   *syntax,address,basic-REPL,stack-balancer*

   address kkk
   #+end_src
* *rule-set,basic-REPL* : save-to
** syntax,save-to,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,save-to,basic-REPL
     << value, word:address -- address >>
     drop2
     read-word-for-REPL
     >::word
     ::word find-jo if
     else
       "* (syntax,save-to,basic-REPL) meet undefined word : " .s ::word .s .l
       "  the value " .s .i " is saved to no where" .s .l
       end
     then
     >:jo
     :jo variable-jo? if
     else
       "* (syntax,save-to,basic-REPL) meet a not variable-jo : " .s ::word .s .l
       "  the value " .s .i " is saved to no where" .s .l
       end
     then
     :jo *jo-size* add
     save
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:save-to?
   jo syntax,save-to,basic-REPL
   *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   666
   save-to *syntax,address,basic-REPL,stack-balancer*
   *syntax,address,basic-REPL,stack-balancer*

   1 save-to kkk
   #+end_src
* stack-REPL
** note
   * print argument-stack in every loop
** print-argument-stack
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,loop
     << address, counter -- >>
     dup zero? if
       drop2
       end
     then
     sub1 swap
       dup fetch .
     *jo-size* add
     swap
     loop
   ; define-function

   : print-argument-stack
     << -- >>
     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     *the-stack* greater-or-equal? if
       *the-stack*   << address as return value >>
       *the-stack-pointer-snapshot* *the-stack* sub
       *jo-size* div << counter as return value >>
       print-argument-stack,loop
       end
     then
     "below the stack " .s
     end
   ; define-function
   #+end_src
** print-argument-stack,pretty
   #+begin_src cicada-nymph :tangle core.cn
   : print-argument-stack,pretty
     << -- >>
     snapshot-the-stack-pointer
     .l
     "  * " .s
        *the-stack-pointer-snapshot*
        *the-stack* sub
        << ad hoc for the BUG of div >>
        dup negative? if
          negate
          *jo-size* div
          negate
        else
          *jo-size* div
        then
        .i
     " * " .s
     " -- " .s
       print-argument-stack
     "--" .s
     .l
     end
   ; define-function
   #+end_src
** stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : stack-REPL,loop
     << unknown -- unknown >>
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     print-argument-stack,pretty
     loop
   ; define-function

   : stack-REPL
     << unknown -- unknown >>
     prepare-for
       !bye,basic-REPL
       end
     *rule-set,basic-REPL* push-syntax-stack
     stack-REPL,loop
     end
   ; define-function
     #+end_src
* *lost-exception-REPL*
** reset *lost-exception-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo stack-REPL save-to *lost-exception-REPL*
   #+end_src
** test
   #+begin_src cicada-nymph
   : function-with-lost-exception
     !undo-make-jojo
   ; define-function
   function-with-lost-exception
   #+end_src
* -----------------------------------
* test endianness of n-fetch & n-save
  * big-endian is used
    in memory
    | value-1 |
    | value-2 |
    | value-3 |
    on stack
    << value-1, value-2, value-3 >>
  #+begin_src cicada-nymph
  3 *jo-size* mul allocate-memory
  : *t*
  ; define-variable,with-tos

  1 2 3 *t* 3 n-save

  << re-occur when fetching through >>
  *t* fetch .
  *t* *jo-size* add fetch .
  *t* *jo-size* 2 mul add fetch .

  *t* 3 n-fetch
  #+end_src
* rule-set
** list-rule
   * 最後寫到規則集合裏的 被最先打印出來
   * 下面的打印方式 看似有些不簡潔
     是因爲 我還沒有 integer->string 這樣的函數
     [因爲 沒有對字符串的動態內存管理]
   #+begin_src cicada-nymph :tangle core.cn
   : list-rule,loop
     << rule-set, cursor, counter -- >>
     xx|over|x equal? if
       drop drop2
       end
     then
     "  * " .s
     "(" .s
     add1 dup .i
     ")" .s .l
     swap
       dup cursor->predicate
       "    " .s jo->name .s .l
       dup cursor->function
       "    " .s jo->name .s .l
       *jo-size* sub *jo-size* sub
     swap
     loop
   ; define-function

   : list-rule
     << rule-set -- >>
     dup rule-set,fetch-border
     0 list-rule,loop
     end
   ; define-function
   #+end_src
** sub-rule
   * firstly
     in (sub-rule,loop)
     cursor move from border down to address of rule-set
     secondly
     in (sub-rule,move)
     cursor move from founded place up to border
   #+begin_src cicada-nymph :tangle core.cn
   : sub-rule,move-one
     << cursor -- >>
     >:cursor
     :cursor 2 n-fetch
     :cursor *jo-size* 2 mul sub
     2 n-save
     end
   ; define-function

   : sub-rule,move
     << rule-set, cursor -- >>
     >:cursor
     >:rule-set
     :rule-set rule-set,fetch-border >:border
     :cursor :border equal? if
       :border *jo-size* 2 mul sub
       :rule-set
       rule-set,save-border
       end
     then
     :cursor sub-rule,move-one
     :rule-set
     :cursor *jo-size* 2 mul add
     loop
   ; define-function

   : sub-rule,loop
     << rule[predicate, function], rule-set, cursor -- >>
     >:cursor
     >:rule-set
     >::rule
     :cursor :rule-set equal? if
       end
     then
     ::rule :cursor cursor->rule equal2? if
       :rule-set :cursor
       sub-rule,move
       end
     then
     ::rule
     :rule-set
     :cursor *jo-size* 2 mul sub
     loop
   ; define-function

   : sub-rule
     << rule[predicate, function], rule-set -- >>
     dup rule-set,fetch-border
     sub-rule,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   *rule-set,basic-REPL* list-rule

   jo word:address?
   jo syntax,address,basic-REPL
   *rule-set,basic-REPL* add-rule
   jo word:double-quote?
   jo syntax,double-quote,basic-REPL
   *rule-set,basic-REPL* add-rule
   *rule-set,basic-REPL* list-rule

   jo word:address?
   jo syntax,address,basic-REPL
   *rule-set,basic-REPL* sub-rule
   *rule-set,basic-REPL* list-rule

   jo word:double-quote?
   jo syntax,double-quote,basic-REPL
   *rule-set,basic-REPL* sub-rule
   *rule-set,basic-REPL* list-rule
   #+end_src
* -----------------------------------
* eval-string
** note
   * eval-string is implemented by doing side-effect on reading-stack
     this is because syntax extension system is implemented by reader-macro
   * by implementing eval-string this way
     i can easily change the syntax be used to eval a string
** eval-string
   #+begin_src cicada-nymph :tangle core.cn
   : eval-string,loop
     << unknown -- unknown >>
     tos-reading-stack space-string? if
       end
     then
     read-word-for-REPL
     dup2 find-syntax if
       execute-jo
     else
       execute-word
     then
     loop
   ; define-function

   : eval-string
     << string[address, length] -- unknown >>
     push-reading-stack
     eval-string,loop
     drop-reading-stack
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "1 2 3 add add . " eval-string
   "1 2 3 add add ." eval-string
   ": k 1 2 3 add add . end ; define-function k" eval-string
   #+end_src
* define-variable
** note string allocation
   * string should be allocated to a static area
     instead of dynamic area like *circular-string-area*
     thus we have
     (syntax,double-quote,define-variable)
** syntax,double-quote,define-variable
   * in ASCII encode double-quote is 34
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,double-quote,define-variable,loop
     << cursor -- cursor >>
     read-byte
     dup 34 equal? if
       drop
       end
     then
     over save-byte
     add1
     loop
   ; define-function

   : syntax,double-quote,define-variable
     << word:double-quote -- string[address, length] >>
     drop2
     1024 2 mul allocate-local-memory >:buffer
     :buffer
     syntax,double-quote,define-variable,loop
     >:cursor
     *current-free-address,string-area* add2 >:address
     :buffer
     :cursor :buffer sub dup >:length
     save-into,string-area
     :address
     :length
     end
   ; define-function
   #+end_src
** define-variable
   #+begin_src cicada-nymph :tangle core.cn
   : define-variable
     << string[address, length] -- >>
     >::string
     ::string string-head,word >::variable-name
     ::string string-tail,word >::variable-body

     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     >:old-snapshot
     jo word:double-quote? jo syntax,double-quote,define-variable *rule-set,basic-REPL* add-rule
     ::variable-body eval-string
     jo word:double-quote? jo syntax,double-quote,define-variable *rule-set,basic-REPL* sub-rule

     snapshot-the-stack-pointer
     *the-stack-pointer-snapshot*
     >:new-snapshot

     :new-snapshot :old-snapshot sub

     dup negative? if
       negate *jo-size* div
       "* (define-variable) fail to define variable : " .s ::variable-name .s .l
       "  because after eval the following variable-body" .s .l
       "  the stack is " .s .i " below what it use to be" .s .l
       ::variable-body .s .l
       end
     then
     dup zero? if
       drop
       "* (define-variable) fail to define variable : " .s ::variable-name .s .l
       "  because after eval the following variable-body" .s .l
       "  the stack is still where it use to be" .s .l
       ::variable-body .s .l
       end
     then

     *jo-size* div >:variable-length

     :variable-length
       save-into,jojo-area

     *current-free-address,string-area*
       save-into,jojo-area
     ::variable-name
       save-into,string-area

     *first-jo,jo-link*
     jo->link
       save-into,jojo-area

     *current-free-address,jojo-area*
     dup jo,save-into,name-hash-table
     save-to *first-jo,jo-link*

     *explainer,variable*
       save-into,jojo-area

     *current-free-address,jojo-area*
     :variable-length
     n-save

     :variable-length *jo-size* mul
     address *current-free-address,jojo-area*
     add-save

     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : *numbers:define-variable*
     1 2 3
   ; define-variable
   *numbers:define-variable* . . .
   address *numbers:define-variable* fetch .

   : *string:define-variable*
     "define-variable"
   ; define-variable
   *string:define-variable* .s

   : kkk
     1 . 2 . 3 .
   ; define-variable

   1 2 3
   : kkk
     . . .
   ; define-variable
   #+end_src
* -----------------------------------
* constant for linux                  :linux:
** init-syscall-number                :32bit:
   #+begin_src cicada-nymph :tangle core.cn
   *jo-size* 4 equal? if
     5   : :syscall-number,open:       ; define-variable,with-tos
     6   : :syscall-number,close:      ; define-variable,with-tos
     3   : :syscall-number,read:       ; define-variable,with-tos
     4   : :syscall-number,write:      ; define-variable,with-tos
     9   : :syscall-number,link:       ; define-variable,with-tos
     10  : :syscall-number,unlink:     ; define-variable,with-tos
     39  : :syscall-number,mkdir:      ; define-variable,with-tos
     40  : :syscall-number,rmdir:      ; define-variable,with-tos
     141 : :syscall-number,getdents:   ; define-variable,with-tos
     220 : :syscall-number,getdents64: ; define-variable,with-tos
     106 : :syscall-number,stat:       ; define-variable,with-tos
     1   : :syscall-number,exit:       ; define-variable,with-tos
     43  : :syscall-number,times:      ; define-variable,with-tos
     20  : :syscall-number,getpid:     ; define-variable,with-tos
     183 : :syscall-number,getcwd:     ; define-variable,with-tos
     12  : :syscall-number,chdir:      ; define-variable,with-tos
   then
   #+end_src
** init-syscall-number                :64bit:
   #+begin_src cicada-nymph :tangle core.cn
   *jo-size* 8 equal? if
     2   : :syscall-number,open:       ; define-variable,with-tos
     3   : :syscall-number,close:      ; define-variable,with-tos
     0   : :syscall-number,read:       ; define-variable,with-tos
     1   : :syscall-number,write:      ; define-variable,with-tos
     86  : :syscall-number,link:       ; define-variable,with-tos
     87  : :syscall-number,unlink:     ; define-variable,with-tos
     83  : :syscall-number,mkdir:      ; define-variable,with-tos
     84  : :syscall-number,rmdir:      ; define-variable,with-tos
     78  : :syscall-number,getdents:   ; define-variable,with-tos
     217 : :syscall-number,getdents64: ; define-variable,with-tos
     4   : :syscall-number,stat:       ; define-variable,with-tos
     60  : :syscall-number,exit:       ; define-variable,with-tos
     100 : :syscall-number,times:      ; define-variable,with-tos
     39  : :syscall-number,getpid:     ; define-variable,with-tos
     79  : :syscall-number,getcwd:     ; define-variable,with-tos
     80  : :syscall-number,chdir:      ; define-variable,with-tos
   then
   #+end_src
** error-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : error-code->string
     << error-code -- string[address, length] >>
     dup -1  equal? if drop  << EPERM   >>   "Operation not permitted " end then
     dup -2  equal? if drop  << ENOENT  >>   "No such file or directory " end then
     dup -3  equal? if drop  << ESRCH   >>   "No such process " end then
     dup -4  equal? if drop  << EINTR   >>   "Interrupted system call " end then
     dup -5  equal? if drop  << EIO     >>   "I/O error " end then
     dup -6  equal? if drop  << ENXIO   >>   "No such device or address " end then
     dup -7  equal? if drop  << E2BIG   >>   "Argument list too long " end then
     dup -8  equal? if drop  << ENOEXEC >>   "Exec format error " end then
     dup -9  equal? if drop  << EBADF   >>   "Bad file number " end then
     dup -10 equal? if drop  << ECHILD  >>   "No child processes " end then
     dup -11 equal? if drop  << EAGAIN  >>   "Try again " end then
     dup -12 equal? if drop  << ENOMEM  >>   "Out of memory " end then
     dup -13 equal? if drop  << EACCES  >>   "Permission denied " end then
     dup -14 equal? if drop  << EFAULT  >>   "Bad address " end then
     dup -15 equal? if drop  << ENOTBLK >>   "Block device required " end then
     dup -16 equal? if drop  << EBUSY   >>   "Device or resource busy " end then
     dup -17 equal? if drop  << EEXIST  >>   "File exists " end then
     dup -18 equal? if drop  << EXDEV   >>   "Cross-device link " end then
     dup -19 equal? if drop  << ENODEV  >>   "No such device " end then
     dup -20 equal? if drop  << ENOTDIR >>   "Not a directory " end then
     dup -21 equal? if drop  << EISDIR  >>   "Is a directory " end then
     dup -22 equal? if drop  << EINVAL  >>   "Invalid argument " end then
     dup -23 equal? if drop  << ENFILE  >>   "File table overflow " end then
     dup -24 equal? if drop  << EMFILE  >>   "Too many open files " end then
     dup -25 equal? if drop  << ENOTTY  >>   "Not a typewriter " end then
     dup -26 equal? if drop  << ETXTBSY >>   "Text file busy " end then
     dup -27 equal? if drop  << EFBIG   >>   "File too large " end then
     dup -28 equal? if drop  << ENOSPC  >>   "No space left on device " end then
     dup -29 equal? if drop  << ESPIPE  >>   "Illegal seek " end then
     dup -30 equal? if drop  << EROFS   >>   "Read-only file system " end then
     dup -31 equal? if drop  << EMLINK  >>   "Too many links " end then
     dup -32 equal? if drop  << EPIPE   >>   "Broken pipe " end then
     dup -33 equal? if drop  << EDOM    >>   "Math argument out of domain of func " end then
     dup -34 equal? if drop  << ERANGE  >>   "Math result not representable " end then
     "unknow error-code : " .s .i .l
     "* (error-code->string) fail" << to balance the argument-stack >>
     end
   ; define-function
   #+end_src
** file-type-code->string
   #+begin_src cicada-nymph :tangle core.cn
   : file-type-code->string
     << file-type-code -- string[address, length] >>
     dup 1  equal?  << DT_FIFO  >>  if drop "named pipe i.e. FIFO"  end then
     dup 2  equal?  << DT_CHR   >>  if drop "character device"      end then
     dup 4  equal?  << DT_DIR   >>  if drop "directory"             end then
     dup 6  equal?  << DT_BLK   >>  if drop "block device"          end then
     dup 8  equal?  << DT_REG   >>  if drop "regular file"          end then
     dup 10 equal?  << DT_LNK   >>  if drop "symbolic link"         end then
     dup 12 equal?  << DT_SOCK  >>  if drop "UNIX domain socket"    end then
     drop
     "unknow file type"
     end
   ; define-function
   #+end_src
* -----------------------------------
* jo-link
** jo-link,list-by-jo-predicate
   * 最後寫到珠典裏的 被最先打印出來
   #+begin_src cicada-nymph :tangle core.cn
   : jo-link,list-by-jo-predicate,loop
     << jo-predicate, counter, jo -- total >>
     dup zero? if
       drop
       swap drop
       end
     then
     dup x|over|xxx execute-jo false? if
       jo->pre-jo
       loop
     then
     swap
       "  " .s
       add1 dup .i ". " .s
     swap
     dup jo->name
     dup2 space-string? if
       drop2
       "  unnamed" .s .l
     else
       .s .l
     then
     jo->pre-jo
     loop
   ; define-function

   : jo-link,list-by-jo-predicate
     << jo-predicate -- total >>
     0 *first-jo,jo-link*
     jo-link,list-by-jo-predicate,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,jo-link,list-by-jo-predicate
     << -- >>
     jo primitive-function-jo? jo-link,list-by-jo-predicate
     end
   ; define-function
   test,jo-link,list-by-jo-predicate
   #+end_src
** jo-link,report
   * different types of words in jo-link
     are showed separately
   #+begin_src cicada-nymph :tangle core.cn
   : jo-link,report
     << -- >>
     "* all primitive-function in jo-link :" .s .l
     jo primitive-function-jo?
     jo-link,list-by-jo-predicate
     "* all function in jo-link :" .s .l
     jo function-jo?
     jo-link,list-by-jo-predicate add
     "* all exception in jo-link :" .s .l
     jo exception-jo?
     jo-link,list-by-jo-predicate add
     "* all variable in jo-link :" .s .l
     jo variable-jo?
     jo-link,list-by-jo-predicate add
     "* totally : " .s
     .i .l
     end
   ; define-function
   #+end_src
* string
** n-string->buffer!
   * this function return length
   #+begin_src cicada-nymph :tangle core.cn
   : n-string->buffer!,loop
     << string-1[address, length],
        ...
        string-2[address, length],
        buffer, n, cursor
        -- length >>
     >:cursor
     >:n
     >:buffer
     :n zero? if
       :buffer
       :cursor :buffer sub
       string-reverse!
       swap drop
       end
     then
     dup zero? if
       drop2
       :buffer
       :n sub1
       :cursor
       loop
     then
     dup2 add sub1 fetch-byte :cursor save-byte
     sub1
     :buffer
     :n
     :cursor add1
     loop
   ; define-function

   : n-string->buffer!
     << string-1[address, length],
        ...
        string-2[address, length],
        buffer, n
        -- length >>
     over n-string->buffer!,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : *test,buffer*
     512 allocate-memory
   ; define-variable

   "/home" "/xyh" "/cicada"
   *test,buffer*
   3 n-string->buffer!
   *test,buffer* swap
   .s
   #+end_src
* -----------------------------------
* port
** note syscall with string arguments
   * for syscall the arguments in stack look like
     << ..., arg3, arg2, arg1 >>
     so
     for read(port, buffer, size)
     we need
     << size, buffer, port >>
     but the interface (port,read) in cicada-nymph is
     << buffer, size, port >>
     thus we need a swap here
     and
     we should be careful
     for other interface functions in cicada-nymph
** note linux header
   * 8 base number :
     O_ACCMODE          0003
     O_RDONLY             00
     O_WRONLY             01
     O_RDWR               02
     O_CREAT            0100  Not fcntl
     O_EXCL             0200  Not fcntl
     O_NOCTTY           0400  Not fcntl
     O_TRUNC           01000  Not fcntl
     O_APPEND          02000
     O_NONBLOCK        04000
     O_NDELAY     O_NONBLOCK
     O_SYNC         04010000
     O_FSYNC          O_SYNC
     O_ASYNC          020000
     O_LARGEFILE     0100000
     O_DIRECTORY     0200000
     O_NOFOLLOW      0400000
     O_CLOEXEC      02000000
     O_DIRECT         040000
     O_NOATIME      01000000
     O_PATH        010000000
     O_DSYNC          010000
     O_TMPFILE     020200000
** 記 關於輸入輸出
   * 接口設計分兩個層次
     1. 底層的以 port 爲基礎的接口
        這裏應該如何設計還不確定
        可能會模仿操作系統所提供的接口
     2. 高層的以 path 爲基礎的接口
        這裏將抽象掉 port 這個概念
        也就是每次簡單的讀寫都伴隨兩個對 port 的操作
        這樣接口就很簡單 但是速度可能會非常慢
** input-port,open
   #+begin_src cicada-nymph :tangle core.cn
   : input-port,open
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     2 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** output-port,[creat|update]
   * interface
     |--------+-----------------------|
     | creat  | fail if already exist |
     | update | fail if nor exist     |
     |--------+-----------------------|
   * one should always know if a file exist or not
     when open it as output-port
     predicates are provided to help you to do so
   #+begin_src cicada-nymph :tangle core.cn
   : output-port,creat
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1102 <<
     O_RDWR   0002
     O_CREAT  0100
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function

   : output-port,update
     << path[address, length]
        -- port, true
        -- error-code, false >>
     string->syscall-string
     >:syscall-path
     8#644 <<
     110100100b
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** port,close
   #+begin_src cicada-nymph :tangle core.cn
   : port,close
     << port
        -- true
        -- error-code, false >>
     :syscall-number,close:
     1 syscall
     dup
     negative? if
       false
       end
     then
     drop true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,output-port,creat
     << -- >>
     "kkk~" output-port,creat if
       port,close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,output-port,creat

   : test,output-port,update
     << -- >>
     "kkk~" output-port,update if
       port,close if
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,output-port,update
   #+end_src
** port,read
   #+begin_src cicada-nymph :tangle core.cn
   : port,read
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** port,write
   #+begin_src cicada-nymph :tangle core.cn
   : port,write
     << buffer, max-size, port
        -- counter, true
        -- error-code, false >>
     >:port
     swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       false
       end
     then
     true
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,port,read
     << -- >>
     64 allocate-local-memory
     dup
     "kkk~" input-port,open if
       64 swap port,read if
         .s .l
         end
       then error-code->string .s .l end
     then error-code->string .s .l end
   ; define-function
   test,port,read
   #+end_src
* file-tree
** note interface
   * file-tree
     two types of nodes
     1. file
     2. directory
     a leaf must be a file
   * the following interface is provided
     * they use path as an argument
     * they print error message on error
       instead of return error info
       or rise exception
     * the concept of port is
       completely removed from the interface
     --------------------------------
     * file
       1. file,creat
       2. file,write
       3. file,read
       4. file,remove
     * jo-link
       1. directory,creat
       2. directory,remove
       3. empty-directory?
     * list
       1. directory,list-file
       2. directory,list-directory
     * find
       1. directory,find-file
       2. directory,find-directory
** 記 錯誤處理
   * 兩種風格
     IO 相關的函數在出錯時
     1. 立即報錯
     2. 返回出錯信息
   * 第一種很簡單
     它假設了所有的錯誤都是不可忽略的
** 記 元數據
   * 訪問管理
     1. 誰有權訪問這個文件
     2. 他的權利是什麼
   * 文件類型
     [linux 沒有]
   * 文件大小
   * 文件使用註釋
     [linux 沒有]
** file,creat
   #+begin_src cicada-nymph :tangle core.cn
   : file,creat
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#0200
     8#0100 bit-or <<
     O_EXCL   0200
     O_CREAT  0100
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (file,creat) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     port,close if
       end
     then
     "* (file,creat) fail to close port for the following path :" .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** file,write
   #+begin_src cicada-nymph :tangle core.cn
   : file,write
     << string[address, length], path[address, length] -- >>
     >::path
     >::string
     ::path
     string->syscall-string
     >:syscall-path
     8#644 <<
     2#110100100
     >>
     8#1002 <<
     O_RDWR   0002
     O_TRUNC  1000
     >>
     :syscall-path
     :syscall-number,open:
     3 syscall
     dup
     negative? if
       "* (file,write) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     ::string swap
     :port
     :syscall-number,write:
     3 syscall
     dup
     negative? if
       "* (file,write) fail to write port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:counter << bytes been written >>
     :port
     port,close if
       end
     then
     "* (file,write) fail to close port for the following path : " .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** file,read
   #+begin_src cicada-nymph :tangle core.cn
   : file,read
     << string[address, max-length], path[address, length] -- counter >>
     >::path
     >::string
     ::path
     string->syscall-string
     >:syscall-path
     0 <<
     O_RDONLY
     >>
     :syscall-path
     :syscall-number,open:
     2 syscall
     dup
     negative? if
       "* (file,read) fail to open port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       0
       end
     then
     >:port
     ::string swap
     :port
     :syscall-number,read:
     3 syscall
     dup
     negative? if
       "* (file,read) fail to read port for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       0
       end
     then
     >:counter << bytes been readed >>
     :port
     port,close if
       :counter
       end
     then
     "* (file,read) fail to close port for the following path : " .s .l
     "  " .s ::path .s .l
     "  " .s error-code->string .s .l
     0
     end
   ; define-function
   #+end_src
** file,remove
   #+begin_src cicada-nymph :tangle core.cn
   : file,remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,unlink:
     1 syscall
     dup
     negative? if
       "* (file,remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,file,creat
     << -- >>
     "kkk~" file,creat
     "core" file,creat
     end
   ; define-function
   test,file,creat

   : test,file,write
     << -- >>
     "kkk~" file,creat
     "kkk took my baby away !!!" "kkk~" file,write
     end
   ; define-function
   test,file,write

   : test,file,read
     << -- >>
     "............................" >::string
     ::string "kkk~" file,read .i .l
     ::string .s
     end
   ; define-function
   test,file,read

   : test,file,remove
     << -- >>
     "kkk~" file,remove
     "play" file,remove
     end
   ; define-function
   test,file,remove
   #+end_src
** directory,creat
   #+begin_src cicada-nymph :tangle core.cn
   : directory,creat
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     8#755 <<
     2#111101101
     >>
     :syscall-path
     :syscall-number,mkdir:
     2 syscall
     dup
     negative? if
       "* (directory,creat) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** directory,remove
   #+begin_src cicada-nymph :tangle core.cn
   : directory,remove
     << path[address, length] -- >>
     >::path
     ::path
     string->syscall-string
     >:syscall-path
     :syscall-path
     :syscall-number,rmdir:
     1 syscall
     dup
     negative? if
       "* (directory,remove) fail for the following path :" .s .l
       "  " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,directory,creat
     << -- >>
     "play" directory,creat
     end
   ; define-function
   test,directory,creat

   : test,directory,remove
     << -- >>
     "play" directory,remove
     end
   ; define-function
   test,directory,remove
   #+end_src
** getdents64 structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +getdents64,d_ino+        ; define-variable,with-tos
   0 : +getdents64,d_off+        ; define-variable,with-tos
   0 : +getdents64,d_reclen+     ; define-variable,with-tos
   0 : +getdents64,d_type+       ; define-variable,with-tos
   0 : +getdents64,d_name+       ; define-variable,with-tos
   0 : +getdents64,end+          ; define-variable,with-tos

   : init,getdents64
     << offset -- >>
     *jo-size* 4 equal? if
       dup save-to +getdents64,d_ino+        8 add
       dup save-to +getdents64,d_off+        8 add
       dup save-to +getdents64,d_reclen+     2 add
       dup save-to +getdents64,d_type+       1 add
       dup save-to +getdents64,d_name+       256 add
           save-to +getdents64,end+
       end
     then
     *jo-size* 8 equal? if
       dup save-to +getdents64,d_ino+        8 add
       dup save-to +getdents64,d_off+        8 add
       dup save-to +getdents64,d_reclen+     2 add
       dup save-to +getdents64,d_type+       1 add
       dup save-to +getdents64,d_name+       256 add
           save-to +getdents64,end+
       end
     then
     end
   ; define-function

   0 init,getdents64
   +getdents64,end+ : +getdents64,length+ ; define-variable,with-tos
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,getdents64,print
     << -- >>
     "+getdents64,d_ino+ : "    .s +getdents64,d_ino+     fetch . .l
     "+getdents64,d_off+ : "    .s +getdents64,d_off+     fetch . .l
     "+getdents64,d_reclen+ : " .s +getdents64,d_reclen+  fetch-two-bytes . .l
     "+getdents64,d_type+ : "   .s
     +getdents64,d_type+
     fetch-byte file-type-code->string .s .l
     "+getdents64,d_name+ : "   .s
     +getdents64,d_name+
     dup 256
     0 string,find-char
     drop  << drop 0 >>
     over sub .s .l
     .l
     end
   ; define-function

   : test,getdents64,loop,structure
     << end, cursor -- >>
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     :cursor init,getdents64
     test,getdents64,print
     :cursor +getdents64,d_reclen+ fetch-two-bytes add
     loop
   ; define-function

   : test,getdents64,loop
     << port -- >>
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     "* syscall returns : " .s dup .i .l
     dup negative? if
       error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     test,getdents64,loop,structure
     :port
     loop
   ; define-function

   : test,getdents64
     << path[address, length] -- >>
     >::path
     ::path input-port,open if
     else
       "* (test,getdents64) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port test,getdents64,loop
     :port port,close if
       end
     then
     "* (test,getdents64) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function

   "play" test,getdents64
   "play/kkk" test,getdents64
   "." test,getdents64
   "/" test,getdents64
   #+end_src
** empty-directory?
   #+begin_src cicada-nymph :tangle core.cn
   : empty-directory?
     << path[address, length] -- bool >>
     >::path
     ::path input-port,open if
     else
       "* (empty-directory?) fail to open : " .s ::path .s .l
       "  " .s error-code->string .s .l
       false
       end
     then
     >:port
     128 allocate-local-memory >:getdents64-structure-list
     128
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     48 equal? << this call to equal? returns the needed bool >>
     :port port,close if
       end
     then
     "* (empty-directory?) fail to close : " .s ::path .s .l
     "  " .s error-code->string .s .l
     false
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "play" empty-directory? . .l
   "play/kkk" empty-directory? . .l
   "play/aaa" empty-directory? . .l
   "." empty-directory? . .l
   "/" empty-directory? . .l
   #+end_src
** directory,map
   #+begin_src cicada-nymph :tangle core.cn
   : directory,map,loop,execute
     << end, cursor, function -- >>
     >:function
     dup2 less-or-equal? if
       drop2
       end
     then
     >:cursor
     >:end
     :cursor init,getdents64
     :function execute-jo
     :end
     :cursor +getdents64,d_reclen+ fetch-two-bytes add
     :function
     loop
   ; define-function

   : directory,map,loop
     << port, function -- >>
     >:function
     >:port
     1024 allocate-local-memory >:getdents64-structure-list
     1024
     :getdents64-structure-list
     :port
     :syscall-number,getdents64:
     3 syscall
     dup negative? if
       "* (directory,map,loop) syscall fail" .s .l
       "  " .s error-code->string .s .l
       end
     then
     dup zero? if
       drop
       end
     then
     :getdents64-structure-list add
     :getdents64-structure-list
     :function
     directory,map,loop,execute
     :port
     :function
     loop
   ; define-function

   : directory,map
     << directory-path[address, length],
        function
        -- true
        -- false >>
     >:function
     >::directory-path
     ::directory-path input-port,open if
     else
       "* (directory,map) fail to open : " .s ::directory-path .s .l
       "  " .s error-code->string .s .l
       end
     then
     >:port
     :port :function directory,map,loop
     :port port,close if
       end
     then
     "* (directory,map) fail to close : " .s ::directory-path .s .l
     "  " .s error-code->string .s .l
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,function
     << -- >>
     +getdents64,d_type+ fetch-byte
     8 equal? if
       "  " .s
       +getdents64,d_name+
       dup 256
       0 string,find-char
       drop  << drop 0 >>
       over sub .s .l
     then
     end
   ; define-function

   : test,directory,map
     << -- >>
     "play" jo test,function directory,map
     end
   ; define-function
   test,directory,map
   #+end_src
** directory,list-file
   #+begin_src cicada-nymph :tangle core.cn
   : directory,list-file,lister
     << -- >>
     +getdents64,d_type+ fetch-byte
     8 equal? if
       "  " .s
       +getdents64,d_name+
       dup 256
       0 string,find-char
       drop  << drop 0 >>
       over sub .s .l
     then
     end
   ; define-function

   : directory,list-file
     << directory-path[address, length] -- >>
     jo directory,list-file,lister
     directory,map
     end
   ; define-function
   #+end_src
** directory,list-directory
   #+begin_src cicada-nymph :tangle core.cn
   : directory,list-directory,lister
     << -- >>
     +getdents64,d_type+ fetch-byte
     4 equal? if
       +getdents64,d_name+
       dup 256
       0 string,find-char
       drop  << drop 0 >>
       over sub >::name
       ".." ::name string-equal? if
         end
       then
       "." ::name string-equal? if
         end
       then
       "  " .s ::name .s .l
       end
     then
     end
   ; define-function

   : directory,list-directory
     << directory-path[address, length] -- >>
     jo directory,list-directory,lister
     directory,map
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "play" dup2
   directory,list-file
   directory,list-directory

   "play/kkk" dup2
   directory,list-file
   directory,list-directory

   "." dup2
   directory,list-file
   directory,list-directory

   "/" dup2
   directory,list-file
   directory,list-directory
   #+end_src
** directory,find-file
   #+begin_src cicada-nymph :tangle core.cn
   : directory,find-file,finder
     << file-name[address, length], bool --
        file-name[address, length], bool >>
     +getdents64,d_type+ fetch-byte 8 equal? not if
       end
     then
     >:bool
     >:file-name,lenght
     >:file-name,address
     :file-name,lenght +getdents64,d_name+ add
     fetch-byte zero? not if
       :file-name,address
       :file-name,lenght
       :bool
       end
     then
     :file-name,address :file-name,lenght
     +getdents64,d_name+ :file-name,lenght
     string-equal? if
       :file-name,address
       :file-name,lenght
       true
       end
     then
     :file-name,address
     :file-name,lenght
     :bool
     end
   ; define-function

   : directory,find-file
     << directory-path[address, length], file-name[address, length] -- bool >>
     xx|swap|xx
     false
     xx|swap|x
     jo directory,find-file,finder
     directory,map
     xx|swap|x drop2
     end
   ; define-function
   #+end_src
** directory,find-directory
   #+begin_src cicada-nymph :tangle core.cn
   : directory,find-directory,finder
     << file-name[address, length], bool --
        file-name[address, length], bool >>
     +getdents64,d_type+ fetch-byte 4 equal? not if
       end
     then
     >:bool
     >:file-name,lenght
     >:file-name,address
     :file-name,lenght +getdents64,d_name+ add
     fetch-byte zero? not if
       :file-name,address
       :file-name,lenght
       :bool
       end
     then
     :file-name,address :file-name,lenght
     +getdents64,d_name+ :file-name,lenght
     string-equal? if
       :file-name,address
       :file-name,lenght
       true
       end
     then
     :file-name,address
     :file-name,lenght
     :bool
     end
   ; define-function

   : directory,find-directory
     << directory-path[address, length], file-name[address, length] -- bool >>
     xx|swap|xx
     false
     xx|swap|x
     jo directory,find-directory,finder
     directory,map
     xx|swap|x drop2
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,directory,find-file
     << -- >>
     "play" "cn" directory,find-file .
     "play" "kkk" directory,find-file .
     "play" "no" directory,find-file .
     .l
     "playlay" "no" directory,find-file .
     .l
     end
   ; define-function
   test,directory,find-file

   : test,directory,find-directory
     << -- >>
     "play" "cn" directory,find-directory .
     "play" "kkk" directory,find-directory .
     "play" "no" directory,find-directory .
     .l
     "playlay" "no" directory,find-directory .
     .l
     end
   ; define-function
   test,directory,find-directory
   #+end_src
* system environment                  :linux:
** note one directory
   * all files about cicada
     are stored in
     "/home/<user>/.cicada"
** note linux system environment
   * pid is the key to all the linux system environment
   * command-line
     /proc/<pid>/cmdline
   * environment-variable-list
     /proc/<pid>/environ
** [init|get]-pid
   #+begin_src cicada-nymph :tangle core.cn
   0 : *pid* ; define-variable,with-tos

   : init-pid
     << -- >>
     :syscall-number,getpid:
     0 syscall
     save-to *pid*
     end
   ; define-function

   : get-pid
     << -- pid >>
     *pid*
     end
   ; define-function
   #+end_src
** [init|get]-command-line
   #+begin_src cicada-nymph :tangle core.cn
   512 allocate-memory
   : *address,command-line*
   ; define-variable,with-tos

   512
   : *length,command-line*
   ; define-variable,with-tos

   : init-command-line
     << -- >>
     64 allocate-local-memory >:path-buffer
     :path-buffer >:cursor

     get-pid write-number,fill-buffer >::pid-string

     "/proc/" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     ::pid-string dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     "/cmdline" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     :path-buffer
     :cursor :path-buffer sub dup2 >::path
     input-port,open if
     else
       "* (init-command-line) fail to open : " .s ::path .s .l
       end
     then
     >:port

     *address,command-line*
     *length,command-line*
     :port
     port,read if
     else
       "* (init-command-line) fail to read : " .s ::path .s .l
       end
     then
     save-to *length,command-line*
     end
   ; define-function

   : get-command-line
     << -- string[address, length] >>
     *address,command-line* *length,command-line*
     end
   ; define-function
   #+end_src
** [init|get]-environment-variable-list
   * the size of /proc/<pid>/environ is limited to 4k
   #+begin_src cicada-nymph :tangle core.cn
   1024 4 mul allocate-memory
   : *address,environment-variable-list*
   ; define-variable,with-tos

   1024 4 mul
   : *length,environment-variable-list*
   ; define-variable,with-tos

   : init-environment-variable-list
     << -- >>
     64 allocate-local-memory >:path-buffer
     :path-buffer >:cursor

     get-pid write-number,fill-buffer >::pid-string

     "/proc/" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     ::pid-string dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     "/environ" dup >:add-to-cursor
     :cursor string->buffer!
     :add-to-cursor :cursor add >:cursor

     :path-buffer
     :cursor :path-buffer sub dup2 >::path
     input-port,open if
     else
       "* (init-environment-variable-list) fail to open : " .s ::path .s .l
       end
     then
     >:port

     *address,environment-variable-list*
     *length,environment-variable-list*
     :port
     port,read if
     else
       "* (init-environment-variable-list) fail to read : " .s ::path .s .l
       end
     then
     save-to *length,environment-variable-list*
     end
   ; define-function

   : get-environment-variable-list
     << -- string[address, length] >>
     *address,environment-variable-list*
     *length,environment-variable-list*
     end
   ; define-function
   #+end_src
** find-environment-variable
   * the string used to find an environment-variable
     can not contain "="
     no error handling on this
   #+begin_src cicada-nymph :tangle core.cn
   : find-environment-variable,loop
     << string[address, length], cursor
        -- string[address, length], true
        -- false >>
     dup
     get-environment-variable-list add
     greater-than? if
       drop drop2
       false
       end
     then
     >:cursor
     >:length
     >:address
     :address :cursor :length
     compare-buffer not if
       :address :length
       :cursor 0 cursor->next-matching-byte add1
       loop
     then
     :cursor :length add fetch-byte
     "=" string-head,byte
     equal? not if
       :address :length
       :cursor 0 cursor->next-matching-byte add1
       loop
     then
     :cursor :length add add1 << over "=" >>
     >:find-address
     :find-address 0 cursor->next-matching-byte
     :find-address sub >:find-length
     :find-address
     :find-length
     end
   ; define-function

   : find-environment-variable
     << string[address, length]
        -- string[address, length], true
        -- false >>
     get-environment-variable-list drop
     find-environment-variable,loop
     end
   ; define-function
   #+end_src
** initialize system environment
   #+begin_src cicada-nymph :tangle core.cn
   init-pid
   init-command-line
   init-environment-variable-list
   #+end_src
** *home-directory*
   #+begin_src cicada-nymph :tangle core.cn
   : *home-directory*
     "HOME" find-environment-variable
   ; define-variable
   #+end_src
** report-environment-variable
   #+begin_src cicada-nymph :tangle core.cn
   : report-environment-variable,loop
     << environment-variable-list[address, length]-- >>
     dup2 space-string? if
       drop2
       end
     then

     >:length
     >:address

     :address :length 0 string,find-char drop add1 >:cursor
     :cursor :address sub >:length-of-one-variable

     :address
     :length-of-one-variable sub1 .s .l

     :cursor
     :length :length-of-one-variable sub
     loop
   ; define-function

   : report-environment-variable
     << -- >>
     get-environment-variable-list
     report-environment-variable,loop
     end
   ; define-function
   #+end_src
** report-command-line
   #+begin_src cicada-nymph :tangle core.cn
   : report-command-line,loop
     << command-line[address, length] -- >>
     dup2 space-string? if
       drop2
       end
     then
     dup2 string-head,word .s 32 .b
     string-tail,word
     loop
   ; define-function

   : report-command-line
     << -- >>
     get-command-line
     report-command-line,loop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   report-environment-variable
   report-command-line
   #+end_src
* work-directory
** get-work-directory
   #+begin_src cicada-nymph :tangle core.cn
   512 allocate-memory
   : *buffer,work-directory*
   ; define-variable,with-tos

   : get-work-directory
     << -- directory[address, length] >>
     512
     *buffer,work-directory*
     :syscall-number,getcwd:
     2 syscall
     dup negative? if
       "* (get-work-directory) fail" .s .l
       "  " .s error-code->string .s .l
       end
     then
     *buffer,work-directory*
     swap
     sub1 << for the ending zero >>
     end
   ; define-function
   #+end_src
** change-work-directory
   #+begin_src cicada-nymph :tangle core.cn
   : change-work-directory
     << directory-path[address, length] -- >>
     >::directory-path
     ::directory-path
     string->syscall-string
     :syscall-number,chdir:
     1 syscall
     dup negative? if
       "* (change-work-directory) fail" .s .l
       "  can not change the work directory into : " .s ::directory-path .s .l
       "  " .s error-code->string .s .l
       end
     then
     drop
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   get-work-directory .s
   "/home" change-work-directory
   get-work-directory .s
   "/////home/xyh////cicada/play" change-work-directory
   get-work-directory .s
   "//././/home/xyh/././cicada/./" change-work-directory
   get-work-directory .s
   #+end_src
* path
** stat structure
   #+begin_src cicada-nymph :tangle core.cn
   0 : +stat,st_dev+        ; define-variable,with-tos
   0 : +stat,st_ino+        ; define-variable,with-tos
   0 : +stat,st_mode+       ; define-variable,with-tos
   0 : +stat,st_nlink+      ; define-variable,with-tos
   0 : +stat,st_uid+        ; define-variable,with-tos
   0 : +stat,st_gid+        ; define-variable,with-tos
   0 : +stat,st_rdev+       ; define-variable,with-tos
   0 : +stat,st_size+       ; define-variable,with-tos
   0 : +stat,st_blksize+    ; define-variable,with-tos
   0 : +stat,st_blocks+     ; define-variable,with-tos
   0 : +stat,st_atime+      ; define-variable,with-tos
   0 : +stat,st_atime_nsec+ ; define-variable,with-tos
   0 : +stat,st_mtime+      ; define-variable,with-tos
   0 : +stat,st_mtime_nsec+ ; define-variable,with-tos
   0 : +stat,st_ctime+      ; define-variable,with-tos
   0 : +stat,st_ctime_nsec+ ; define-variable,with-tos
   0 : +stat,__unused4+     ; define-variable,with-tos
   0 : +stat,__unused5+     ; define-variable,with-tos
   0 : +stat,end+           ; define-variable,with-tos

   : init,stat
     << offset -- >>
     *jo-size* 4 equal? if
       dup save-to +stat,st_dev+         *jo-size* add
       dup save-to +stat,st_ino+         *jo-size* add
       dup save-to +stat,st_mode+        2 add
       dup save-to +stat,st_nlink+       2 add
       dup save-to +stat,st_uid+         2 add
       dup save-to +stat,st_gid+         2 add
       dup save-to +stat,st_rdev+        *jo-size* add
       dup save-to +stat,st_size+        *jo-size* add
       dup save-to +stat,st_blksize+     *jo-size* add
       dup save-to +stat,st_blocks+      *jo-size* add
       dup save-to +stat,st_atime+       *jo-size* add
       dup save-to +stat,st_atime_nsec+  *jo-size* add
       dup save-to +stat,st_mtime+       *jo-size* add
       dup save-to +stat,st_mtime_nsec+  *jo-size* add
       dup save-to +stat,st_ctime+       *jo-size* add
       dup save-to +stat,st_ctime_nsec+  *jo-size* add
       dup save-to +stat,__unused4+      *jo-size* add
       dup save-to +stat,__unused5+      *jo-size* add
           save-to +stat,end+
       end
     then
     *jo-size* 8 equal? if
       dup save-to +stat,st_dev+         *jo-size* add
       dup save-to +stat,st_ino+         *jo-size* add
       <<
       note the following order changing
       this is linux' bad
       >>
       dup save-to +stat,st_nlink+       8 add
       dup save-to +stat,st_mode+        4 add

       dup save-to +stat,st_uid+         4 add
       dup save-to +stat,st_gid+         4 add
                                             4 add << padding >>
       dup save-to +stat,st_rdev+        *jo-size* add
       dup save-to +stat,st_size+        *jo-size* add
       dup save-to +stat,st_blksize+     *jo-size* add
       dup save-to +stat,st_blocks+      *jo-size* add
       dup save-to +stat,st_atime+       *jo-size* add
       dup save-to +stat,st_atime_nsec+  *jo-size* add
       dup save-to +stat,st_mtime+       *jo-size* add
       dup save-to +stat,st_mtime_nsec+  *jo-size* add
       dup save-to +stat,st_ctime+       *jo-size* add
       dup save-to +stat,st_ctime_nsec+  *jo-size* add
       dup save-to +stat,__unused4+      *jo-size* add
       dup save-to +stat,__unused5+      *jo-size* add
           save-to +stat,end+
       end
     then
     end
   ; define-function

   0 init,stat
   +stat,end+ : +stat,length+ ; define-variable,with-tos
   #+end_src
** test
   #+begin_src cicada-nymph
   : test,stat
     << path[address, length] -- >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       dup .
       error-code->string .s .l
       end
     then
     drop
     :stat-structure init,stat
     "+stat,st_dev+ : " .s +stat,st_dev+        fetch . .l
     "+stat,st_ino+ : " .s +stat,st_ino+        fetch . .l
     *jo-size* 4 equal? if
     "+stat,st_mode+ : " .s +stat,st_mode+       fetch-two-bytes  . .l
     "+stat,st_nlink+ : " .s +stat,st_nlink+      fetch-two-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        fetch-two-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        fetch-two-bytes  . .l
     then
     *jo-size* 8 equal? if
     "+stat,st_nlink+ : " .s +stat,st_nlink+      fetch  . .l
     "+stat,st_mode+ : " .s +stat,st_mode+       fetch-four-bytes  . .l
     "+stat,st_uid+ : " .s +stat,st_uid+        fetch-four-bytes  . .l
     "+stat,st_gid+ : " .s +stat,st_gid+        fetch-four-bytes  . .l
     then
     "+stat,st_rdev+ : " .s +stat,st_rdev+       fetch . .l
     "+stat,st_size+ : " .s +stat,st_size+       fetch . .l
     "+stat,st_blksize+ : " .s +stat,st_blksize+    fetch . .l
     "+stat,st_blocks+ : " .s +stat,st_blocks+     fetch . .l
     "+stat,st_atime+ : " .s +stat,st_atime+      fetch . .l
     "+stat,st_atime_nsec+ : " .s +stat,st_atime_nsec+ fetch . .l
     "+stat,st_mtime+ : " .s +stat,st_mtime+      fetch . .l
     "+stat,st_mtime_nsec+ : " .s +stat,st_mtime_nsec+ fetch . .l
     "+stat,st_ctime+ : " .s +stat,st_ctime+      fetch . .l
     "+stat,st_ctime_nsec+ : " .s +stat,st_ctime_nsec+ fetch . .l
     "+stat,__unused4+ : " .s +stat,__unused4+     fetch . .l
     "+stat,__unused5+ : " .s +stat,__unused5+     fetch . .l
     end
   ; define-function

   "cn" test,stat
   "no" test,stat
   #+end_src
** note predicate
   * to use predicate to know more about the file-tree
     before calling a function that makes action on the file-tree
** path,nothing?
   #+begin_src cicada-nymph :tangle core.cn
   : path,nothing?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     -2 equal?
     end
   ; define-function
   #+end_src
** path,file?
   #+begin_src cicada-nymph :tangle core.cn
   : path,file?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       fetch-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       fetch-four-bytes
     then
     12 bit-right
     8#0010
     equal?
     <<
     0170000
     S_IFDIR       0040000 /* Directory.  */
     S_IFCHR       0020000 /* Character device.  */
     S_IFBLK       0060000 /* Block device.  */
     S_IFREG       0100000 /* Regular file.  */
     S_IFIFO       0010000 /* FIFO.  */
     S_IFLNK       0120000 /* Symbolic link.  */
     S_IFSOCK      0140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** path,directory?
   #+begin_src cicada-nymph :tangle core.cn
   : path,directory?
     << path[address, length] -- bool >>
     string->syscall-string
     >:syscall-path
     +stat,length+ allocate-local-memory
     >:stat-structure
     :stat-structure
     :syscall-path
     :syscall-number,stat:
     2 syscall
     dup
     negative? if
       drop
       false
       end
     then
     drop
     :stat-structure init,stat
     *jo-size* 4 equal? if
       +stat,st_mode+
       fetch-two-bytes
     then
     *jo-size* 8 equal? if
       +stat,st_mode+
       fetch-four-bytes
     then
     12 bit-right
     8#0004
     equal?
     <<
     0170000
     S_IFDIR       00040000 /* Directory.  */
     S_IFCHR       00020000 /* Character device.  */
     S_IFBLK       00060000 /* Block device.  */
     S_IFREG       00100000 /* Regular file.  */
     S_IFIFO       00010000 /* FIFO.  */
     S_IFLNK       00120000 /* Symbolic link.  */
     S_IFSOCK      00140000 /* Socket.  */
     >>
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "cn" path,nothing? . << 0 >>
   "core" path,nothing? . << 0 >>
   "ai" path,nothing? . << 1 >>

   "cn" path,file? . << 1 >>
   "core" path,file? . << 0 >>
   "ai" path,file? . << 0 >>

   "cn" path,directory? . << 0 >>
   "core" path,directory? . << 1 >>
   "ai" path,directory? . << 0 >>
   #+end_src
** 記 字符串的謂詞
   * 下面這兩個函數
     其實是在用遞歸函數實現正則表達式對字符串的匹配效果
   * 是否應該設計 正則表達式 子語言 ?
     還是總是直接使用遞歸函數 ?
** 記 unix 路徑格式
   * "/" 相當於 空格
     連續的 "//" 相當於 連續的空格
     這種空格使用在字符串開頭時 代表這是一個 絕對路徑
   * "." 相當於 空格
     連續的 ".." 不算 連續的空格 有別的語義
     但是在這種空格使用在最前面的時候 標誌這個
     這種空格使用在字符串開頭時 代表這是一個 相對路徑
   * 而對於下面的兩個函數我簡單地要求
     1. relative-path
        不以 "/" 開頭 的字符串
     2. full-path
        以 "/" 開頭 的字符串
     3. 並且在這裏我允許 path 內 出現空格
        保留對這種路徑的處理能力
        只不過 我不使用這種路徑而已
** relative-path?
   * in ASCII "/" is 47
   #+begin_src cicada-nymph :tangle core.cn
   : relative-path?
     << string[address, length] -- bool >>
     dup zero? if
       drop2
       false
       end
     then
     string-head,byte
     47 equal? not
     end
   ; define-function
   #+end_src
** full-path?
   * in ASCII "/" is 47
   #+begin_src cicada-nymph :tangle core.cn
   : full-path?
     << string[address, length] -- bool >>
     dup zero? if
       drop2
       false
       end
     then
     string-head,byte
     47 equal?
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "/home" relative-path? .
   "/home" full-path? .
   "home" relative-path? .
   "home" full-path? .
   #+end_src
* poi
** note
   * poi denotes path-organizer
     it can give a name to a path
     one path one name
   * a path as a string must not contain any space chars
   * a name should only consist of number or letter or "-"
** *poi-directory*
   * one directory to store the name path record
     "/home/<user>/.cicada/poi"
   #+begin_src cicada-nymph :tangle core.cn
   : *poi-directory,user,address*
     512 allocate-memory
   ; define-variable

   : *poi-directory*
     *home-directory* "/.cicada/poi"
     *poi-directory,user,address*
     2 n-string->buffer!
     *poi-directory,user,address* swap
   ; define-variable
   #+end_src
** poi,find
   * note that
     this function uses *circular-string-area*
   #+begin_src cicada-nymph :tangle core.cn
   : poi,find
     << name[address, length]
        -- path[address, length], true
        -- false >>
     >::name
     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     :buffer :length
     path,file? not if
       false
       end
     then

     512 allocate-local-memory >:read-buffer
     :read-buffer 512
     :buffer :length
     file,read >:read-length

     *current-free-address,circular-string-area*
     >:path-address

     :read-buffer :read-length
     save-into,circular-string-area

     :path-address
     :read-length
     true
     end
   ; define-function
   #+end_src
** poi,add
   #+begin_src cicada-nymph :tangle core.cn
   : poi,add
     << name[address, length], relative-path[address, length] -- >>
     >::relative-path
     >::name

     ::relative-path relative-path? not if
       "* (poi,add) the argument must be a relative-path" .s .l
       "  but the following is not : " .s ::relative-path .s .l
       end
     then

     ::relative-path path,directory? not if
       "* (poi,add) the argument must be a relative-path to a existing directory" .s .l
       "  but the following path is not to a directory : " .s ::relative-path .s .l
       end
     then

     ::name poi,find if
       "* (poi,add) can not add" .s .l
       "  for the following poi already exist : " .s ::name .s .l
       "  name is use as the following directory's name : " .s .s .l
       end
     then

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name
     :buffer
     3 n-string->buffer!
     >:length
     :buffer :length
     directory,creat

     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer!
     >:length
     :buffer :length
     file,creat

     512 allocate-local-memory >:address,full-path
     get-work-directory "/" ::relative-path
     :address,full-path
     3 n-string->buffer! >:length,full-path

     :address,full-path :length,full-path
     :buffer :length
     file,write
     end
   ; define-function
   #+end_src
** poi,sub
   #+begin_src cicada-nymph :tangle core.cn
   : poi,sub
     << name[address, length] -- >>
     >::name

     ::name poi,find not if
       "* (poi,sub) can not sub" .s .l
       "  for the following poi does not exist : " .s ::name .s .l
       end
     then
     >::named-directory

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     :buffer :length
     file,remove

     *poi-directory* "/" ::name
     :buffer
     3 n-string->buffer!
     >:length
     :buffer :length
     directory,remove
     end
   ; define-function
   #+end_src
** poi,up
   #+begin_src cicada-nymph :tangle core.cn
   : poi,up
     << name[address, length], relative-path[address, length] -- >>
     >::relative-path
     >::name

     ::relative-path relative-path? not if
       "* (poi,up) the argument must be a relative-path" .s .l
       "  but the following is not : " .s ::relative-path .s .l
       end
     then

     ::relative-path path,directory? not if
       "* (poi,up) the argument must be a relative-path to a existing directory" .s .l
       "  but the following directory is not exist : " .s ::relative-path .s .l
       end
     then

     ::name poi,find not if
       "* (poi,up) can not up" .s .l
       "  for the following poi does not exist : " .s ::name .s .l
       end
     then
     >::named-directory

     512 allocate-local-memory >:buffer
     *poi-directory* "/" ::name "/path"
     :buffer
     4 n-string->buffer! >:length

     512 allocate-local-memory >:address,full-path
     get-work-directory "/" ::relative-path
     :address,full-path
     3 n-string->buffer! >:length,full-path

     :address,full-path :length,full-path
     :buffer :length
     file,write
     end
   ; define-function
   #+end_src
** poi,list
   #+begin_src cicada-nymph :tangle core.cn
   : poi,list,lister
     << -- >>
     +getdents64,d_type+ fetch-byte
     4 equal? if
       512 allocate-local-memory >:path-buffer
       +getdents64,d_name+
       dup 256
       0 string,find-char
       drop  << drop 0 >>
       over sub >::name

       ".." ::name string-equal? if
         end
       then

       "." ::name string-equal? if
         end
       then

       "  * " .s ::name .s .l
       "      " .s

       *poi-directory* "/" ::name "/path"
       :path-buffer
       4 n-string->buffer! >:path-length

       512 allocate-local-memory >:reading-buffer
       :reading-buffer 512
       :path-buffer :path-length
       file,read >:reading-length

       :reading-buffer :reading-length
       .s .l
     then
     end
   ; define-function

   : poi,list
     << -- >>
     *poi-directory*
     jo poi,list,lister
     directory,map
     end
   ; define-function
   #+end_src
** poi,help
   #+begin_src cicada-nymph :tangle core.cn
   : poi,help
     << -- >>
     "* (poi,help)" .s .l
     "  * cn poi add  <new-name> <relative-path-to-existing-directory>" .s .l
     "  * cn poi sub  <old-name>" .s .l
     "  * cn poi up   <old-name> <relative-path-to-existing-directory>" .s .l
     "  * cn poi find <old-name>" .s .l
     "  * cn poi list" .s .l
     end
   ; define-function
   #+end_src
** +name+?
   #+begin_src cicada-nymph :tangle core.cn
   : +name+?
     << string[address, length] -- bool >>
     dup 1 less-or-equal? if
       drop2
       false
       end
     then
     over fetch-byte
     "+" string-head,byte equal? not if
       drop2
       false
       end
     then
     add sub1 fetch-byte
     "+" string-head,byte equal?
     end
   ; define-function
   #+end_src
** +name+->name
   #+begin_src cicada-nymph :tangle core.cn
   : +name+->name
     << +name+[address, length] -- name[address, length] >>
     sub2 swap
     add1 swap
     end
   ; define-function
   #+end_src
** test
   #+begin_src cicada-nymph
   "test-cicada-play" "./play" poi,add
   "test-cicada-play" poi,find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play-2" "./play-2" poi,add
   "test-cicada-play-2" poi,find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play" "./contribution" poi,up
   "test-cicada-play" poi,find
   if .s .l
   else "not found" .s .l
   then

   "test-cicada-play" poi,sub
   "test-cicada-play" poi,find
   if .s .l
   else "not found" .s .l
   then

   poi,list

   poi,help

   "+work+" +name+? .
   "work" +name+? .
   #+end_src
* path syntax
** note
   * path syntax can be implemented by a new *rule-set*
     but in the following
     I just simply implemented it
     as a rule in *rule-set,basic-REPL*
** note format
   #+begin_src cicada-nymph
   <<
   the following 4 poi are built in
   +root+
   +home+
   +work+
   +back+
   >>

   path: +root+ home xyh cicada core core.cn ;
   path: +home+ cicada core core.cn ;
   "/home/xyh/cicada/core/core.cn"

   path: +back+ cicada core core.cn ;
   "../cicada/core/core.cn"

   path: +work+ core core.cn ;
   path: core core.cn ;


   path: +library+ hi.cn ;
   "/home/xyh/cicada/library/hi.cn"
   #+end_src
** word:path:?
   #+begin_src cicada-nymph :tangle core.cn
   : word:path:?
     << word[address, length] -- bool >>
     "path:" string-equal?
     end
   ; define-function
   #+end_src
** !bad-path-syntax-word
   #+begin_src cicada-nymph :tangle core.cn
   : bad-path-syntax-word,loop
     << -- >>
     read-word-for-REPL
     dup2 ";" string-equal? if
       .s 32 .b
       end
     then
     .s 32 .b
     loop
   ; define-function

   : !bad-path-syntax-word
     << word -- >>
     "* (!bad-path-syntax-word) the following word is of bad syntax : " .s .l
     "    " .s .s .l
     exception-reset-stack
     << -- >>
     "  the rest of the words in path syntax is as following :" .s .l
     "    " .s bad-path-syntax-word,loop .l
     end
   ; define-exception
   #+end_src
** path-syntax-word->path
   #+begin_src cicada-nymph :tangle core.cn
   : path-syntax-word->path
     << word[address, length] -- path[address, length] >>
     >::word
     ::word "+root+" string-equal? if
       "/"
       end
     then
     ::word "+work+" string-equal? if
       get-work-directory
       end
     then
     ::word "+home+" string-equal? if
       *home-directory*
       end
     then
     ::word "+back+" string-equal? if
       ".."
       end
     then
     ::word +name+? not if
       ::word
       end
     then
     ::word +name+->name poi,find if
       end
     then
     ::word
     !bad-path-syntax-word
   ; define-function
   #+end_src
** syntax,path:,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : syntax,path:,basic-REPL,loop
     << cursor -- cursor >>
     >:cursor
     read-word-for-REPL >::word

     ";" ::word string-equal? if
       :cursor
       end
     then

     ::word path-syntax-word->path dup >:length
     :cursor
     string->buffer!

     :cursor :length add
       dup
       "/" string-head,byte
       swap
       save-byte
     add1
     loop
   ; define-function

   : syntax,path:,basic-REPL
     << word:path: -- path[address, length] >>
     drop2

     prepare-for
       !bad-path-syntax-word
       end

     512 allocate-local-memory >:buffer
     :buffer syntax,path:,basic-REPL,loop >:cursor

     :cursor :buffer sub >:length

     *current-free-address,circular-string-area*
     >:address

     :buffer
     :length
     save-into,circular-string-area

     :address
     :length
     end
   ; define-function
   #+end_src
** add-rule to *rule-set,basic-REPL*
   #+begin_src cicada-nymph :tangle core.cn
   jo word:path:?
   jo syntax,path:,basic-REPL
   *rule-set,basic-REPL* add-rule
   #+end_src
** test
   #+begin_src cicada-nymph
   path: +root+ home xyh cicada core core.cn ; .s
   path: +home+ cicada core core.cn ; .s

   path: +back+ cicada core core.cn ; .s

   path: +work+ core core.cn ; .s
   path: core core.cn ; .s

   "library" "library" poi,add
   path: +library+ hi.cn ; .s
   "library" poi,sub
   path: +library+ hi.cn ;
   #+end_src
* load & need
** note usage
   * no library code will be auto loaded
     you need to configure path by (poi)
     then load the code you want by using path-syntax
** note loading-stack
   * by a loading-stack
     (load) is able to maintain a list of loaded files
     also be able to un-load code by the loading-order
** load
   #+begin_src cicada-nymph
   : load
     << path[address, length] -- >>

     end
   ; define-function
   #+end_src
** need
   * (need) is as (load-when-not-loaded)
   #+begin_src cicada-nymph

   #+end_src
* -----------------------------------
* report
** report-memory
   #+begin_src cicada-nymph :tangle core.cn
   : report-memory
     << -- >>
     "* *un-initialized-memory*" .s .l
     "  * size : " .s
          *size,un-initialized-memory*
          . .l
     "  * used : " .s
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub . .l
     "  * free : " .s
          *size,un-initialized-memory*
          *current-free-address,un-initialized-memory*
          *un-initialized-memory*
          sub sub . .l
     "* *string-area*" .s .l
     "  * size : " .s
          *size,string-area*
          . .l
     "  * used : " .s
          *current-free-address,string-area*
          *string-area*
          sub . .l
     "  * free : " .s
          *size,string-area*
          *current-free-address,string-area*
          *string-area*
          sub sub . .l
     "* *jojo-area*" .s .l
     "  * size : " .s
          *size,jojo-area* . .l
     "  * used : " .s
          *current-free-address,jojo-area*
          *jojo-area*
          sub . .l
     "  * free : " .s
          *size,jojo-area*
          *current-free-address,jojo-area*
          *jojo-area*
          sub sub . .l
     end
   ; define-function
   #+end_src
** report-platform
   #+begin_src cicada-nymph :tangle core.cn
   : report-platform
     << -- >>
     "* platform : " .s
     platform .s
     .l
     end
   ; define-function
   #+end_src
** report-jo-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-jo-size
     << -- >>
     "* jo-size : " .s
     *jo-size* write-number
     " bytes" .s
     .l
     end
   ; define-function
   #+end_src
** report-machine-word-size
   #+begin_src cicada-nymph :tangle core.cn
   : report-machine-word-size
     << -- >>
     "* machine-word-size : " .s
     *jo-size* 8 mul write-number
     " bits" .s
     .l
     end
   ; define-function
   #+end_src
** report-syntax
   #+begin_src cicada-nymph :tangle core.cn
   : report-syntax
     << -- >>
     "* *rule-set,make-jojo* :" .s .l
      *rule-set,make-jojo* list-rule
     "* *rule-set,basic-REPL* :" .s .l
      *rule-set,basic-REPL* list-rule
     "* tos-syntax-stack :" .s .l
      tos-syntax-stack list-rule
     end
   ; define-function
   #+end_src
** initial-report
   #+begin_src cicada-nymph :tangle core.cn
   : initial-report
     << -- >>
     "* initial-report : " .s .l
     "  " .s report-platform
     "  " .s report-machine-word-size
     "  " .s report-jo-size
     end
   ; define-function
   #+end_src
* hi
** welcome
   #+begin_src cicada-nymph :tangle core.cn
   : welcome
     << -- >>
     "* welcome to cicada-nymph" .s .l
     end
   ; define-function
   #+end_src
** hi
   #+begin_src cicada-nymph :tangle core.cn
   0
   : *hi,random-base*
   ; define-variable,with-tos

   : hi,random
     << -- random-number >>
     0 :syscall-number,times:
     1 syscall
     9 mod
     <<
      *hi,random-base*
      *hi,random-base* add1 13 mod
      address *hi,random-base* save
     >>
     end
   ; define-function

   : hi,say
     << number -- >>
     dup 0 equal? if drop "  cica cica da yaya !!!" .s .l end then
     dup 1 equal? if drop "  hi ^-^" .s .l end then
     dup 2 equal? if drop "  hello :)" .s .l end then
     dup 3 equal? if drop "  hey *^-^*" .s .l end then
     dup 4 equal? if drop "  hiya \^o^/" .s .l end then
     dup 5 equal? if drop "  I wish you a lovely day" .s .l end then
     dup 6 equal? if drop "  I wish you a lovely day { or night :P }" .s .l end then
     dup 7 equal? if drop "  o.o" .s .l end then
                     drop "  lovely ^3^" .s .l end
   ; define-function

   : hi
     << -- >>
     hi,random
     hi,say
     end
   ; define-function
   #+end_src
** help
   #+begin_src cicada-nymph :tangle core.cn
   : help
     << -- >>
     "* helpful documentations will be written soon" .s .l
     "  please wait ^-^" .s .l
     end
   ; define-function
   #+end_src
* command-line-interface
** note
** command-line,unknow-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,unknow-function
     << -- >>
     "* (cicada-nymph) unknow command-line-function : " .s
     get-command-line
     string-tail,word
     string-head,word .s .l
     "  good bye ^-^/" .s .l
     bye
   ; define-function
   #+end_src
** command-line,stack-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,stack-REPL
     << -- >>
     welcome
     hi
     initial-report
     "* you are in the (stack-REPL)" .s .l
     "  every time after a word is executed" .s .l
     "  the argument-stack get printed" .s .l
     print-argument-stack,pretty
     jo stack-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,basic-REPL
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,basic-REPL
     << -- >>
     welcome
     hi
     initial-report
     "* you are in the (basic-REPL)" .s .l
     "  this REPL does not print any thing automaticly" .s .l
     jo basic-REPL
     reset-top-level-REPL
   ; define-function
   #+end_src
** command-line,poi
   * cn poi add  <name> <relative-path>
   * cn poi sub  <name>
   * cn poi up   <name> <relative-path>
   * cn poi find <name>
   * cn poi list
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,poi
     << -- >>
     get-command-line
     string-tail,word
     string-tail,word >::command-line

     ::command-line space-string? if
       poi,help
       bye
     then

     ::command-line string-head,word >::sub-function-name
     ::command-line string-tail,word >::command-line-arguments

     ::sub-function-name "help" string-equal? if
       poi,help
       bye
     then

     ::sub-function-name "add" string-equal? if
       ::command-line-arguments string-head,word
       ::command-line-arguments string-tail,word string-head,word
       poi,add
       bye
     then

     ::sub-function-name "sub" string-equal? if
       ::command-line-arguments string-head,word
       poi,sub
       bye
     then

     ::sub-function-name "up" string-equal? if
       ::command-line-arguments string-head,word
       ::command-line-arguments string-tail,word string-head,word
       poi,up
       bye
     then

     ::sub-function-name "find" string-equal? if
       ::command-line-arguments string-head,word
       poi,find if
         .s .l
       else
         "no found" .s .l
       then
       bye
     then

     ::sub-function-name "list" string-equal? if
       poi,list
       bye
     then

     "* (poi) meets argument that (poi) can not understand" .s .l
     "  it is the following command-line that is confusing (poi) :" .s .l
     "    " .s report-command-line .l
     "  to get some help info  you can type :" .s .l
     "    cn poi help" .s .l
     "  good bye ^-^/" .s .l
     bye
   ; define-function
   #+end_src
** command-line,no-function
   #+begin_src cicada-nymph :tangle core.cn
   : command-line,no-function
     << -- >>
     command-line,stack-REPL
     end
   ; define-function
   #+end_src
** command-line-dispatcher
   #+begin_src cicada-nymph :tangle core.cn
   : command-line-dispatcher
     << -- >>
     get-command-line
     string-tail,word
     dup2 space-string? if
       drop2
       command-line,no-function
       end
     then
     string-head,word
     >::1st-word
     ::1st-word "basic-REPL" string-equal? if
       command-line,basic-REPL
       end
     then
     ::1st-word "stack-REPL" string-equal? if
       command-line,stack-REPL
       end
     then
     ::1st-word "poi" string-equal? if
       command-line,poi
       end
     then
     command-line,unknow-function
     end
   ; define-function
   #+end_src
* *the-story-begin*
  #+begin_src cicada-nymph :tangle core.cn
  : the-story-begin
    << -- >>
    command-line-dispatcher
    end
  ; define-function

  the-story-begin
  #+end_src
* ===================================
* test
** report
   #+begin_src cicada-nymph
   report-memory
   report-syntax
   jo-link,report
   #+end_src
* ===================================
