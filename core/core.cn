: .l
  << -- >>
  10 write-byte
  end
; define-function

: .i
  << -- >>
  write-integer
  end
; define-function

: word:if?
  << word[address, length] -- bool >>
  "if" string-equal?
  end
; define-function

: word:else?
  << word[address, length] -- bool >>
  "else" string-equal?
  end
; define-function

: word:then?
  << word[address, length] -- bool >>
  "then" string-equal?
  end
; define-function

: syntax,if,make-jojo
  << string[address, length], word:if --
     address, string[address, length] >>
  drop2
  *false?branch* save-into,jo-heap
  *current-free-address,jo-heap* xx|swap|x
  0 save-into,jo-heap
  end
; define-function

: syntax,else,make-jojo
  << address, string[address, length], word:else --
     address, string[address, length] >>
  drop2
  *branch* save-into,jo-heap
  x|swap|xx
  *current-free-address,jo-heap* xxx|swap|x
  0 save-into,jo-heap
  << address, string[address, length], address >>
  *current-free-address,jo-heap*
  over sub *jo-size* div
  swap save
  end
; define-function

: syntax,then,make-jojo
  << address, string[address, length], word:then --
     string[address, length] >>
  drop2
  x|swap|xx
  *current-free-address,jo-heap*
  over sub *jo-size* div
  swap save
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
  jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
  jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: word:prepare-for?
  << word[address, length] -- bool >>
  "prepare-for" string-equal?
  end
; define-function

: syntax,prepare-for,make-jojo
  << string[address, length], word:prepare-for --
     string[address, length] >>
  drop2
  *prepare-for*    save-into,jo-heap
  *exception-head* save-into,jo-heap
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo word:prepare-for?
  jo syntax,prepare-for,make-jojo
  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: remove-char!,loop
  << cursor, length, char -- cursor >>
  >:char
  >:length
  >:cursor
  :length zero? if
    :cursor
    end
  then
  :cursor fetch-byte :char equal? if
    :cursor add1 :length sub1
    :cursor
    string->buffer!
    :cursor
    :length sub1
    :char
  else
    :cursor add1
    :length sub1
    :char
  then
  <> remove-char!,loop
; define-function

: remove-char!
  << string[address, length], char -- string[address, length] >>
  x|over|xx >:address
  remove-char!,loop >:cursor
  :address
  :cursor :address sub
  end
; define-function

: latin-char?
  << char -- bool >>
  dup "A" string-head,char less-than? false?branch 4
    drop false
    end
  dup "Z" string-head,char less-or-equal? false?branch 4
    drop true
    end
  dup "a" string-head,char less-than? false?branch 4
    drop false
    end
  dup "z" string-head,char less-or-equal? false?branch 4
    drop true
    end
  drop false
  end
; define-function

: latin-char->number
  << latin-char -- number >>
  dup "A" string-head,char less-than? if
    "* (latin-char->number) the argument must be a latin-char" .s .l
    "  but the following char is less-than 'A' : " .s
    .i .l
    end
  then
  dup "Z" string-head,char less-or-equal? if
    "A" string-head,char
    sub
    10 add
    end
  then
  dup "a" string-head,char less-than? if
    "* (latin-char->number) the argument must be a latin-char" .s .l
    "  but the following char is less-than 'a' but greater-then 'Z' : " .s
    .i .l
    end
  then
  dup "z" string-head,char less-or-equal? if
    "a" string-head,char
    sub
    10 add
    end
  then
  "* (latin-char->number) the argument must be a latin-char" .s .l
  "  but the following char is greater-then 'z' : " .s
  .i .l
  end
; define-function

: number->latin-char
  << number -- latin-char >>
  10 sub
  "a" string-head,char
  add
  end
; define-function

: wild-digit-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 true
    end
  then
  over fetch-byte
  dup digit-char?
  swap latin-char?
  or if
    string-tail,char
    <> wild-digit-string?
  then
  drop2
  false
  end
; define-function

: wild-integer-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 false
    end
  then
  dup2 string-head,char
  "-" string-head,char
  equal? if
    string-tail,char
    wild-digit-string?
    end
  then
  wild-digit-string?
  end
; define-function

: empty-string?
  << string[address, length] -- bool >>
  swap drop
  zero?
  end
; define-function

: base#wild-integer-string?
  << string[address, length] -- bool >>
  128 allocate-local-memory
  >:string-address
  tuck
  :string-address
  string->buffer!
  :string-address swap
  "_" string-head,char
  remove-char!
  >:new-string-length
  >:new-string-address
  << dup2 .s .l 0 end >>
  :new-string-address
  :new-string-length
  "#" string-head,char
  find-char,string if
  else
    false
    end
  then
  >:address-of-#
  :new-string-address
  :address-of-# :new-string-address sub
  >::base-string
  :address-of-# add1
  :address-of-# :new-string-address sub add1
  :new-string-length swap sub
  >::wild-integer-string
  ::base-string digit-string?
  ::base-string empty-string? not
  and if
  else
    false
    end
  then
  ::wild-integer-string wild-integer-string?
  ::wild-integer-string empty-string? not
  and if
    true
  else
    false
  then
  end
; define-function

: base#wild-integer-string->base-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string-head,char
  find-char,string if
  else
    "* (base#wild-integer-string->base-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address
  :address-of-# :address sub
  end
; define-function

: base#wild-integer-string->wild-integer-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string-head,char
  find-char,string if
  else
    "* (base#wild-integer-string->wild-integer-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address-of-# add1
  :address-of-# :address sub add1
  :length swap sub
  end
; define-function

: wild-integer-string->integer,with-base,loop
  << string[address, length], base, sum, counter -- integer >>
  >:counter
  >:sum
  >:base
  >:length
  >:address
  :length zero? if
    :sum
    end
  then
  :address fetch-byte >:char
  :char digit-char? if
    :char digit-char->number
  then
  :char latin-char? if
    :char latin-char->number
  then
  :base :counter power
  mul
  :sum add
  >:sum
  :address add1
  :length sub1
  :base
  :sum
  :counter add1
  <> wild-integer-string->integer,with-base,loop
; define-function

: wild-integer-string->integer,with-base
  << string[address, length], base -- integer >>
  >:base
  dup zero? if
    drop2
    0
    end
  then
  dup2 string-head,char
  "-" string-head,char
  equal? if
    string-tail,char
    -1 >:sign
  else
    1 >:sign
  then
  >::string
  ::string string-reverse!
  :base
  0 0 wild-integer-string->integer,with-base,loop
  :sign mul
  ::string string-reverse!
  drop2
  end
; define-function

: base#wild-integer-string->integer
  << string[address, length] -- integer >>
  128 allocate-local-memory
    >:address
  tuck :address string->buffer!
    >:length
  :address :length
  "_" string-head,char remove-char!
    >::string
  ::string
  base#wild-integer-string->base-string
    >::base-string
  ::string
  base#wild-integer-string->wild-integer-string
    >::wild-integer-string
  ::base-string
  digit-string->nature-number
    >:base
  ::wild-integer-string
  :base
  wild-integer-string->integer,with-base
  end
; define-function

: .#,loop
  << nature-number, base, cursor -- cursor >>
  >:cursor
  >:base
  >:nature-number
  :nature-number zero? if
    :cursor
    end
  then
  :nature-number
  :base
  divmod >:mod >:div
  :mod 10 less-than? if
    :mod number->digit-char
  else
    :mod number->latin-char
  then
  :cursor
  save-byte
  :div
  :base
  :cursor add1
  <> .#,loop
; define-function

: .#
  << integer, base -- >>
  over zero? if
    drop .i
    end
  then
  dup 36 greater-than?
  over 2 less-than?
  or if
    "* (.#) the base " .s .i " is not valid to write a number" .s .l
    "  a base should in between 2 and 36 includingly" .s .l
    "  the integer to be written is " .s .i .l
    end
  then
  dup .i
  "#" .s
  over negative? if
    swap negate swap
    "-" .s
  then
  128 allocate-local-memory >:buffer
  :buffer
  .#,loop >:cursor
  :buffer
  :cursor :buffer sub
  string-reverse! .s
  end
; define-function

: .#2  2  .# " " .s end ; define-function
: .#8  8  .# " " .s end ; define-function
: .#16 16 .# " " .s end ; define-function

: syntax,base#wild-integer-string,make-jojo
  << string[address, length], word[address, length] --
     string[address, length] >>
  *literal* save-into,jo-heap
  base#wild-integer-string->integer
  save-into,jo-heap
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo base#wild-integer-string?
  jo syntax,base#wild-integer-string,make-jojo
  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: allocate-memory
  << size -- address >>
  dup *current-free-address,un-initialized-memory* clear-memory
  *current-free-address,un-initialized-memory* swap << address as return value >>
  address *current-free-address,un-initialized-memory* add-save
  end
; define-function

1024 *jo-size* mul
: *size,rule-set,basic-REPL*
; define-variable

<< for cursor >>
*jo-size* allocate-memory drop

*size,rule-set,basic-REPL*
allocate-memory
: *rule-set,basic-REPL*
; define-variable

*rule-set,basic-REPL*
*rule-set,basic-REPL* *jo-size* sub
save

: execute-word
  << word[address, length] -- unknown >>
  dup2
  find if
    dup exception-jo? if
      drop
      "* (execute-word) can not execute exception directly : " .s
      .s .l
      end
    then
    << function & primitive-function & variable >>
    xx|swap|x drop2
    execute-jo
    end
  else
  "* (execute-word) meets undefined word : " .s
  .s .l
  then
  end
; define-function

: word:bye?
  << word[address, length] -- bool >>
  "bye" string-equal?
  end
; define-function

: !bye,basic-REPL
  << -- >>
  drop-syntax-stack
  end
; define-exception

: syntax,bye,basic-REPL
  << word:bye -- >>
  drop2
  !bye,basic-REPL
; define-function

: init,rule-set,basic-REPL
  << -- >>
  jo integer-string? jo string->integer       *rule-set,basic-REPL* add-rule
  jo word:bye?       jo syntax,bye,basic-REPL *rule-set,basic-REPL* add-rule

  jo base#wild-integer-string? jo base#wild-integer-string->integer *rule-set,basic-REPL* add-rule
  end
; define-function

init,rule-set,basic-REPL

: basic-REPL,loop
  << unknown -- unknown >>
  read-word-for-REPL
  dup2 find-syntax if
    execute-jo
  else
    execute-word
  then
  <> basic-REPL,loop
; define-function

: basic-REPL
  << unknown -- unknown >>
  prepare-for
    !bye,basic-REPL
    end
  *rule-set,basic-REPL* push-syntax-stack
  basic-REPL,loop
  end
; define-function

basic-REPL

: print-argument-stack,loop
  << address, counter -- >>
  dup zero? if
    drop2
    end
  then
  sub1 swap
    dup fetch .
  *jo-size* add
  swap
  <> print-argument-stack,loop
; define-function

: print-argument-stack
  << -- >>
  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot*
  *the-stack* greater-or-equal? if
    *the-stack*   << address as return value >>
    *the-stack-pointer-snapshot* *the-stack* sub
    *jo-size* div << counter as return value >>
    print-argument-stack,loop
    end
  then
  "below the stack " .s
  end
; define-function

: print-argument-stack,pretty
  << -- >>
  snapshot-the-stack-pointer
  .l
  " * " .s
     *the-stack-pointer-snapshot*
     *the-stack* sub
     << ad hoc for the BUG of div >>
     dup negative? if
       negate
       *jo-size* div
       negate
     else
       *jo-size* div
     then
     .i
  " * " .s
  " -- " .s
    print-argument-stack
  "--" .s
  .l
  end
; define-function

: stack-REPL,loop
  << unknown -- unknown >>
  read-word-for-REPL
  dup2 find-syntax if
    execute-jo
  else
    execute-word
  then
  print-argument-stack,pretty
  <> stack-REPL,loop
; define-function

: stack-REPL
  << unknown -- unknown >>
  prepare-for
    !bye,basic-REPL
    end
  *rule-set,basic-REPL* push-syntax-stack
  stack-REPL,loop
  end
; define-function

0 : :syscall-number,open:  ; define-variable
0 : :syscall-number,close: ; define-variable
0 : :syscall-number,read:  ; define-variable
0 : :syscall-number,write: ; define-variable
0 : :syscall-number,stat:  ; define-variable
0 : :syscall-number,exit:  ; define-variable
0 : :syscall-number,times: ; define-variable

: init-syscall-number
  << -- >>
  *jo-size* 4 equal? if
    5   address :syscall-number,open:  save
    6   address :syscall-number,close: save
    3   address :syscall-number,read:  save
    4   address :syscall-number,write: save
    106 address :syscall-number,stat:  save
    1   address :syscall-number,exit:  save
    43  address :syscall-number,times: save
    end
  then
  *jo-size* 8 equal? if
    2   address :syscall-number,open:  save
    3   address :syscall-number,close: save
    0   address :syscall-number,read:  save
    1   address :syscall-number,write: save
    4   address :syscall-number,stat:  save
    60  address :syscall-number,exit:  save
    100 address :syscall-number,times: save
    end
  then
  end
; define-function

init-syscall-number

: error-code->string
  << error-code -- string[address, length] >>
  dup -1  equal? if drop "EPERM    Operation not permitted " end then
  dup -2  equal? if drop "ENOENT   No such file or directory " end then
  dup -3  equal? if drop "ESRCH    No such process " end then
  dup -4  equal? if drop "EINTR    Interrupted system call " end then
  dup -5  equal? if drop "EIO      I/O error " end then
  dup -6  equal? if drop "ENXIO    No such device or address " end then
  dup -7  equal? if drop "E2BIG    Argument list too long " end then
  dup -8  equal? if drop "ENOEXEC  Exec format error " end then
  dup -9  equal? if drop "EBADF    Bad file number " end then
  dup -10 equal? if drop "ECHILD   No child processes " end then
  dup -11 equal? if drop "EAGAIN   Try again " end then
  dup -12 equal? if drop "ENOMEM   Out of memory " end then
  dup -13 equal? if drop "EACCES   Permission denied " end then
  dup -14 equal? if drop "EFAULT   Bad address " end then
  dup -15 equal? if drop "ENOTBLK  Block device required " end then
  dup -16 equal? if drop "EBUSY    Device or resource busy " end then
  dup -17 equal? if drop "EEXIST   File exists " end then
  dup -18 equal? if drop "EXDEV    Cross-device link " end then
  dup -19 equal? if drop "ENODEV   No such device " end then
  dup -20 equal? if drop "ENOTDIR  Not a directory " end then
  dup -21 equal? if drop "EISDIR   Is a directory " end then
  dup -22 equal? if drop "EINVAL   Invalid argument " end then
  dup -23 equal? if drop "ENFILE   File table overflow " end then
  dup -24 equal? if drop "EMFILE   Too many open files " end then
  dup -25 equal? if drop "ENOTTY   Not a typewriter " end then
  dup -26 equal? if drop "ETXTBSY  Text file busy " end then
  dup -27 equal? if drop "EFBIG    File too large " end then
  dup -28 equal? if drop "ENOSPC   No space left on device " end then
  dup -29 equal? if drop "ESPIPE   Illegal seek " end then
  dup -30 equal? if drop "EROFS    Read-only file system " end then
  dup -31 equal? if drop "EMLINK   Too many links " end then
  dup -32 equal? if drop "EPIPE    Broken pipe " end then
  dup -33 equal? if drop "EDOM     Math argument out of domain of func " end then
  dup -34 equal? if drop "ERANGE   Math result not representable " end then
  "unknow error-code : " .s
  .i .l
  end
; define-function

: report-dictionary,primitive-function,loop
  << counter, jo -- total >>
  dup zero? if
    drop
    end
  then
  dup primitive-function-jo? false? if
    jo->pre-jo
    <> report-dictionary,primitive-function,loop
  then
  swap
    "  " .s
    add1 dup .
  swap
  dup jo->name
  dup2 space-string? if
    drop2
    " un-named " .s .l
  else
    .s .l
  then
  jo->pre-jo
  <> report-dictionary,primitive-function,loop
; define-function

: report-dictionary,primitive-function
  << -- >>
  "* all primitive-function in dictionary :" .s .l
  0 *first-jo-in-dictionary*
  report-dictionary,primitive-function,loop
  end
; define-function

: report-dictionary,function,loop
  << counter, jo -- total >>
  dup zero? if
    drop
    end
  then
  dup function-jo? false? if
    jo->pre-jo
    <> report-dictionary,function,loop
  then
  swap
    "  " .s
    add1 dup .
  swap
  dup jo->name
  dup2 space-string? if
    drop2
    " un-named " .s .l
  else
    .s .l
  then
  jo->pre-jo
  <> report-dictionary,function,loop
; define-function

: report-dictionary,function
  << -- >>
  "* all function in dictionary :" .s .l
  0 *first-jo-in-dictionary*
  report-dictionary,function,loop
  end
; define-function

: report-dictionary,exception,loop
  << counter, jo -- total >>
  dup zero? if
    drop
    end
  then
  dup exception-jo? false? if
    jo->pre-jo
    <> report-dictionary,exception,loop
  then
  swap
    "  " .s
    add1 dup .
  swap
  dup jo->name
  dup2 space-string? if
    drop2
    " un-named " .s .l
  else
    .s .l
  then
  jo->pre-jo
  <> report-dictionary,exception,loop
; define-function

: report-dictionary,exception
  << -- >>
  "* all exception in dictionary :" .s .l
  0 *first-jo-in-dictionary*
  report-dictionary,exception,loop
  end
; define-function

: report-dictionary,variable,loop
  << counter, jo -- total >>
  dup zero? if
    drop
    end
  then
  dup variable-jo? false? if
    jo->pre-jo
    <> report-dictionary,variable,loop
  then
  swap
    "  " .s
    add1 dup .
  swap
  dup jo->name
  dup2 space-string? if
    drop2
    " un-named " .s .l
  else
    .s .l
  then
  jo->pre-jo
  <> report-dictionary,variable,loop
; define-function

: report-dictionary,variable
  << -- >>
  "* all variable in dictionary :" .s .l
  0 *first-jo-in-dictionary*
  report-dictionary,variable,loop
  end
; define-function

: report-dictionary
  << -- >>
  report-dictionary,primitive-function
  report-dictionary,function add
  report-dictionary,exception add
  report-dictionary,variable add
  "* totally : " .s
  .i .l
  end
; define-function

: report-memory
  << -- >>
  "* *un-initialized-memory*" .s .l
  "  * size : " .s
       *size,un-initialized-memory*
       . .l
  "  * used : " .s
       *current-free-address,un-initialized-memory*
       *un-initialized-memory*
       sub . .l
  "  * free : " .s
       *size,un-initialized-memory*
       *current-free-address,un-initialized-memory*
       *un-initialized-memory*
       sub sub . .l
  "* *primitive-string-heap*" .s .l
  "  * size : " .s
       *size,primitive-string-heap*
       . .l
  "  * used : " .s
       *current-free-address,primitive-string-heap*
       *primitive-string-heap*
       sub . .l
  "  * free : " .s
       *size,primitive-string-heap*
       *current-free-address,primitive-string-heap*
       *primitive-string-heap*
       sub sub . .l
  "* *jo-heap*" .s .l
  "  * size : " .s
       *size,jo-heap* . .l
  "  * used : " .s
       *current-free-address,jo-heap*
       *jo-heap*
       sub . .l
  "  * free : " .s
       *size,jo-heap*
       *current-free-address,jo-heap*
       *jo-heap*
       sub sub . .l
  end
; define-function

: report-platform
  << -- >>
  "* platform : " .s
  platform .s
  .l
  end
; define-function

: report-jo-size
  << -- >>
  "* jo-size : " .s
  *jo-size* write-nature-number
  " bytes" .s
  .l
  end
; define-function

: report-machine-word-size
  << -- >>
  "* machine-word-size : " .s
  *jo-size* 8 mul write-nature-number
  " bits" .s
  .l
  end
; define-function

: list-rule,loop
  << rule-set, cursor, counter -- >>
  xx|over|x equal? if
    drop drop2
    end
  then
  "  " .s
  add1 dup .
  swap
    dup cursor->predicate
    jo->name .s
    "  " .s
    dup cursor->function
    jo->name .s .l
    *jo-size* sub *jo-size* sub
  swap
  <> list-rule,loop
; define-function

: list-rule
  << rule-set -- >>
  dup rule-set,fetch-cursor
  0 list-rule,loop
  end
; define-function

: report-syntax
  << -- >>
  "* *rule-set,make-jojo* :" .s .l
   *rule-set,make-jojo* list-rule
  "* *rule-set,basic-REPL* :" .s .l
   *rule-set,basic-REPL* list-rule
  "* tos-syntax-stack :" .s .l
   tos-syntax-stack list-rule
  end
; define-function

: report-loaded-core-file
  << -- >>
  "* loaded-core-file : " .s
  get-path,loaded-core-file .s .l
  end
; define-function

: initial-report
  << -- >>
  "* initial-report : " .s .l
  "  " .s report-loaded-core-file
  "  " .s report-platform
  "  " .s report-machine-word-size
  "  " .s report-jo-size
  end
; define-function

: welcome
  << -- >>
  "* welcome to cicada-nymph ^-^" .s .l
  end
; define-function

0
: *hi,random-base*
; define-variable

: hi,random
  << -- random-number >>
  0 :syscall-number,times:
  1 syscall
  13 mod
  <<
   *hi,random-base*
   *hi,random-base* add1 13 mod
   address *hi,random-base* save
  >>
  end
; define-function

: hi,say
  << number -- >>
  dup 0 equal? if drop "* do not forget to eat good good coder !" .s .l end then
  dup 1 equal? if drop "* me wile moku e pona moku ^-^" .s .l end then
  dup 2 equal? if drop "* cica cica da yaya !!!" .s .l end then
  dup 3 equal? if drop "* hi ^-^" .s .l end then
  dup 4 equal? if drop "* hello :)" .s .l end then
  dup 5 equal? if drop "* hey *^-^*" .s .l end then
  dup 6 equal? if drop "* hiya \^o^/" .s .l end then
  dup 7 equal? if drop "* I wish you a lovely day" .s .l end then
  dup 8 equal? if drop "* I wish you a lovely day { or night :P }" .s .l end then
  dup 9 equal? if drop "* o.o" .s .l end then
  drop "* lovely ^3^" .s .l end
; define-function

: hi
  << -- >>
  hi,random
  hi,say
  end
; define-function

: help
  << -- >>
  "* helpful documentations will be written soon" .s .l
  "  please wait ^-^" .s .l
  end
; define-function

: open-input-port
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  0
  0 <<
  O_RDONLY
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: open-output-port,creat
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#1102 <<
  O_RDWR  0002h 0002o
  O_CREAT 0100h 0100o
  O_TRUNC 0800h 1000o
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: open-output-port,update
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  110100100b
  >>
  8#1002 <<
  O_RDWR  0002h 0002o
  O_TRUNC 0800h 1000o
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: close-port
  << port
     -- true
     -- error-code, false >>
  :syscall-number,close:
  1 syscall
  dup
  negative? if
    false
    end
  then
  drop true
  end
; define-function

: read-port
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  :syscall-number,read:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: write-port
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  :syscall-number,write:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

0 : +stat,st_dev+        ; define-variable
0 : +stat,st_ino+        ; define-variable
0 : +stat,st_mode+       ; define-variable
0 : +stat,st_nlink+      ; define-variable
0 : +stat,st_uid+        ; define-variable
0 : +stat,st_gid+        ; define-variable
0 : +stat,st_rdev+       ; define-variable
0 : +stat,st_size+       ; define-variable
0 : +stat,st_blksize+    ; define-variable
0 : +stat,st_blocks+     ; define-variable
0 : +stat,st_atime+      ; define-variable
0 : +stat,st_atime_nsec+ ; define-variable
0 : +stat,st_mtime+      ; define-variable
0 : +stat,st_mtime_nsec+ ; define-variable
0 : +stat,st_ctime+      ; define-variable
0 : +stat,st_ctime_nsec+ ; define-variable
0 : +stat,__unused4+     ; define-variable
0 : +stat,__unused5+     ; define-variable
0 : +stat,end+           ; define-variable

: init,stat
  << offset -- >>
  *jo-size* 4 equal? if
    dup address +stat,st_dev+        save *jo-size* add
    dup address +stat,st_ino+        save *jo-size* add
    dup address +stat,st_mode+       save 2 add
    dup address +stat,st_nlink+      save 2 add
    dup address +stat,st_uid+        save 2 add
    dup address +stat,st_gid+        save 2 add
    dup address +stat,st_rdev+       save *jo-size* add
    dup address +stat,st_size+       save *jo-size* add
    dup address +stat,st_blksize+    save *jo-size* add
    dup address +stat,st_blocks+     save *jo-size* add
    dup address +stat,st_atime+      save *jo-size* add
    dup address +stat,st_atime_nsec+ save *jo-size* add
    dup address +stat,st_mtime+      save *jo-size* add
    dup address +stat,st_mtime_nsec+ save *jo-size* add
    dup address +stat,st_ctime+      save *jo-size* add
    dup address +stat,st_ctime_nsec+ save *jo-size* add
    dup address +stat,__unused4+     save *jo-size* add
    dup address +stat,__unused5+     save *jo-size* add
        address +stat,end+           save
    end
  then
  *jo-size* 8 equal? if
    dup address +stat,st_dev+        save *jo-size* add
    dup address +stat,st_ino+        save *jo-size* add
    <<
    note the following order changing
    this is linux' bad
    >>
    dup address +stat,st_nlink+      save 8 add
    dup address +stat,st_mode+       save 4 add

    dup address +stat,st_uid+        save 4 add
    dup address +stat,st_gid+        save 4 add
                                          4 add << padding >>
    dup address +stat,st_rdev+       save *jo-size* add
    dup address +stat,st_size+       save *jo-size* add
    dup address +stat,st_blksize+    save *jo-size* add
    dup address +stat,st_blocks+     save *jo-size* add
    dup address +stat,st_atime+      save *jo-size* add
    dup address +stat,st_atime_nsec+ save *jo-size* add
    dup address +stat,st_mtime+      save *jo-size* add
    dup address +stat,st_mtime_nsec+ save *jo-size* add
    dup address +stat,st_ctime+      save *jo-size* add
    dup address +stat,st_ctime_nsec+ save *jo-size* add
    dup address +stat,__unused4+     save *jo-size* add
    dup address +stat,__unused5+     save *jo-size* add
        address +stat,end+           save
    end
  then
  end
; define-function

0 init,stat
+stat,end+ : +stat,length+ ; define-variable

: path-to-nothing?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  :syscall-number,stat:
  2 syscall
  -2 equal?
  end
; define-function

: path-to-file?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  :syscall-number,stat:
  2 syscall
  dup
  negative? if
    drop
    false
    end
  then
  drop
  :stat-structure init,stat
  *jo-size* 4 equal? if
    +stat,st_mode+
    fetch-two-bytes
  then
  *jo-size* 8 equal? if
    +stat,st_mode+
    fetch-four-bytes
  then
  <<
  0170000
__S_IFDIR       0040000 /* Directory.  */
__S_IFCHR       0020000 /* Character device.  */
__S_IFBLK       0060000 /* Block device.  */
__S_IFREG       0100000 /* Regular file.  */
__S_IFIFO       0010000 /* FIFO.  */
__S_IFLNK       0120000 /* Symbolic link.  */
__S_IFSOCK      0140000 /* Socket.  */
>>
  end
; define-function

: path-to-directory?
  << path[address, length] -- bool >>

  end
; define-function

: poi,help
  << -- >>

  end
; define-function

: poi,add
  << name[address, length], relative-path[address, length] -- >>

  end
; define-function

: poi,sub
  << name[address, length] -- >>

  end
; define-function

: poi,up
  << name[address, length], relative-path[address, length] -- >>

  end
; define-function

: poi,list
  << -- >>

  end
; define-function

: poi,show
  << name[address, length] -- >>

  end
; define-function

: load-file
  << ??? -- >>

  end
; define-function

100333 drop
13
: *name-hash-table,size*
; define-variable

*jo-size* 4 mul
: *name-hash-table,unit*
; define-variable

*name-hash-table,size*
*name-hash-table,unit* mul
allocate-memory
: *name-hash-table*
; define-variable

0
: *name-hash-table,counter*
; define-variable

: name-hash-table,hash
  << number, counter -- index >>
  add *name-hash-table,size* mod
  end
; define-function

16
: *max-carry-position*
; define-variable

: string->finite-carry-sum,loop
  << carry-sum, string[address, length], counter -- carry-sum >>
  over zero? if
    drop drop2
    end
  then
  dup *max-carry-position* greater-than? if
    drop 0 << re-start from 0 >>
  then
  xx|over|x
  string-head,char over
  2 swap power
  mul
  x|swap|xxxx add xxx|swap|x
  add1 xx|swap|x
  string-tail,char x|swap|xx
  <> string->finite-carry-sum,loop
; define-function

: string->finite-carry-sum
  << string[address, length] -- carry-sum >>
  0 xx|swap|x << carry-sum >>
  0 << counter >>
  string->finite-carry-sum,loop
  end
; define-function

: name->address
  << name -- address >>
  *name-hash-table,unit* mul
  *name-hash-table* add
  end
; define-function

: name,used?
  << name -- bool >>
  name->address
  fetch zero? false?
  end
; define-function

: name,used-as-title?
  << name -- bool >>
  name->address
  *jo-size* add
  fetch zero?
  end
; define-function

: name,fetch-string
  << name -- string[address, length] >>
  name->address
  fetch
  address->primitive-string
  end
; define-function

: name,fetch-title-index
  << name -- index >>
  name->address
  *jo-size* add
  fetch
  end
; define-function

: name,fetch-orbit-length
  << name -- length >>
  name->address
  *jo-size* add
  *jo-size* add
  fetch
  end
; define-function

: name,fetch-orbiton
  << name -- address >>
  name->address
  *jo-size* add
  *jo-size* add
  *jo-size* add
  fetch
  end
; define-function

: name,save-string
  << string[address, length], name -- >>
  *current-free-address,primitive-string-heap*
  xx|swap|xx
  save-into,primitive-string-heap
  swap
  name->address
  save
  end
; define-function

: name,save-title-index
  << index, name -- >>
  name->address
  *jo-size* add
  save
  end
; define-function

: name,save-orbit-length
  << index, name -- >>
  name->address
  *jo-size* add
  *jo-size* add
  save
  end
; define-function

: name,save-orbiton
  << index, name -- >>
  name->address
  *jo-size* add
  *jo-size* add
  *jo-size* add
  save
  end
; define-function

: name,no-collision?
  << name -- bool >>
  dup name,fetch-orbiton
  equal?
  end
; define-function

: name-hash-table,search,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    :name false
    end
  then
  :name name,fetch-string
  ::string string-equal? if
    :name true
    end
  then
  :name name,fetch-orbit-length
  :counter equal? if
    :name false
    end
  then
  ::string
  :number :counter add1
  <> name-hash-table,search,loop
; define-function

: name-hash-table,search
  << string[address, length]
     -- name, true
     -- false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,search,loop
  end
; define-function

: name-hash-table,insert,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    ::string :name
    name,save-string
    :orbit :name
    name,save-orbiton
    :counter :orbit
    name,save-orbit-length
    1 address *name-hash-table,counter* add-save
    :name true
    end
  then
  :name name,fetch-string
  ::string string-equal? if
    :name true
    end
  then
  :counter *name-hash-table,size* equal? if
    :name false
    end
  then
  ::string
  :number :counter add1
  <> name-hash-table,insert,loop
; define-function

: name-hash-table,insert
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,insert,loop
  end
; define-function

: string->name
  << string[address, length] -- name >>
  name-hash-table,insert
  false? if
    "* (string->name) *name-hash-table* is full!" .s .l
    end
  then
  end
; define-function

: name->string
  << name -- string[address, length]] >>
  name,fetch-string
  end
; define-function

: name-hash-table,test
  << -- >>
  "a-000" string->name . .l
  "a-111" string->name . .l
  "a-222" string->name . .l
  "a-333" string->name . .l
  "a-444" string->name . .l
  "a-555" string->name . .l
  "a-666" string->name . .l
  "a-777" string->name . .l
  "a-888" string->name . .l
  "a-999" string->name . .l
  "b-000" string->name . .l
  "b-111" string->name . .l
  "b-222" string->name . .l
  "b-333" string->name . .l
  "b-444" string->name . .l
  "b-555" string->name . .l
  "b-666" string->name . .l
  "b-777" string->name . .l
  "b-888" string->name . .l
  "b-999" string->name . .l
  end
; define-function

: name-hash-table,report,orbit
  << name, counter -- >>
  over name,fetch-orbit-length
  over less-than? if
    drop2
    end
  then
  over name,fetch-string string->finite-carry-sum
  over name-hash-table,hash
  dup name,fetch-orbiton
  << name, counter, new-name, orbiton >>
  x|over|xxx name,fetch-string string->finite-carry-sum
  0 name-hash-table,hash
  equal? if
    "  {" .s
    dup write-nature-number
    "} " .s
    name,fetch-string .s
    .l
  else
    drop
  then
  add1 <> name-hash-table,report,orbit
; define-function

: name-hash-table,report,loop
  << name -- >>
  dup *name-hash-table,size* equal? if
    drop
    end
  then
  dup name,used? if
  dup name,no-collision? if
    << * {index} string # orbit-lenght >>
    "* {" .s
    dup write-nature-number
    "} " .s
    dup name,fetch-string .s
    " # " .s
    dup name,fetch-orbit-length
    write-nature-number
    .l
    dup 1 name-hash-table,report,orbit
  then
  then
  add1 <> name-hash-table,report,loop
; define-function

: name-hash-table,report
  << -- >>
  0 name-hash-table,report,loop
  "* totally : " .s
  *name-hash-table,counter* write-nature-number
  .l
  end
; define-function

: command-line,unknow-function
  << -- >>
  "* (cicada-nymph) unknow command-line-function : " .s
  get-command-line
  string-tail,word
  string-head,word .s .l
  "* good bye ^-^/" .s .l
  bye
  end
; define-function

: command-line,stack-REPL
  << -- >>
  welcome
  initial-report
  hi
  "* you are in the (stack-REPL)" .s .l
  "  every time after a word is executed" .s .l
  "  the argument-stack get printed" .s .l
  print-argument-stack,pretty
  jo stack-REPL
  reset-top-level-REPL
; define-function

: command-line,basic-REPL
  << -- >>
  welcome
  initial-report
  hi
  "* you are in the (basic-REPL)" .s .l
  "  this REPL does not print any thing automaticly" .s .l
  jo basic-REPL
  reset-top-level-REPL
; define-function

: command-line,poi
  << -- >>
  "* poi byebye" .s .l
  bye
  end
; define-function

: command-line,no-function
  << -- >>
  <> command-line,stack-REPL
; define-function

: command-line-dispatcher
  << -- >>
  get-command-line
  string-tail,word
  dup2 space-string? if
    drop2
    <> command-line,no-function
  then
  string-head,word
  >::1st-word
  ::1st-word "basic-REPL" string-equal? if
    <> command-line,basic-REPL
  then
  ::1st-word "stack-REPL" string-equal? if
    <> command-line,stack-REPL
  then
  ::1st-word "poi" string-equal? if
    <> command-line,poi
  then
    <> command-line,unknow-function
; define-function

: the-story-begin
  << -- >>
  <> command-line-dispatcher
; define-function

the-story-begin
