: .l
  << -- >>
  10 write-byte
  end
; define-function

: .i
  << -- >>
  write-integer
  end
; define-function

: .b
  << byte -- >>
  write-byte
  end
; define-function

: word:if?
  << word[address, length] -- bool >>
  "if" string-equal?
  end
; define-function

: word:else?
  << word[address, length] -- bool >>
  "else" string-equal?
  end
; define-function

: word:then?
  << word[address, length] -- bool >>
  "then" string-equal?
  end
; define-function

: syntax,if,make-jojo
  << jo, string[address, length], word:if --
     address, jo, string[address, length] >>
  drop2
  jo instruction,false?branch
    jojo-area,stay
  *jojo-area,current-free-address* xxx|swap|x
  0 jojo-area,stay
  end
; define-function

: syntax,else,make-jojo
  << address, jo, string[address, length], word:else --
     address, jo, string[address, length] >>
  drop2
  jo instruction,branch
     jojo-area,stay
  x|swap|xxx
  *jojo-area,current-free-address* xxxx|swap|x
  0 jojo-area,stay
  << address, string[address, length], address >>
  *jojo-area,current-free-address*
  over sub *jo-size* div
  swap save
  end
; define-function

: syntax,then,make-jojo
  << address, jo, string[address, length], word:then --
     jo, string[address, length] >>
  drop2
  x|swap|xxx
  *jojo-area,current-free-address*
  over sub *jo-size* div
  swap save
  end
; define-function

: word:prepare-for?
  << word[address, length] -- bool >>
  "prepare-for" string-equal?
  end
; define-function

: syntax,prepare-for,make-jojo
  << string[address, length], word:prepare-for --
     string[address, length] >>
  drop2
  jo instruction,prepare-for
    jojo-area,stay
  jo instruction,exception-head
    jojo-area,stay
  end
; define-function

: word:exception-reset-stack?
  << word[address, length] -- bool >>
  "exception-reset-stack" string-equal?
  end
; define-function

: syntax,exception-reset-stack,make-jojo
  << jo, string[address, length], word:exception-reset-stack --
     jo, string[address, length] >>
  drop2
  jo instruction,exception-reset-stack
    jojo-area,stay
  x|over|xx
    jojo-area,stay
  end
; define-function

: word:save-to?
  << word[address, length] -- bool >>
  "save-to" string-equal?
  end
; define-function

: syntax,save-to,make-jojo
  << string[address, length], word:save-to --
     string[address, length] >>
  <<
  note that
  the following call to (syntax,address,make-jojo)
  will drop word:save-to
  >>
  syntax,address,make-jojo
  jo save
    jojo-area,stay
  end
; define-function

: word:loop?
  << word[address, length] -- bool >>
  "loop" string-equal?
  end
; define-function

: syntax,loop,make-jojo
  << jo, string[address, length], word:loop --
     jo, string[address, length] >>
  drop2
  jo tail-call
    jojo-area,stay
  x|over|xx
    jojo-area,stay
  end
; define-function

: word:recur?
  << word[address, length] -- bool >>
  "recur" string-equal?
  end
; define-function

: syntax,recur,make-jojo
  << jo, string[address, length], word:recur --
     jo, string[address, length] >>
  drop2
  x|over|xx
    jojo-area,stay
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo word:if?   jo syntax,if,make-jojo    *rule-set,make-jojo* add-rule
  jo word:else? jo syntax,else,make-jojo  *rule-set,make-jojo* add-rule
  jo word:then? jo syntax,then,make-jojo  *rule-set,make-jojo* add-rule

  jo word:prepare-for?
  jo syntax,prepare-for,make-jojo
  *rule-set,make-jojo* add-rule
  jo word:exception-reset-stack?
  jo syntax,exception-reset-stack,make-jojo
  *rule-set,make-jojo* add-rule

  jo word:save-to?
  jo syntax,save-to,make-jojo
  *rule-set,make-jojo* add-rule

  jo word:loop?  jo syntax,loop,make-jojo  *rule-set,make-jojo* add-rule
  jo word:recur? jo syntax,recur,make-jojo *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: allocate-memory
  << size -- address >>
  dup *un-initialized-memory,current-free-address* clear-memory
  *un-initialized-memory,current-free-address* swap << address as return value >>
  address *un-initialized-memory,current-free-address* add-save
  end
; define-function

100333
<< drop 13 >>
: *name-hash-table,size*
; define-variable,with-tos

*jo-size* 5 mul
: *name-hash-table,unit*
; define-variable,with-tos

*name-hash-table,size*
*name-hash-table,unit* mul allocate-memory
: *name-hash-table*
; define-variable,with-tos

0
: *name-hash-table,counter*
; define-variable,with-tos

: name->address
  << name -- address >>
  *name-hash-table,unit* mul
  *name-hash-table* add
  end
; define-function

: name,used?
  << name -- bool >>
  name->address
  fetch zero? false?
  end
; define-function

: name,used-as-jo?
  << name -- bool >>
  name->address
  *jo-size* 4 mul add
  fetch zero? not
  end
; define-function

: name->string
  << name -- string[address, length] >>
  name->address
  2 n-fetch
  end
; define-function

: name,fetch-orbit-length
  << name -- orbit-length >>
  name->address
  *jo-size* 2 mul add
  fetch
  end
; define-function

: name,fetch-orbiton
  << name -- orbiton >>
  name->address
  *jo-size* 3 mul add
  fetch
  end
; define-function

: name,fetch-jo
  << name -- jo >>
  name->address
  *jo-size* 4 mul add
  fetch
  end
; define-function

: name,save-string
  << string[address, length], name -- >>
  >:name
  make-string
  :name name->address
  2 n-save
  end
; define-function

: name,save-string,share
  << string[address, length], name -- >>
  name->address
  2 n-save
  end
; define-function

: name,save-orbit-length
  << orbit-length, name -- >>
  name->address
  *jo-size* 2 mul add
  save
  end
; define-function

: name,save-orbiton
  << orbiton, name -- >>
  name->address
  *jo-size* 3 mul add
  save
  end
; define-function

: name,save-jo
  << jo, name -- >>
  name->address
  *jo-size* 4 mul add
  save
  end
; define-function

: name,no-collision?
  << name -- bool >>
  dup name,fetch-orbiton
  equal?
  end
; define-function

: name-hash-table,hash
  << number, counter -- index >>
  add *name-hash-table,size* mod
  end
; define-function

16
: *max-carry-position*
; define-variable,with-tos

: string->finite-carry-sum,loop
  << carry-sum, string[address, length], counter -- carry-sum >>
  over zero? if
    drop drop2
    end
  then
  dup *max-carry-position* greater-than? if
    drop 0 << re-start from 0 >>
  then
  xx|over|x
  string-head,byte over
  2 swap power
  mul
  x|swap|xxxx add xxx|swap|x
  add1 xx|swap|x
  string-tail,byte x|swap|xx
  loop
; define-function

: string->finite-carry-sum
  << string[address, length] -- carry-sum >>
  0 xx|swap|x << carry-sum >>
  0 << counter >>
  string->finite-carry-sum,loop
  end
; define-function

: name-hash-table,search,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    :name false
    end
  then
  :name name->string
  ::string string-equal? if
    :name true
    end
  then
  :name name,fetch-orbit-length
  :counter equal? if
    :name false
    end
  then
  ::string
  :number :counter add1
  loop
; define-function

: name-hash-table,search
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,search,loop
  end
; define-function

: name-hash-table,insert,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    ::string :name
    name,save-string
    :orbit :name
    name,save-orbiton
    :counter :orbit
    name,save-orbit-length
    1 address *name-hash-table,counter* add-save
    :name true
    end
  then
  :name name->string
  ::string string-equal? if
    :name true
    end
  then
  :counter *name-hash-table,size* equal? if
    :name false
    end
  then
  ::string
  :number
  :counter add1
  loop
; define-function

: name-hash-table,insert
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,insert,loop
  end
; define-function

: name-hash-table,insert,share,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    ::string :name
    name,save-string,share
    :orbit :name
    name,save-orbiton
    :counter :orbit
    name,save-orbit-length
    1 address *name-hash-table,counter* add-save
    :name true
    end
  then
  :name name->string
  ::string string-equal? if
    :name true
    end
  then
  :counter *name-hash-table,size* equal? if
    :name false
    end
  then
  ::string
  :number
  :counter add1
  loop
; define-function

: name-hash-table,insert,share
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,insert,share,loop
  end
; define-function

: string->name
  << string[address, length] -- name >>
  name-hash-table,insert
  false? if
    "* (string->name) *name-hash-table* is full!" .s .l
    end
  then
  end
; define-function

: string->name,share
  << string[address, length] -- name >>
  name-hash-table,insert,share
  false? if
    "* (string->name,share) *name-hash-table* is full!" .s .l
    end
  then
  end
; define-function

: name-hash-table,report,orbit
  << name, counter -- >>
  over name,fetch-orbit-length
  over less-than? if
    drop2
    end
  then
  over name->string string->finite-carry-sum
  over name-hash-table,hash
  dup name,fetch-orbiton
  << name, counter, new-name, orbiton >>
  x|over|xxx name->string string->finite-carry-sum
  0 name-hash-table,hash
  equal? if
    "  {" .s
    dup write-number
    "} " .s
    name->string .s
    .l
  else
    drop
  then
  add1
  loop
; define-function

: name-hash-table,report,loop
  << name -- >>
  dup *name-hash-table,size* equal? if
    drop
    end
  then
  dup name,used? if
  dup name,no-collision? if
    << * {index} string # orbit-lenght >>
    "* {" .s
    dup write-number
    "} " .s
    dup name->string .s
    " # " .s
    dup name,fetch-orbit-length
    write-number
    .l
    dup 1 name-hash-table,report,orbit
  then
  then
  add1
  loop
; define-function

: name-hash-table,report
  << -- >>
  0 name-hash-table,report,loop
  "* totally : " .s
  *name-hash-table,counter* write-number
  .l
  end
; define-function

: name-hash-table,save-jo
  << jo -- >>
  >:jo
  :jo jo->name-string string->name,share >:name
  :jo :name name,save-jo
  end
; define-function

: name-hash-table,find-jo
  << word[address, length]
     -- jo, true
     -- false >>
  name-hash-table,search if
  else
    drop
    false
    end
  then
  dup name,used-as-jo? if
    name,fetch-jo
    true
    end
  then
  drop
  false
  end
; define-function

: name-hash-table,delete-jo
  << jo -- >>
  >:jo
  :jo jo->name-string string->name,share >:name
  0 :name name,save-jo
  end
; define-function

: n-string->buffer!,loop
  << string-1[address, length],
     ...
     string-2[address, length],
     buffer, n, cursor
     -- length >>
  >:cursor
  >:n
  >:buffer
  :n zero? if
    :buffer
    :cursor :buffer sub
    string-reverse!
    swap drop
    end
  then
  dup zero? if
    drop2
    :buffer
    :n sub1
    :cursor
    loop
  then
  dup2 add sub1 fetch-byte :cursor save-byte
  sub1
  :buffer
  :n
  :cursor add1
  loop
; define-function

: n-string->buffer!
  << string-1[address, length],
     ...
     string-2[address, length],
     buffer, n
     -- length >>
  over n-string->buffer!,loop
  end
; define-function

: string,find-word
  << string[address, length], word[address, length]
     -- sub-string[address, length], true
     -- false >>
  xx|over|xx space-string? if
    drop2 drop2
    false
    end
  then
  xx|over|xx string-head,word
  xx|over|xx string-equal? if
    drop2
    true
    end
  then
  xx|swap|xx string-tail,word
  xx|swap|xx
  loop
; define-function

: make-jojo,dispatch-word
  << jo, string[address, length], word[address, length] --
     jo, string[address, length] >>
  dup2 find-syntax if
    apply
    end
  then
  dup2 name-hash-table,find-jo if
    xx|swap|x drop2
    jojo-area,stay
    end
  then
  "* (make-jojo) meets undefined word : " .s .s .l
  x|over|xx name-hash-table,delete-jo
  !undo-make-jojo
; define-function

: make-jojo,loop
  << jo, string[address, length] -- >>
  dup2 space-string? if
    drop2
    drop
    end
  then
  dup2
  string-tail,word
  xx|swap|xx
  string-head,word
  make-jojo,dispatch-word
  loop
; define-function

: make-jojo
  << jo, string[address, length] -- >>
  local-variable-table,clear
  *rule-set,make-jojo*
  push-syntax-stack
  make-jojo,loop
  drop-syntax-stack
  end
; define-function

: init,name-hash-table,by-link
  << link -- >>
  >:link
  :link zero? if
    end
  then
  :link link->name-string >::name-string
  ::name-string name-hash-table,search swap >:name if
    :name name,used-as-jo? if
      :link link->next-link
      loop
    then
  then
  :link link->jo name-hash-table,save-jo
  :link link->next-link
  loop
; define-function

: define-variable,with-tos
  << value, string[address, length] -- >>
  string-head,word make-string >::name
  >:value

  ::name *link* 0
  make-link >:link

  :link save-to *link*

  ::name *explainer,variable* 0
  make-jo-head >:jo

  :jo :link link,save-jo

  :jo name-hash-table,save-jo

  1 :jo jo,save-length

  :value jojo-area,stay
  end
; define-function

: define-exception
  << string[address, length] -- >>
  *string-area,current-free-address* xx|swap|x
  *jojo-area,current-free-address* xx|swap|x
  *link* xx|swap|x
  << *string-area,current-free-address*
     *jojo-area,current-free-address*
     *link*
     string[address, length] >>
  prepare-for
    !undo-make-jojo
    end

  dup2 string-head,word >::name
  dup2 string-tail,word >::body

  ::name make-string >::name

  ::name *link* 0
  make-link >:link

  :link save-to *link*

  ::name *explainer,exception* 0
  make-jo-head >:jo

  :jo :link link,save-jo

  :jo name-hash-table,save-jo

  *jojo-area,current-free-address* >:old-address

  :jo ::body make-jojo

  *jojo-area,current-free-address*
  :old-address sub *jo-size* div
  :jo jo,save-length

  drop2
  drop
  drop
  drop
  end
; define-function

: <word>?
  << string[address, length] -- bool >>
  dup 2 less-or-equal? if
    drop2
    false
    end
  then
  dup2 string-end,byte
  ">" string-end,byte equal? not if
    drop2
    false
    end
  then
  string-head,byte
  "<" string-head,byte equal?
  end
; define-function

: name-hash-table,find-jo,with-title
  << title[address, length], word[address, length]
     -- jo, true
     -- false >>
  512 allocate-local-memory >:buffer
  " " xx|swap|xx
  :buffer
  3 n-string->buffer! >:length
  :buffer
  :length
  name-hash-table,search if
  else
    drop
    false
    end
  then
  dup name,used-as-jo? if
    name,fetch-jo
    true
    end
  then
  drop
  false
  end
; define-function

: define-function,with-title
  << string[address, length] -- >>
  *string-area,current-free-address* xx|swap|x
  *jojo-area,current-free-address* xx|swap|x
  *link* xx|swap|x
  << *string-area,current-free-address*
     *jojo-area,current-free-address*
     *link*
     string[address, length] >>
  prepare-for
    !undo-make-jojo
    end

  dup2 string-head,word >::title
  dup2 string-tail,word string-head,word >::name
  dup2 string-tail,word string-tail,word >::body

  ::title <word>? not if
    "* (define-function,with-title) the string is not begin with a <title>" .s .l
    !undo-make-jojo
  then

  512 allocate-local-memory >:buffer
  ::title " " ::name
  :buffer
  3 n-string->buffer! >:length

  :buffer :length
  make-string >::title-name

  ::title-name *link* 0
  make-link >:link

  :link save-to *link*

  ::title-name *explainer,function* 0
  make-jo-head >:jo

  :jo :link link,save-jo

  :jo name-hash-table,save-jo

  *jojo-area,current-free-address* >:old-address

  :jo ::body make-jojo

  *jojo-area,current-free-address*
  :old-address sub *jo-size* div
  :jo jo,save-length

  drop2
  drop
  drop
  drop
  end
; define-function

: define-function,without-title
  << string[address, length] -- >>
  *string-area,current-free-address* xx|swap|x
  *jojo-area,current-free-address* xx|swap|x
  *link* xx|swap|x
  << *string-area,current-free-address*
     *jojo-area,current-free-address*
     *link*
     string[address, length] >>
  prepare-for
    !undo-make-jojo
    end

  dup2 string-head,word >::name
  dup2 string-tail,word >::body

  ::name make-string >::name

  ::name *link* 0
  make-link >:link

  :link save-to *link*

  ::name *explainer,function* 0
  make-jo-head >:jo

  :jo :link link,save-jo

  :jo name-hash-table,save-jo

  *jojo-area,current-free-address* >:old-address

  :jo ::body make-jojo

  *jojo-area,current-free-address*
  :old-address sub *jo-size* div
  :jo jo,save-length

  drop2
  drop
  drop
  drop
  end
; define-function

: define-function
  << string[address, length] -- >>
  dup2 string-head,word >::head
  ::head <word>? if
    define-function,with-title
    end
  then
  define-function,without-title
  end
; define-function

*link* init,name-hash-table,by-link

: syntax,<title>,make-jojo
  << jo, string[address, length], <title>[address, length] --
     jo, string[address, length] >>
  >::title
  >::string
  >:jo
  ::title ::string string-head,word
  name-hash-table,find-jo,with-title if
    jojo-area,stay
  else
    "* (syntax,<title>,make-jojo) meet undefined" .s .l
    "  title : " .s ::title .s .l
    "  name  : " .s ::string string-head,word .s .l
    :jo name-hash-table,delete-jo
    !undo-make-jojo
  then
  :jo
  ::string string-tail,word
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo <word>?
  jo syntax,<title>,make-jojo
  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: word:name?
  << word[address, length] -- bool >>
  "name" string-equal?
  end
; define-function

: syntax,name,make-jojo
  << string[address, length], word[address, length] --
     string[address, length] >>
  drop2
  jo instruction,literal
    jojo-area,stay
  dup2
  string-head,word
  string->name
    jojo-area,stay
  string-tail,word
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo word:name?
  jo syntax,name,make-jojo
  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

: define-alias,with-title
  << string[address, length] -- >>

  end
; define-function



: remove-char!,loop
  << cursor, length, char -- cursor >>
  >:char
  >:length
  >:cursor
  :length zero? if
    :cursor
    end
  then
  :cursor fetch-byte :char equal? if
    :cursor add1 :length sub1
    :cursor
    string->buffer!
    :cursor
    :length sub1
    :char
  else
    :cursor add1
    :length sub1
    :char
  then
  loop
; define-function

: remove-char!
  << string[address, length], char -- string[address, length] >>
  x|over|xx >:address
  remove-char!,loop >:cursor
  :address
  :cursor :address sub
  end
; define-function

: latin-char?
  << char -- bool >>
  dup "A" string-head,byte less-than? false?branch 4
    drop false
    end
  dup "Z" string-head,byte less-or-equal? false?branch 4
    drop true
    end
  dup "a" string-head,byte less-than? false?branch 4
    drop false
    end
  dup "z" string-head,byte less-or-equal? false?branch 4
    drop true
    end
  drop false
  end
; define-function

: latin-char->number
  << latin-char -- number >>
  dup "A" string-head,byte less-than? if
    "* (latin-char->number) the argument must be a latin-char" .s .l
    "  but the following char is less-than 'A' : " .s
    .i .l
    end
  then
  dup "Z" string-head,byte less-or-equal? if
    "A" string-head,byte
    sub
    10 add
    end
  then
  dup "a" string-head,byte less-than? if
    "* (latin-char->number) the argument must be a latin-char" .s .l
    "  but the following char is less-than 'a' but greater-then 'Z' : " .s
    .i .l
    end
  then
  dup "z" string-head,byte less-or-equal? if
    "a" string-head,byte
    sub
    10 add
    end
  then
  "* (latin-char->number) the argument must be a latin-char" .s .l
  "  but the following char is greater-then 'z' : " .s
  .i .l
  end
; define-function

: number->latin-char
  << number -- latin-char >>
  10 sub
  "a" string-head,byte
  add
  end
; define-function

: wild-digit-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 true
    end
  then
  over fetch-byte
  dup digit-char?
  swap latin-char?
  or if
    string-tail,byte
    loop
  then
  drop2
  false
  end
; define-function

: wild-integer-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 false
    end
  then
  dup2 string-head,byte
  "-" string-head,byte
  equal? if
    string-tail,byte
    wild-digit-string?
    end
  then
  wild-digit-string?
  end
; define-function

: base#wild-integer-string?
  << string[address, length] -- bool >>
  128 allocate-local-memory
  >:string-address
  tuck
  :string-address
  string->buffer!
  :string-address swap
  "_" string-head,byte
  remove-char!
  >:new-string-length
  >:new-string-address
  << dup2 .s .l 0 end >>
  :new-string-address
  :new-string-length
  "#" string-head,byte
  string,find-char if
  else
    false
    end
  then
  >:address-of-#
  :new-string-address
  :address-of-# :new-string-address sub
  >::base-string
  :address-of-# add1
  :address-of-# :new-string-address sub add1
  :new-string-length swap sub
  >::wild-integer-string
  ::base-string digit-string?
  ::base-string empty-string? not
  and if
  else
    false
    end
  then
  ::wild-integer-string wild-integer-string?
  ::wild-integer-string empty-string? not
  and if
    true
  else
    false
  then
  end
; define-function

: base#wild-integer-string->base-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string-head,byte
  string,find-char if
  else
    "* (base#wild-integer-string->base-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address
  :address-of-# :address sub
  end
; define-function

: base#wild-integer-string->wild-integer-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string-head,byte
  string,find-char if
  else
    "* (base#wild-integer-string->wild-integer-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address-of-# add1
  :address-of-# :address sub add1
  :length swap sub
  end
; define-function

: wild-integer-string->integer,with-base,loop
  << string[address, length], base, sum, counter -- integer >>
  >:counter
  >:sum
  >:base
  >:length
  >:address
  :length zero? if
    :sum
    end
  then
  :address fetch-byte >:char
  :char digit-char? if
    :char digit-char->number
  then
  :char latin-char? if
    :char latin-char->number
  then
  :base :counter power
  mul
  :sum add
  >:sum
  :address add1
  :length sub1
  :base
  :sum
  :counter add1
  loop
; define-function

: wild-integer-string->integer,with-base
  << string[address, length], base -- integer >>
  >:base
  dup zero? if
    drop2
    0
    end
  then
  dup2 string-head,byte
  "-" string-head,byte
  equal? if
    string-tail,byte
    -1 >:sign
  else
    1 >:sign
  then
  >::string
  ::string string-reverse!
  :base
  0 0 wild-integer-string->integer,with-base,loop
  :sign mul
  ::string string-reverse!
  drop2
  end
; define-function

: base#wild-integer-string->integer
  << string[address, length] -- integer >>
  128 allocate-local-memory
    >:address
  tuck :address string->buffer!
    >:length
  :address :length
  "_" string-head,byte remove-char!
    >::string
  ::string
  base#wild-integer-string->base-string
    >::base-string
  ::string
  base#wild-integer-string->wild-integer-string
    >::wild-integer-string
  ::base-string
  digit-string->number
    >:base
  ::wild-integer-string
  :base
  wild-integer-string->integer,with-base
  end
; define-function

: .#,loop
  << number, base, cursor -- cursor >>
  >:cursor
  >:base
  >:number
  :number zero? if
    :cursor
    end
  then
  :number
  :base
  divmod >:mod >:div
  :mod 10 less-than? if
    :mod number->digit-char
  else
    :mod number->latin-char
  then
  :cursor
  save-byte
  :div
  :base
  :cursor add1
  loop
; define-function

: .#
  << integer, base -- >>
  over zero? if
    drop .i
    end
  then
  dup 36 greater-than?
  over 2 less-than?
  or if
    "* (.#) the base " .s .i " is not valid to write a number" .s .l
    "  a base should in between 2 and 36 includingly" .s .l
    "  the integer to be written is " .s .i .l
    end
  then
  dup .i
  "#" .s
  over negative? if
    swap negate swap
    "-" .s
  then
  128 allocate-local-memory >:buffer
  :buffer
  .#,loop >:cursor
  :buffer
  :cursor :buffer sub
  string-reverse! .s
  end
; define-function

: .#2  2  .# " " .s end ; define-function
: .#8  8  .# " " .s end ; define-function
: .#16 16 .# " " .s end ; define-function

: number->gamber
  << number -- gamber >>
  dup 1 bit-right
  bit-xor
  end
; define-function

: gamber->number,loop
  << gamber, number, cursor -- number >>
  dup negative? if
    drop
    swap drop
    end
  then
  >:cursor
  >:number
  >:gamber
  :gamber :cursor get-bit
  :number :cursor add1 get-bit
  xor if
    :number :cursor set-bit >:number
  then
  :gamber
  :number
  :cursor sub1
  loop
; define-function

: gamber->number
  << gamber -- number >>
  dup find-highest-set-bit
  dup negative? if
    drop
    end
  then
  0 over set-bit
  swap sub1
  gamber->number,loop
  end
; define-function

: syntax,base#wild-integer-string,make-jojo
  << string[address, length], word[address, length] --
     string[address, length] >>
  jo instruction,literal
    jojo-area,stay
  base#wild-integer-string->integer
    jojo-area,stay
  end
; define-function

: more,rule-set,make-jojo
  << -- >>
  jo base#wild-integer-string?
  jo syntax,base#wild-integer-string,make-jojo
  *rule-set,make-jojo* add-rule
  end
; define-function

more,rule-set,make-jojo

1024 *jo-size* mul
: *size,rule-set,basic-REPL*
; define-variable,with-tos

<< for cursor >>
*jo-size* allocate-memory drop

*size,rule-set,basic-REPL*
allocate-memory
: *rule-set,basic-REPL*
; define-variable,with-tos

*rule-set,basic-REPL*
*rule-set,basic-REPL* *jo-size* sub
save

: eval-word
  << word[address, length] -- unknown >>
  dup2 find-syntax if
    apply
    end
  then
  dup2
  name-hash-table,find-jo if
    dup exception-jo? if
      drop
      "* (eval-word) can not execute exception directly : " .s
      .s .l
      end
    then
    << function & primitive-function & variable >>
    xx|swap|x drop2
    apply
    end
  else
  "* (eval-word) meets undefined word : " .s
  .s .l
  then
  end
; define-function

: word:bye?
  << word[address, length] -- bool >>
  "bye" string-equal?
  end
; define-function

: !bye,basic-REPL
  << -- >>
  exception-reset-stack
  drop-syntax-stack
  end
; define-exception

: syntax,bye,basic-REPL
  << word:bye -- >>
  drop2
  !bye,basic-REPL
; define-function

: basic-REPL,loop
  << unknown -- unknown >>
  read-word-for-REPL
  eval-word
  loop
; define-function

: basic-REPL
  << unknown -- unknown >>
  prepare-for
    !bye,basic-REPL
    end
  *rule-set,basic-REPL* push-syntax-stack
  basic-REPL,loop
  end
; define-function

basic-REPL

: word:jo?
  << word[address, length] -- bool >>
  "jo" string-equal?
  end
; define-function

: syntax,jo,basic-REPL
  << word:jo -- >>
  drop2
  read-word-for-REPL
  >::word
  ::word name-hash-table,find-jo if
    end
  then
  "* (syntax,jo,basic-REPL) meet undefined word after jo : " .s ::word .s .l
  end
; define-function

: init,rule-set,basic-REPL
  << -- >>
  jo integer-string? jo string->integer       *rule-set,basic-REPL* add-rule
  jo word:bye?       jo syntax,bye,basic-REPL *rule-set,basic-REPL* add-rule
  jo word:jo?        jo syntax,jo,basic-REPL  *rule-set,basic-REPL* add-rule
  jo base#wild-integer-string? jo base#wild-integer-string->integer *rule-set,basic-REPL* add-rule
  end
; define-function

init,rule-set,basic-REPL

: syntax,if,basic-REPL,meet-true,else
  << -- >>
  read-word-for-REPL
  "then" string-equal? if
    end
  then
  loop
; define-function

: syntax,if,basic-REPL,meet-true
  << -- >>
  read-word-for-REPL
  dup2 "then" string-equal? if
    drop2
    end
  then
  dup2 "else" string-equal? if
    drop2
    syntax,if,basic-REPL,meet-true,else
    end
  then
  eval-word
  loop
; define-function

: syntax,if,basic-REPL,meet-false,else
  << -- >>
  read-word-for-REPL
  dup2 "then" string-equal? if
    drop2
    end
  then
  eval-word
  loop
; define-function

: syntax,if,basic-REPL,meet-false
  << -- >>
  read-word-for-REPL
  dup2 "then" string-equal? if
    drop2
    end
  then
  dup2 "else" string-equal? if
    drop2
    syntax,if,basic-REPL,meet-false,else
    end
  then
  drop2
  loop
; define-function

: syntax,if,basic-REPL
  << bool, word:if -- >>
  drop2 if
    syntax,if,basic-REPL,meet-true
  else
    syntax,if,basic-REPL,meet-false
  then
  end
; define-function

jo word:if? jo syntax,if,basic-REPL *rule-set,basic-REPL* add-rule

1024 1024 mul
: *circular-string-area,size*
; define-variable,with-tos


*circular-string-area,size* allocate-memory
: *circular-string-area*
; define-variable,with-tos

*circular-string-area*
: *circular-string-area,current-free-address*
; define-variable,with-tos

: circular-string-area,stay
  << string[address, length] -- >>
  dup *circular-string-area,current-free-address* add
  *circular-string-area,size* *circular-string-area* add
  greater-or-equal? if
    *circular-string-area*
    save-to *circular-string-area,current-free-address*
  then
  tuck
  *circular-string-area,current-free-address*
  string->buffer!
  address *circular-string-area,current-free-address*
  add-save
  0 *circular-string-area,current-free-address*
  save-byte
  1 address *circular-string-area,current-free-address*
  add-save
  end
; define-function

: syntax,double-quote,basic-REPL,loop
  << cursor -- cursor >>
  read-byte
  dup 34 equal? if
    drop
    end
  then
  over save-byte
  add1
  loop
; define-function

: syntax,double-quote,basic-REPL
  << word:double-quote -- string[address, length] >>
  drop2
  1024 2 mul allocate-local-memory >:buffer
  :buffer
  syntax,double-quote,basic-REPL,loop
  >:cursor
  *circular-string-area,current-free-address* >:address
  :buffer
  :cursor :buffer sub dup >:length
  circular-string-area,stay
  :address
  :length
  end
; define-function

jo word:double-quote? jo syntax,double-quote,basic-REPL *rule-set,basic-REPL* add-rule

0
: *syntax,address,basic-REPL,stack-balancer*
; define-variable,with-tos

: syntax,address,basic-REPL
  << word:address -- address >>
  drop2
  read-word-for-REPL
  >::word
  ::word name-hash-table,find-jo if
  else
    "* (syntax,address,basic-REPL) meet undefined word : " .s ::word .s .l
    address *syntax,address,basic-REPL,stack-balancer*
    end
  then
  >:jo
  :jo variable-jo? if
  else
    "* (syntax,address,basic-REPL) meet a not variable-jo : " .s ::word .s .l
    address *syntax,address,basic-REPL,stack-balancer*
    end
  then
  :jo *jo-size* add
  end
; define-function

jo word:address?
jo syntax,address,basic-REPL
*rule-set,basic-REPL* add-rule

: syntax,save-to,basic-REPL
  << value, word:address -- address >>
  drop2
  read-word-for-REPL
  >::word
  ::word name-hash-table,find-jo if
  else
    "* (syntax,save-to,basic-REPL) meet undefined word : " .s ::word .s .l
    "  the value " .s .i " is saved to no where" .s .l
    end
  then
  >:jo
  :jo variable-jo? if
  else
    "* (syntax,save-to,basic-REPL) meet a not variable-jo : " .s ::word .s .l
    "  the value " .s .i " is saved to no where" .s .l
    end
  then
  :jo *jo-size* add
  save
  end
; define-function

jo word:save-to?
jo syntax,save-to,basic-REPL
*rule-set,basic-REPL* add-rule

: print-argument-stack,loop
  << address, counter -- >>
  dup zero? if
    drop2
    end
  then
  sub1 swap
    dup fetch .
  *jo-size* add
  swap
  loop
; define-function

: print-argument-stack
  << -- >>
  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot*
  *the-stack* greater-or-equal? if
    *the-stack*   << address as return value >>
    *the-stack-pointer-snapshot* *the-stack* sub
    *jo-size* div << counter as return value >>
    print-argument-stack,loop
    end
  then
  "below the stack " .s
  end
; define-function

: print-argument-stack,pretty
  << -- >>
  snapshot-the-stack-pointer
  .l
  "  * " .s
     *the-stack-pointer-snapshot*
     *the-stack* sub
     << ad hoc for the BUG of div >>
     dup negative? if
       negate
       *jo-size* div
       negate
     else
       *jo-size* div
     then
     .i
  " * " .s
  " -- " .s
    print-argument-stack
  "--" .s
  .l
  end
; define-function

: stack-REPL,loop
  << unknown -- unknown >>
  read-word-for-REPL
  eval-word
  print-argument-stack,pretty
  loop
; define-function

: stack-REPL
  << unknown -- unknown >>
  prepare-for
    !bye,basic-REPL
    end
  *rule-set,basic-REPL* push-syntax-stack
  stack-REPL,loop
  end
; define-function

jo stack-REPL save-to *lost-exception-REPL*

: list-rule,loop
  << rule-set, cursor, counter -- >>
  xx|over|x equal? if
    drop drop2
    end
  then
  "  * " .s
  "(" .s
  add1 dup .i
  ")" .s .l
  swap
    dup cursor->predicate
    "    " .s jo->name-string .s .l
    dup cursor->function
    "    " .s jo->name-string .s .l
    *jo-size* sub *jo-size* sub
  swap
  loop
; define-function

: list-rule
  << rule-set -- >>
  dup rule-set,fetch-border
  0 list-rule,loop
  end
; define-function

: sub-rule,move-one
  << cursor -- >>
  >:cursor
  :cursor 2 n-fetch
  :cursor *jo-size* 2 mul sub
  2 n-save
  end
; define-function

: sub-rule,move
  << rule-set, cursor -- >>
  >:cursor
  >:rule-set
  :rule-set rule-set,fetch-border >:border
  :cursor :border equal? if
    :border *jo-size* 2 mul sub
    :rule-set
    rule-set,save-border
    end
  then
  :cursor sub-rule,move-one
  :rule-set
  :cursor *jo-size* 2 mul add
  loop
; define-function

: sub-rule,loop
  << rule[predicate, function], rule-set, cursor -- >>
  >:cursor
  >:rule-set
  >::rule
  :cursor :rule-set equal? if
    end
  then
  ::rule :cursor cursor->rule equal2? if
    :rule-set :cursor
    sub-rule,move
    end
  then
  ::rule
  :rule-set
  :cursor *jo-size* 2 mul sub
  loop
; define-function

: sub-rule
  << rule[predicate, function], rule-set -- >>
  dup rule-set,fetch-border
  sub-rule,loop
  end
; define-function

: eval-string,loop
  << unknown -- unknown >>
  tos-reading-stack space-string? if
    end
  then
  read-word-for-REPL
  eval-word
  loop
; define-function

: eval-string
  << string[address, length] -- unknown >>
  push-reading-stack
  eval-string,loop
  drop-reading-stack
  end
; define-function

: syntax,double-quote,define-variable,loop
  << cursor -- cursor >>
  read-byte
  dup 34 equal? if
    drop
    end
  then
  over save-byte
  add1
  loop
; define-function

: syntax,double-quote,define-variable
  << word:double-quote -- string[address, length] >>
  drop2
  1024 2 mul allocate-local-memory >:buffer
  :buffer
  syntax,double-quote,define-variable,loop
  >:cursor
  :buffer
  :cursor :buffer sub
  make-string
  end
; define-function

: define-variable
  << string[address, length] -- >>
  >::string
  ::string string-head,word >::name
  ::string string-tail,word >::body

  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot* >:old-snapshot

  jo word:double-quote?
  jo syntax,double-quote,define-variable
  *rule-set,basic-REPL* add-rule

  ::body eval-string

  jo word:double-quote?
  jo syntax,double-quote,define-variable
  *rule-set,basic-REPL* sub-rule

  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot* >:new-snapshot

  :new-snapshot :old-snapshot sub

  dup negative? if
    negate *jo-size* div
    "* (define-variable) fail to define variable : " .s ::name .s .l
    "  because after eval the following body" .s .l
    "  the stack is " .s .i " below what it use to be" .s .l
    ::body .s .l
    end
  then
  dup zero? if
    drop
    "* (define-variable) fail to define variable : " .s ::name .s .l
    "  because after eval the following body" .s .l
    "  the stack is still where it use to be" .s .l
    ::body .s .l
    end
  then

  *jo-size* div >:length

  ::name make-string >::name

  ::name *link* 0
  make-link >:link

  :link save-to *link*

  ::name *explainer,variable* 0
  make-jo-head >:jo

  :jo :link link,save-jo

  :jo name-hash-table,save-jo

  :length
  :jo jo,save-length

  *jojo-area,current-free-address*
  :length
  n-save

  :length *jo-size* mul
  address *jojo-area,current-free-address*
  add-save
  end
; define-function

: word:square-bar?
  << word[address, length] -- bool >>
  "[" string-equal?
  end
; define-function

: word:square-ket?
  << word[address, length] -- bool >>
  "]" string-equal?
  end
; define-function

: syntax,square-bar,make-jojo
  << jo, string[address, length], word:square-bar --
     jo, string[address, length] >>
  drop2
  >::string

  jo instruction,branch
    jojo-area,stay
  *jojo-area,current-free-address* >:address,offset
  0 jojo-area,stay

  "" *explainer,function* 0
  make-jo-head >:jo

  ::string "]" string,find-word if
  else
    end
  then
  ::string swap drop over sub >:length
  >::string,found
  ::string drop :length >::body

     ::body .s .l
     ::string,found .s .l

  :jo ::body make-jojo

  *jojo-area,current-free-address*
  :address,offset sub

     dup .i .l

  *jo-size* div

     dup .i .l

  :address,offset save

  jo instruction,literal
    jojo-area,stay
  :jo
    jojo-area,stay

  ::string,found string-tail,word
  end
; define-function

jo word:square-bar?
jo syntax,square-bar,make-jojo
*rule-set,make-jojo* add-rule

*jo-size* 4 equal? if
  5   : :syscall-number,open:       ; define-variable,with-tos
  6   : :syscall-number,close:      ; define-variable,with-tos
  3   : :syscall-number,read:       ; define-variable,with-tos
  4   : :syscall-number,write:      ; define-variable,with-tos
  9   : :syscall-number,link:       ; define-variable,with-tos
  10  : :syscall-number,unlink:     ; define-variable,with-tos
  39  : :syscall-number,mkdir:      ; define-variable,with-tos
  40  : :syscall-number,rmdir:      ; define-variable,with-tos
  141 : :syscall-number,getdents:   ; define-variable,with-tos
  220 : :syscall-number,getdents64: ; define-variable,with-tos
  106 : :syscall-number,stat:       ; define-variable,with-tos
  1   : :syscall-number,exit:       ; define-variable,with-tos
  43  : :syscall-number,times:      ; define-variable,with-tos
  20  : :syscall-number,getpid:     ; define-variable,with-tos
  183 : :syscall-number,getcwd:     ; define-variable,with-tos
  12  : :syscall-number,chdir:      ; define-variable,with-tos
then

*jo-size* 8 equal? if
  2   : :syscall-number,open:       ; define-variable,with-tos
  3   : :syscall-number,close:      ; define-variable,with-tos
  0   : :syscall-number,read:       ; define-variable,with-tos
  1   : :syscall-number,write:      ; define-variable,with-tos
  86  : :syscall-number,link:       ; define-variable,with-tos
  87  : :syscall-number,unlink:     ; define-variable,with-tos
  83  : :syscall-number,mkdir:      ; define-variable,with-tos
  84  : :syscall-number,rmdir:      ; define-variable,with-tos
  78  : :syscall-number,getdents:   ; define-variable,with-tos
  217 : :syscall-number,getdents64: ; define-variable,with-tos
  4   : :syscall-number,stat:       ; define-variable,with-tos
  60  : :syscall-number,exit:       ; define-variable,with-tos
  100 : :syscall-number,times:      ; define-variable,with-tos
  39  : :syscall-number,getpid:     ; define-variable,with-tos
  79  : :syscall-number,getcwd:     ; define-variable,with-tos
  80  : :syscall-number,chdir:      ; define-variable,with-tos
then

: error-code->string
  << error-code -- string[address, length] >>
  dup -1  equal? if drop  << EPERM   >>   "Operation not permitted " end then
  dup -2  equal? if drop  << ENOENT  >>   "No such file or directory " end then
  dup -3  equal? if drop  << ESRCH   >>   "No such process " end then
  dup -4  equal? if drop  << EINTR   >>   "Interrupted system call " end then
  dup -5  equal? if drop  << EIO     >>   "I/O error " end then
  dup -6  equal? if drop  << ENXIO   >>   "No such device or address " end then
  dup -7  equal? if drop  << E2BIG   >>   "Argument list too long " end then
  dup -8  equal? if drop  << ENOEXEC >>   "Exec format error " end then
  dup -9  equal? if drop  << EBADF   >>   "Bad file number " end then
  dup -10 equal? if drop  << ECHILD  >>   "No child processes " end then
  dup -11 equal? if drop  << EAGAIN  >>   "Try again " end then
  dup -12 equal? if drop  << ENOMEM  >>   "Out of memory " end then
  dup -13 equal? if drop  << EACCES  >>   "Permission denied " end then
  dup -14 equal? if drop  << EFAULT  >>   "Bad address " end then
  dup -15 equal? if drop  << ENOTBLK >>   "Block device required " end then
  dup -16 equal? if drop  << EBUSY   >>   "Device or resource busy " end then
  dup -17 equal? if drop  << EEXIST  >>   "File exists " end then
  dup -18 equal? if drop  << EXDEV   >>   "Cross-device link " end then
  dup -19 equal? if drop  << ENODEV  >>   "No such device " end then
  dup -20 equal? if drop  << ENOTDIR >>   "Not a directory " end then
  dup -21 equal? if drop  << EISDIR  >>   "Is a directory " end then
  dup -22 equal? if drop  << EINVAL  >>   "Invalid argument " end then
  dup -23 equal? if drop  << ENFILE  >>   "File table overflow " end then
  dup -24 equal? if drop  << EMFILE  >>   "Too many open files " end then
  dup -25 equal? if drop  << ENOTTY  >>   "Not a typewriter " end then
  dup -26 equal? if drop  << ETXTBSY >>   "Text file busy " end then
  dup -27 equal? if drop  << EFBIG   >>   "File too large " end then
  dup -28 equal? if drop  << ENOSPC  >>   "No space left on device " end then
  dup -29 equal? if drop  << ESPIPE  >>   "Illegal seek " end then
  dup -30 equal? if drop  << EROFS   >>   "Read-only file system " end then
  dup -31 equal? if drop  << EMLINK  >>   "Too many links " end then
  dup -32 equal? if drop  << EPIPE   >>   "Broken pipe " end then
  dup -33 equal? if drop  << EDOM    >>   "Math argument out of domain of func " end then
  dup -34 equal? if drop  << ERANGE  >>   "Math result not representable " end then
  "unknow error-code : " .s .i .l
  "* (error-code->string) fail" << to balance the argument-stack >>
  end
; define-function

: file-type-code->string
  << file-type-code -- string[address, length] >>
  dup 1  equal?  << DT_FIFO  >>  if drop "named pipe i.e. FIFO"  end then
  dup 2  equal?  << DT_CHR   >>  if drop "character device"      end then
  dup 4  equal?  << DT_DIR   >>  if drop "directory"             end then
  dup 6  equal?  << DT_BLK   >>  if drop "block device"          end then
  dup 8  equal?  << DT_REG   >>  if drop "regular file"          end then
  dup 10 equal?  << DT_LNK   >>  if drop "symbolic link"         end then
  dup 12 equal?  << DT_SOCK  >>  if drop "UNIX domain socket"    end then
  drop
  "unknow file type"
  end
; define-function

: link,list-by-jo-predicate,loop
  << jo-predicate, counter, link -- >>
  dup zero? if
    drop
    drop
    drop
    end
  then
  dup link->jo
  x|over|xxx apply false? if
    link->next-link
    loop
  then
  swap
    "  " .s
    add1 dup .i ". " .s
  swap
  dup link->jo jo->name-string
  dup2 space-string? if
    drop2
    "  unnamed" .s .l
  else
    .s .l
  then
  link->next-link
  loop
; define-function

: link,list-by-jo-predicate
  << link, jo-predicate -- >>
  swap
  0
  swap
  link,list-by-jo-predicate,loop
  end
; define-function

: input-port,open
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  0 <<
  O_RDONLY
  >>
  :syscall-path
  :syscall-number,open:
  2 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: output-port,creat
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#1102 <<
  O_RDWR   0002
  O_CREAT  0100
  O_TRUNC  1000
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: output-port,update
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  110100100b
  >>
  8#1002 <<
  O_RDWR   0002
  O_TRUNC  1000
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port,close
  << port
     -- true
     -- error-code, false >>
  :syscall-number,close:
  1 syscall
  dup
  negative? if
    false
    end
  then
  drop true
  end
; define-function

: port,read
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  :syscall-number,read:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port,write
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  :syscall-number,write:
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: file,creat
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#0200
  8#0100 bit-or <<
  O_EXCL   0200
  O_CREAT  0100
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    "* (file,creat) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  port,close if
    end
  then
  "* (file,creat) fail to close port for the following path :" .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: file,write
  << string[address, length], path[address, length] -- >>
  >::path
  >::string
  ::path
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#1002 <<
  O_RDWR   0002
  O_TRUNC  1000
  >>
  :syscall-path
  :syscall-number,open:
  3 syscall
  dup
  negative? if
    "* (file,write) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:port
  ::string swap
  :port
  :syscall-number,write:
  3 syscall
  dup
  negative? if
    "* (file,write) fail to write port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:counter << bytes been written >>
  :port
  port,close if
    end
  then
  "* (file,write) fail to close port for the following path : " .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: file,read
  << string[address, max-length], path[address, length] -- counter >>
  >::path
  >::string
  ::path
  string->syscall-string
  >:syscall-path
  0 <<
  O_RDONLY
  >>
  :syscall-path
  :syscall-number,open:
  2 syscall
  dup
  negative? if
    "* (file,read) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    0
    end
  then
  >:port
  ::string swap
  :port
  :syscall-number,read:
  3 syscall
  dup
  negative? if
    "* (file,read) fail to read port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    0
    end
  then
  >:counter << bytes been readed >>
  :port
  port,close if
    :counter
    end
  then
  "* (file,read) fail to close port for the following path : " .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  0
  end
; define-function

: file,remove
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  :syscall-path
  :syscall-number,unlink:
  1 syscall
  dup
  negative? if
    "* (file,remove) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

: directory,creat
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  8#755 <<
  2#111101101
  >>
  :syscall-path
  :syscall-number,mkdir:
  2 syscall
  dup
  negative? if
    "* (directory,creat) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

: directory,remove
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  :syscall-path
  :syscall-number,rmdir:
  1 syscall
  dup
  negative? if
    "* (directory,remove) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

0 : +getdents64,d_ino+        ; define-variable,with-tos
0 : +getdents64,d_off+        ; define-variable,with-tos
0 : +getdents64,d_reclen+     ; define-variable,with-tos
0 : +getdents64,d_type+       ; define-variable,with-tos
0 : +getdents64,d_name+       ; define-variable,with-tos
0 : +getdents64,end+          ; define-variable,with-tos

: init,getdents64
  << offset -- >>
  *jo-size* 4 equal? if
    dup save-to +getdents64,d_ino+        8 add
    dup save-to +getdents64,d_off+        8 add
    dup save-to +getdents64,d_reclen+     2 add
    dup save-to +getdents64,d_type+       1 add
    dup save-to +getdents64,d_name+       256 add
        save-to +getdents64,end+
    end
  then
  *jo-size* 8 equal? if
    dup save-to +getdents64,d_ino+        8 add
    dup save-to +getdents64,d_off+        8 add
    dup save-to +getdents64,d_reclen+     2 add
    dup save-to +getdents64,d_type+       1 add
    dup save-to +getdents64,d_name+       256 add
        save-to +getdents64,end+
    end
  then
  end
; define-function

0 init,getdents64
+getdents64,end+ : +getdents64,length+ ; define-variable,with-tos

: empty-directory?
  << path[address, length] -- bool >>
  >::path
  ::path input-port,open if
  else
    "* (empty-directory?) fail to open : " .s ::path .s .l
    "  " .s error-code->string .s .l
    false
    end
  then
  >:port
  128 allocate-local-memory >:getdents64-structure-list
  128
  :getdents64-structure-list
  :port
  :syscall-number,getdents64:
  3 syscall
  48 equal? << this call to equal? returns the needed bool >>
  :port port,close if
    end
  then
  "* (empty-directory?) fail to close : " .s ::path .s .l
  "  " .s error-code->string .s .l
  false
  end
; define-function

: directory,map,loop,execute
  << end, cursor, function -- >>
  >:function
  dup2 less-or-equal? if
    drop2
    end
  then
  >:cursor
  >:end
  :cursor init,getdents64
  :function apply
  :end
  :cursor +getdents64,d_reclen+ fetch-two-bytes add
  :function
  loop
; define-function

: directory,map,loop
  << port, function -- >>
  >:function
  >:port
  1024 allocate-local-memory >:getdents64-structure-list
  1024
  :getdents64-structure-list
  :port
  :syscall-number,getdents64:
  3 syscall
  dup negative? if
    "* (directory,map,loop) syscall fail" .s .l
    "  " .s error-code->string .s .l
    end
  then
  dup zero? if
    drop
    end
  then
  :getdents64-structure-list add
  :getdents64-structure-list
  :function
  directory,map,loop,execute
  :port
  :function
  loop
; define-function

: directory,map
  << directory-path[address, length],
     function
     -- true
     -- false >>
  >:function
  >::directory-path
  ::directory-path input-port,open if
  else
    "* (directory,map) fail to open : " .s ::directory-path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:port
  :port :function directory,map,loop
  :port port,close if
    end
  then
  "* (directory,map) fail to close : " .s ::directory-path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: directory,list-file,lister
  << -- >>
  +getdents64,d_type+ fetch-byte
  8 equal? if
    "  " .s
    +getdents64,d_name+
    dup 256
    0 string,find-char
    drop  << drop 0 >>
    over sub .s .l
  then
  end
; define-function

: directory,list-file
  << directory-path[address, length] -- >>
  jo directory,list-file,lister
  directory,map
  end
; define-function

: directory,list-directory,lister
  << -- >>
  +getdents64,d_type+ fetch-byte
  4 equal? if
    +getdents64,d_name+
    dup 256
    0 string,find-char
    drop  << drop 0 >>
    over sub >::name
    ".." ::name string-equal? if
      end
    then
    "." ::name string-equal? if
      end
    then
    "  " .s ::name .s .l
    end
  then
  end
; define-function

: directory,list-directory
  << directory-path[address, length] -- >>
  jo directory,list-directory,lister
  directory,map
  end
; define-function

: directory,find-file,finder
  << file-name[address, length], bool --
     file-name[address, length], bool >>
  +getdents64,d_type+ fetch-byte 8 equal? not if
    end
  then
  >:bool
  >:file-name,lenght
  >:file-name,address
  :file-name,lenght +getdents64,d_name+ add
  fetch-byte zero? not if
    :file-name,address
    :file-name,lenght
    :bool
    end
  then
  :file-name,address :file-name,lenght
  +getdents64,d_name+ :file-name,lenght
  string-equal? if
    :file-name,address
    :file-name,lenght
    true
    end
  then
  :file-name,address
  :file-name,lenght
  :bool
  end
; define-function

: directory,find-file
  << directory-path[address, length], file-name[address, length] -- bool >>
  xx|swap|xx
  false
  xx|swap|x
  jo directory,find-file,finder
  directory,map
  xx|swap|x drop2
  end
; define-function

: directory,find-directory,finder
  << file-name[address, length], bool --
     file-name[address, length], bool >>
  +getdents64,d_type+ fetch-byte 4 equal? not if
    end
  then
  >:bool
  >:file-name,lenght
  >:file-name,address
  :file-name,lenght +getdents64,d_name+ add
  fetch-byte zero? not if
    :file-name,address
    :file-name,lenght
    :bool
    end
  then
  :file-name,address :file-name,lenght
  +getdents64,d_name+ :file-name,lenght
  string-equal? if
    :file-name,address
    :file-name,lenght
    true
    end
  then
  :file-name,address
  :file-name,lenght
  :bool
  end
; define-function

: directory,find-directory
  << directory-path[address, length], file-name[address, length] -- bool >>
  xx|swap|xx
  false
  xx|swap|x
  jo directory,find-directory,finder
  directory,map
  xx|swap|x drop2
  end
; define-function

0 : *pid* ; define-variable,with-tos

: init-pid
  << -- >>
  :syscall-number,getpid:
  0 syscall
  save-to *pid*
  end
; define-function

: get-pid
  << -- pid >>
  *pid*
  end
; define-function

512 allocate-memory
: *address,command-line*
; define-variable,with-tos

512
: *length,command-line*
; define-variable,with-tos

: init-command-line
  << -- >>
  64 allocate-local-memory >:path-buffer
  :path-buffer >:cursor

  get-pid write-number,fill-buffer >::pid-string

  "/proc/" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  ::pid-string dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  "/cmdline" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  :path-buffer
  :cursor :path-buffer sub dup2 >::path
  input-port,open if
  else
    "* (init-command-line) fail to open : " .s ::path .s .l
    end
  then
  >:port

  *address,command-line*
  *length,command-line*
  :port
  port,read if
  else
    "* (init-command-line) fail to read : " .s ::path .s .l
    end
  then
  save-to *length,command-line*
  end
; define-function

: get-command-line
  << -- string[address, length] >>
  *address,command-line* *length,command-line*
  end
; define-function

1024 4 mul allocate-memory
: *address,environment-variable-list*
; define-variable,with-tos

1024 4 mul
: *length,environment-variable-list*
; define-variable,with-tos

: init-environment-variable-list
  << -- >>
  64 allocate-local-memory >:path-buffer
  :path-buffer >:cursor

  get-pid write-number,fill-buffer >::pid-string

  "/proc/" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  ::pid-string dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  "/environ" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  :path-buffer
  :cursor :path-buffer sub dup2 >::path
  input-port,open if
  else
    "* (init-environment-variable-list) fail to open : " .s ::path .s .l
    end
  then
  >:port

  *address,environment-variable-list*
  *length,environment-variable-list*
  :port
  port,read if
  else
    "* (init-environment-variable-list) fail to read : " .s ::path .s .l
    end
  then
  save-to *length,environment-variable-list*
  end
; define-function

: get-environment-variable-list
  << -- string[address, length] >>
  *address,environment-variable-list*
  *length,environment-variable-list*
  end
; define-function

: find-environment-variable,loop
  << string[address, length], cursor
     -- string[address, length], true
     -- false >>
  dup
  get-environment-variable-list add
  greater-than? if
    drop drop2
    false
    end
  then
  >:cursor
  >:length
  >:address
  :address :cursor :length
  compare-buffer not if
    :address :length
    :cursor 0 cursor->next-matching-byte add1
    loop
  then
  :cursor :length add fetch-byte
  "=" string-head,byte
  equal? not if
    :address :length
    :cursor 0 cursor->next-matching-byte add1
    loop
  then
  :cursor :length add add1 << over "=" >>
  >:find-address
  :find-address 0 cursor->next-matching-byte
  :find-address sub >:find-length
  :find-address
  :find-length
  end
; define-function

: find-environment-variable
  << string[address, length]
     -- string[address, length], true
     -- false >>
  get-environment-variable-list drop
  find-environment-variable,loop
  end
; define-function

init-pid
init-command-line
init-environment-variable-list

: *home-directory*
  "HOME" find-environment-variable
; define-variable

: report-environment-variable,loop
  << environment-variable-list[address, length]-- >>
  dup2 space-string? if
    drop2
    end
  then

  >:length
  >:address

  :address :length 0 string,find-char drop add1 >:cursor
  :cursor :address sub >:length-of-one-variable

  :address
  :length-of-one-variable sub1 .s .l

  :cursor
  :length :length-of-one-variable sub
  loop
; define-function

: report-environment-variable
  << -- >>
  get-environment-variable-list
  report-environment-variable,loop
  end
; define-function

: report-command-line,loop
  << command-line[address, length] -- >>
  dup2 space-string? if
    drop2
    end
  then
  dup2 string-head,word .s 32 .b
  string-tail,word
  loop
; define-function

: report-command-line
  << -- >>
  get-command-line
  report-command-line,loop
  end
; define-function

512 allocate-memory
: *buffer,work-directory*
; define-variable,with-tos

: get-work-directory
  << -- directory[address, length] >>
  512
  *buffer,work-directory*
  :syscall-number,getcwd:
  2 syscall
  dup negative? if
    "* (get-work-directory) fail" .s .l
    "  " .s error-code->string .s .l
    end
  then
  *buffer,work-directory*
  swap
  sub1 << for the ending zero >>
  end
; define-function

: change-work-directory
  << directory-path[address, length] -- >>
  >::directory-path
  ::directory-path
  string->syscall-string
  :syscall-number,chdir:
  1 syscall
  dup negative? if
    "* (change-work-directory) fail" .s .l
    "  can not change the work directory into : " .s ::directory-path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

0 : +stat,st_dev+        ; define-variable,with-tos
0 : +stat,st_ino+        ; define-variable,with-tos
0 : +stat,st_mode+       ; define-variable,with-tos
0 : +stat,st_nlink+      ; define-variable,with-tos
0 : +stat,st_uid+        ; define-variable,with-tos
0 : +stat,st_gid+        ; define-variable,with-tos
0 : +stat,st_rdev+       ; define-variable,with-tos
0 : +stat,st_size+       ; define-variable,with-tos
0 : +stat,st_blksize+    ; define-variable,with-tos
0 : +stat,st_blocks+     ; define-variable,with-tos
0 : +stat,st_atime+      ; define-variable,with-tos
0 : +stat,st_atime_nsec+ ; define-variable,with-tos
0 : +stat,st_mtime+      ; define-variable,with-tos
0 : +stat,st_mtime_nsec+ ; define-variable,with-tos
0 : +stat,st_ctime+      ; define-variable,with-tos
0 : +stat,st_ctime_nsec+ ; define-variable,with-tos
0 : +stat,__unused4+     ; define-variable,with-tos
0 : +stat,__unused5+     ; define-variable,with-tos
0 : +stat,end+           ; define-variable,with-tos

: init,stat
  << offset -- >>
  *jo-size* 4 equal? if
    dup save-to +stat,st_dev+         *jo-size* add
    dup save-to +stat,st_ino+         *jo-size* add
    dup save-to +stat,st_mode+        2 add
    dup save-to +stat,st_nlink+       2 add
    dup save-to +stat,st_uid+         2 add
    dup save-to +stat,st_gid+         2 add
    dup save-to +stat,st_rdev+        *jo-size* add
    dup save-to +stat,st_size+        *jo-size* add
    dup save-to +stat,st_blksize+     *jo-size* add
    dup save-to +stat,st_blocks+      *jo-size* add
    dup save-to +stat,st_atime+       *jo-size* add
    dup save-to +stat,st_atime_nsec+  *jo-size* add
    dup save-to +stat,st_mtime+       *jo-size* add
    dup save-to +stat,st_mtime_nsec+  *jo-size* add
    dup save-to +stat,st_ctime+       *jo-size* add
    dup save-to +stat,st_ctime_nsec+  *jo-size* add
    dup save-to +stat,__unused4+      *jo-size* add
    dup save-to +stat,__unused5+      *jo-size* add
        save-to +stat,end+
    end
  then
  *jo-size* 8 equal? if
    dup save-to +stat,st_dev+         *jo-size* add
    dup save-to +stat,st_ino+         *jo-size* add
    <<
    note the following order changing
    this is linux' bad
    >>
    dup save-to +stat,st_nlink+       8 add
    dup save-to +stat,st_mode+        4 add

    dup save-to +stat,st_uid+         4 add
    dup save-to +stat,st_gid+         4 add
                                          4 add << padding >>
    dup save-to +stat,st_rdev+        *jo-size* add
    dup save-to +stat,st_size+        *jo-size* add
    dup save-to +stat,st_blksize+     *jo-size* add
    dup save-to +stat,st_blocks+      *jo-size* add
    dup save-to +stat,st_atime+       *jo-size* add
    dup save-to +stat,st_atime_nsec+  *jo-size* add
    dup save-to +stat,st_mtime+       *jo-size* add
    dup save-to +stat,st_mtime_nsec+  *jo-size* add
    dup save-to +stat,st_ctime+       *jo-size* add
    dup save-to +stat,st_ctime_nsec+  *jo-size* add
    dup save-to +stat,__unused4+      *jo-size* add
    dup save-to +stat,__unused5+      *jo-size* add
        save-to +stat,end+
    end
  then
  end
; define-function

0 init,stat
+stat,end+ : +stat,length+ ; define-variable,with-tos

: path,nothing?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  :syscall-number,stat:
  2 syscall
  -2 equal?
  end
; define-function

: path,file?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  :syscall-number,stat:
  2 syscall
  dup
  negative? if
    drop
    false
    end
  then
  drop
  :stat-structure init,stat
  *jo-size* 4 equal? if
    +stat,st_mode+
    fetch-two-bytes
  then
  *jo-size* 8 equal? if
    +stat,st_mode+
    fetch-four-bytes
  then
  12 bit-right
  8#0010
  equal?
  <<
  0170000
  S_IFDIR       0040000 /* Directory.  */
  S_IFCHR       0020000 /* Character device.  */
  S_IFBLK       0060000 /* Block device.  */
  S_IFREG       0100000 /* Regular file.  */
  S_IFIFO       0010000 /* FIFO.  */
  S_IFLNK       0120000 /* Symbolic link.  */
  S_IFSOCK      0140000 /* Socket.  */
  >>
  end
; define-function

: path,directory?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  :syscall-number,stat:
  2 syscall
  dup
  negative? if
    drop
    false
    end
  then
  drop
  :stat-structure init,stat
  *jo-size* 4 equal? if
    +stat,st_mode+
    fetch-two-bytes
  then
  *jo-size* 8 equal? if
    +stat,st_mode+
    fetch-four-bytes
  then
  12 bit-right
  8#0004
  equal?
  <<
  0170000
  S_IFDIR       00040000 /* Directory.  */
  S_IFCHR       00020000 /* Character device.  */
  S_IFBLK       00060000 /* Block device.  */
  S_IFREG       00100000 /* Regular file.  */
  S_IFIFO       00010000 /* FIFO.  */
  S_IFLNK       00120000 /* Symbolic link.  */
  S_IFSOCK      00140000 /* Socket.  */
  >>
  end
; define-function

: relative-path?
  << string[address, length] -- bool >>
  dup zero? if
    drop2
    false
    end
  then
  string-head,byte
  47 equal? not
  end
; define-function

: full-path?
  << string[address, length] -- bool >>
  dup zero? if
    drop2
    false
    end
  then
  string-head,byte
  47 equal?
  end
; define-function

: *poi-directory,user,address*
  512 allocate-memory
; define-variable

: *poi-directory*
  *home-directory* "/.cicada/poi"
  *poi-directory,user,address*
  2 n-string->buffer!
  *poi-directory,user,address* swap
; define-variable

: poi,find
  << name[address, length]
     -- path[address, length], true
     -- false >>
  >::name
  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  path,file? not if
    false
    end
  then

  512 allocate-local-memory >:read-buffer
  :read-buffer 512
  :buffer :length
  file,read >:read-length

  *circular-string-area,current-free-address*
  >:path-address

  :read-buffer :read-length
  circular-string-area,stay

  :path-address
  :read-length
  true
  end
; define-function

: poi,add
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path relative-path? not if
    "* (poi,add) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path,directory? not if
    "* (poi,add) the argument must be a relative-path to a existing directory" .s .l
    "  but the following path is not to a directory : " .s ::relative-path .s .l
    end
  then

  ::name poi,find if
    "* (poi,add) can not add" .s .l
    "  for the following poi already exist : " .s ::name .s .l
    "  name is use as the following directory's name : " .s .s .l
    end
  then

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory,creat

  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer!
  >:length
  :buffer :length
  file,creat

  512 allocate-local-memory >:address,full-path
  get-work-directory "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file,write
  end
; define-function

: poi,sub
  << name[address, length] -- >>
  >::name

  ::name poi,find not if
    "* (poi,sub) can not sub" .s .l
    "  for the following poi does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  file,remove

  *poi-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory,remove
  end
; define-function

: poi,up
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path relative-path? not if
    "* (poi,up) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path,directory? not if
    "* (poi,up) the argument must be a relative-path to a existing directory" .s .l
    "  but the following directory is not exist : " .s ::relative-path .s .l
    end
  then

  ::name poi,find not if
    "* (poi,up) can not up" .s .l
    "  for the following poi does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  512 allocate-local-memory >:address,full-path
  get-work-directory "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file,write
  end
; define-function

: poi,list,lister
  << -- >>
  +getdents64,d_type+ fetch-byte
  4 equal? if
    512 allocate-local-memory >:path-buffer
    +getdents64,d_name+
    dup 256
    0 string,find-char
    drop  << drop 0 >>
    over sub >::name

    ".." ::name string-equal? if
      end
    then

    "." ::name string-equal? if
      end
    then

    "  * " .s ::name .s .l
    "      " .s

    *poi-directory* "/" ::name "/path"
    :path-buffer
    4 n-string->buffer! >:path-length

    512 allocate-local-memory >:reading-buffer
    :reading-buffer 512
    :path-buffer :path-length
    file,read >:reading-length

    :reading-buffer :reading-length
    .s .l
  then
  end
; define-function

: poi,list
  << -- >>
  *poi-directory*
  jo poi,list,lister
  directory,map
  end
; define-function

: poi,help
  << -- >>
  "* (poi,help)" .s .l
  "  * cn poi add  <new-name> <relative-path-to-existing-directory>" .s .l
  "  * cn poi sub  <old-name>" .s .l
  "  * cn poi up   <old-name> <relative-path-to-existing-directory>" .s .l
  "  * cn poi find <old-name>" .s .l
  "  * cn poi list" .s .l
  end
; define-function

: +word+?
  << string[address, length] -- bool >>
  dup 1 less-or-equal? if
    drop2
    false
    end
  then
  over fetch-byte
  "+" string-head,byte equal? not if
    drop2
    false
    end
  then
  add sub1 fetch-byte
  "+" string-head,byte equal?
  end
; define-function

: +word+->word
  << +word+[address, length] -- name[address, length] >>
  sub2 swap
  add1 swap
  end
; define-function

: word:path:?
  << word[address, length] -- bool >>
  "path:" string-equal?
  end
; define-function

: bad-path-syntax-word,loop
  << -- >>
  read-word-for-REPL
  dup2 ";" string-equal? if
    .s 32 .b
    end
  then
  .s 32 .b
  loop
; define-function

: !bad-path-syntax-word
  << word -- >>
  "* (!bad-path-syntax-word) the following word is of bad syntax : " .s .l
  "    " .s .s .l
  exception-reset-stack
  << -- >>
  "  the rest of the words in path syntax is as following :" .s .l
  "    " .s bad-path-syntax-word,loop .l
  end
; define-exception

: path-syntax-word->path
  << word[address, length] -- path[address, length] >>
  >::word
  ::word "+root+" string-equal? if
    "/"
    end
  then
  ::word "+work+" string-equal? if
    get-work-directory
    end
  then
  ::word "+home+" string-equal? if
    *home-directory*
    end
  then
  ::word "+back+" string-equal? if
    ".."
    end
  then
  ::word +word+? not if
    ::word
    end
  then
  ::word +word+->word poi,find if
    end
  then
  ::word
  !bad-path-syntax-word
; define-function

: syntax,path:,basic-REPL,loop
  << cursor -- cursor >>
  >:cursor
  read-word-for-REPL >::word

  ";" ::word string-equal? if
    :cursor
    end
  then

  ::word path-syntax-word->path dup >:length
  :cursor
  string->buffer!

  :cursor :length add
    dup
    "/" string-head,byte
    swap
    save-byte
  add1
  loop
; define-function

: syntax,path:,basic-REPL
  << word:path: -- path[address, length] >>
  drop2

  prepare-for
    !bad-path-syntax-word
    end

  512 allocate-local-memory >:buffer
  :buffer syntax,path:,basic-REPL,loop >:cursor

  :cursor :buffer sub >:length

  *circular-string-area,current-free-address*
  >:address

  :buffer
  :length
  circular-string-area,stay

  :address
  :length
  end
; define-function

jo word:path:?
jo syntax,path:,basic-REPL
*rule-set,basic-REPL* add-rule

: <undo-stack> mark-undo-point
  << -- >>

  end
; define-function

: report-memory
  << -- >>
  "* *un-initialized-memory*" .s .l
  "  * size : " .s
       *un-initialized-memory,size*
       . .l
  "  * used : " .s
       *un-initialized-memory,current-free-address*
       *un-initialized-memory*
       sub . .l
  "  * free : " .s
       *un-initialized-memory,size*
       *un-initialized-memory,current-free-address*
       *un-initialized-memory*
       sub sub . .l
  "* *string-area*" .s .l
  "  * size : " .s
       *string-area,size*
       . .l
  "  * used : " .s
       *string-area,current-free-address*
       *string-area*
       sub . .l
  "  * free : " .s
       *string-area,size*
       *string-area,current-free-address*
       *string-area*
       sub sub . .l
  "* *jojo-area*" .s .l
  "  * size : " .s
       *jojo-area,size* . .l
  "  * used : " .s
       *jojo-area,current-free-address*
       *jojo-area*
       sub . .l
  "  * free : " .s
       *jojo-area,size*
       *jojo-area,current-free-address*
       *jojo-area*
       sub sub . .l
  end
; define-function

: report-platform
  << -- >>
  "* platform : " .s
  platform .s
  .l
  end
; define-function

: report-jo-size
  << -- >>
  "* jo-size : " .s
  *jo-size* write-number
  " bytes" .s
  .l
  end
; define-function

: report-machine-word-size
  << -- >>
  "* machine-word-size : " .s
  *jo-size* 8 mul write-number
  " bits" .s
  .l
  end
; define-function

: report-syntax
  << -- >>
  "* *rule-set,make-jojo* :" .s .l
   *rule-set,make-jojo* list-rule
  "* *rule-set,basic-REPL* :" .s .l
   *rule-set,basic-REPL* list-rule
  "* tos-syntax-stack :" .s .l
   tos-syntax-stack list-rule
  end
; define-function

: report-link
  << -- >>
  "* all primitive-function in link :" .s .l
  *link* jo primitive-function-jo?
  link,list-by-jo-predicate

  "* all function in link :" .s .l
  *link* jo function-jo?
  link,list-by-jo-predicate

  "* all exception in link :" .s .l
  *link* jo exception-jo?
  link,list-by-jo-predicate

  "* all variable in link :" .s .l
  *link* jo variable-jo?
  link,list-by-jo-predicate
  end
; define-function

: initial-report
  << -- >>
  "* initial-report : " .s .l
  "  " .s report-platform
  "  " .s report-machine-word-size
  "  " .s report-jo-size
  end
; define-function

: welcome
  << -- >>
  "* welcome to cicada-nymph" .s .l
  end
; define-function

0
: *hi,random-base*
; define-variable,with-tos

: hi,random
  << -- random-number >>
  0 :syscall-number,times:
  1 syscall
  9 mod
  <<
   *hi,random-base*
   *hi,random-base* add1 13 mod
   address *hi,random-base* save
  >>
  end
; define-function

: hi,say
  << number -- >>
  dup 0 equal? if drop "  cica cica da yaya !!!" .s .l end then
  dup 1 equal? if drop "  hi ^-^" .s .l end then
  dup 2 equal? if drop "  hello :)" .s .l end then
  dup 3 equal? if drop "  hey *^-^*" .s .l end then
  dup 4 equal? if drop "  hiya \^o^/" .s .l end then
  dup 5 equal? if drop "  I wish you a lovely day" .s .l end then
  dup 6 equal? if drop "  I wish you a lovely day { or night :P }" .s .l end then
  dup 7 equal? if drop "  o.o" .s .l end then
                  drop "  lovely ^3^" .s .l end
; define-function

: hi
  << -- >>
  hi,random
  hi,say
  end
; define-function

: help
  << -- >>
  "* helpful documentations will be written soon" .s .l
  "  please wait ^-^" .s .l
  end
; define-function

: command-line,unknow-function
  << -- >>
  "* (cicada-nymph) unknow command-line-function : " .s
  get-command-line
  string-tail,word
  string-head,word .s .l
  "  good bye ^-^/" .s .l
  bye
; define-function

: command-line,stack-REPL
  << -- >>
  .l
  welcome hi .l
  initial-report .l
  "* you are in the (stack-REPL)" .s .l
  "  every time after a word is executed" .s .l
  "  the argument-stack get printed" .s .l
  print-argument-stack,pretty
  jo stack-REPL
  reset-top-level-REPL
; define-function

: command-line,basic-REPL
  << -- >>
  .l
  welcome hi .l
  initial-report .l
  "* you are in the (basic-REPL)" .s .l
  "  this REPL does not print any thing automaticly" .s .l
  jo basic-REPL
  reset-top-level-REPL
; define-function

: command-line,poi
  << -- >>
  get-command-line
  string-tail,word
  string-tail,word >::command-line

  ::command-line space-string? if
    poi,help
    bye
  then

  ::command-line string-head,word >::sub-function-name
  ::command-line string-tail,word >::command-line-arguments

  ::sub-function-name "help" string-equal? if
    poi,help
    bye
  then

  ::sub-function-name "add" string-equal? if
    ::command-line-arguments string-head,word
    ::command-line-arguments string-tail,word string-head,word
    poi,add
    bye
  then

  ::sub-function-name "sub" string-equal? if
    ::command-line-arguments string-head,word
    poi,sub
    bye
  then

  ::sub-function-name "up" string-equal? if
    ::command-line-arguments string-head,word
    ::command-line-arguments string-tail,word string-head,word
    poi,up
    bye
  then

  ::sub-function-name "find" string-equal? if
    ::command-line-arguments string-head,word
    poi,find if
      .s .l
    else
      "no found" .s .l
    then
    bye
  then

  ::sub-function-name "list" string-equal? if
    poi,list
    bye
  then

  "* (poi) meets argument that (poi) can not understand" .s .l
  "  it is the following command-line that is confusing (poi) :" .s .l
  "    " .s report-command-line .l
  "  to get some help info  you can type :" .s .l
  "    cn poi help" .s .l
  "  good bye ^-^/" .s .l
  bye
; define-function

: command-line,no-function
  << -- >>
  command-line,stack-REPL
  end
; define-function

: command-line-dispatcher
  << -- >>
  get-command-line
  string-tail,word
  dup2 space-string? if
    drop2
    command-line,no-function
    end
  then
  string-head,word
  >::1st-word
  ::1st-word "basic-REPL" string-equal? if
    command-line,basic-REPL
    end
  then
  ::1st-word "stack-REPL" string-equal? if
    command-line,stack-REPL
    end
  then
  ::1st-word "poi" string-equal? if
    command-line,poi
    end
  then
  command-line,unknow-function
  end
; define-function

: the-story-begin
  << -- >>
  command-line-dispatcher
  end
; define-function

the-story-begin
