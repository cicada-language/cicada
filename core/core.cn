: .l
  << -- >>
  10 write-byte
  end
; define-function

: .i
  << -- >>
  write-integer
  end
; define-function

: .b
  << byte -- >>
  write-byte
  end
; define-function

: literal-word:if?
  << word[address, length] -- bool >>
  "if" string:equal?
  end
; define-function

: literal-word:else?
  << word[address, length] -- bool >>
  "else" string:equal?
  end
; define-function

: literal-word:then?
  << word[address, length] -- bool >>
  "then" string:equal?
  end
; define-function

: jojo-compiler-syntax:if
  << jo, string[address, length], literal-word:if --
     address, jo, string[address, length] >>
  drop2
  jo instruction,false?branch
    jojo-area,stay
  *jojo-area,current-free-address* xxx|swap|x
  0 jojo-area,stay
  end
; define-function

: jojo-compiler-syntax:else
  << address, jo, string[address, length], literal-word:else --
     address, jo, string[address, length] >>
  drop2
  jo instruction,branch
     jojo-area,stay
  x|swap|xxx
  *jojo-area,current-free-address* xxxx|swap|x
  0 jojo-area,stay
  << address, string[address, length], address >>
  *jojo-area,current-free-address*
  over sub *cell-size* div
  swap set
  end
; define-function

: jojo-compiler-syntax:then
  << address, jo, string[address, length], literal-word:then --
     jo, string[address, length] >>
  drop2
  x|swap|xxx
  *jojo-area,current-free-address*
  over sub *cell-size* div
  swap set
  end
; define-function

: literal-word:loop?
  << word[address, length] -- bool >>
  "loop" string:equal?
  end
; define-function

: jojo-compiler-syntax:loop
  << jo, string[address, length], literal-word:loop --
     jo, string[address, length] >>
  drop2
  jo tail-call
    jojo-area,stay
  x|over|xx
    jojo-area,stay
  end
; define-function

: literal-word:recur?
  << word[address, length] -- bool >>
  "recur" string:equal?
  end
; define-function

: jojo-compiler-syntax:recur
  << jo, string[address, length], literal-word:recur --
     jo, string[address, length] >>
  drop2
  x|over|xx
    jojo-area,stay
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  dup jo literal-word:if?    jo jojo-compiler-syntax:if    syntax-rule:add
  dup jo literal-word:else?  jo jojo-compiler-syntax:else  syntax-rule:add
  dup jo literal-word:then?  jo jojo-compiler-syntax:then  syntax-rule:add
  dup jo literal-word:loop?  jo jojo-compiler-syntax:loop  syntax-rule:add
      jo literal-word:recur? jo jojo-compiler-syntax:recur syntax-rule:add
  end
; define-function
more,syntax-rule-set:jojo-compiler

: allocate-memory
  << size -- address >>
  dup *un-initialized-memory,current-free-address* clear-memory
  *un-initialized-memory,current-free-address* swap << address as return value >>
  address *un-initialized-memory,current-free-address* add-set
  end
; define-function

100333
<< drop 13 >>
: *name-hash-table,size*
; define-variable,with-tos

*cell-size* 5 mul
: *name-hash-table,unit*
; define-variable,with-tos

*name-hash-table,size*
*name-hash-table,unit* mul allocate-memory
: *name-hash-table*
; define-variable,with-tos

0
: *name-hash-table,counter*
; define-variable,with-tos

*name-hash-table,size* 32 mul
: *name-hash-table,string-area,size*
; define-variable,with-tos

*name-hash-table,string-area,size*
allocate-memory
: *name-hash-table,string-area*
; define-variable,with-tos

*name-hash-table,string-area*
: *name-hash-table,string-area,current-free-address*
; define-variable,with-tos

: name-hash-table,string-area,stay
  << string[address, length] -- >>
  tuck
  *name-hash-table,string-area,current-free-address*
  string->buffer!
  address *name-hash-table,string-area,current-free-address*
  add-set
  end
; define-function

: make-string,for-name
  << string[address, length] -- string-copy[address, length] >>
  *name-hash-table,string-area,current-free-address*
  xx|swap|x
  tuck
  name-hash-table,string-area,stay
  end
; define-function

: name->address
  << name -- address >>
  *name-hash-table,unit* mul
  *name-hash-table* add
  end
; define-function

: name,used?
  << name -- bool >>
  name->address
  get zero? false?
  end
; define-function

: name,used-as-jo?
  << name -- bool >>
  name->address
  *cell-size* 4 mul add
  get zero? not
  end
; define-function

: name->string
  << name -- string[address, length] >>
  name->address
  2 n-get
  end
; define-function

: name,get-orbit-length
  << name -- orbit-length >>
  name->address
  *cell-size* 2 mul add
  get
  end
; define-function

: name,get-orbiton
  << name -- orbiton >>
  name->address
  *cell-size* 3 mul add
  get
  end
; define-function

: name,get-jo
  << name -- jo >>
  name->address
  *cell-size* 4 mul add
  get
  end
; define-function

: name,set-string
  << string[address, length], name -- >>
  >:name
  make-string,for-name
  :name name->address
  2 n-set
  end
; define-function

: name,set-orbit-length
  << orbit-length, name -- >>
  name->address
  *cell-size* 2 mul add
  set
  end
; define-function

: name,set-orbiton
  << orbiton, name -- >>
  name->address
  *cell-size* 3 mul add
  set
  end
; define-function

: name,set-jo
  << jo, name -- >>
  name->address
  *cell-size* 4 mul add
  set
  end
; define-function

: name,no-collision?
  << name -- bool >>
  dup name,get-orbiton
  equal?
  end
; define-function

: name-hash-table,hash
  << number, counter -- index >>
  add *name-hash-table,size* mod
  end
; define-function

16
: *max-carry-position*
; define-variable,with-tos

: string->finite-carry-sum,loop
  << carry-sum, string[address, length], counter -- carry-sum >>
  over zero? if
    drop drop2
    end
  then
  dup *max-carry-position* greater-than? if
    drop 0 << re-start from 0 >>
  then
  xx|over|x
  string:byte over
  2 swap power
  mul
  x|swap|xxxx add xxx|swap|x
  add1 xx|swap|x
  string:byte-tail x|swap|xx
  loop
; define-function

: string->finite-carry-sum
  << string[address, length] -- carry-sum >>
  0 xx|swap|x << carry-sum >>
  0 << counter >>
  string->finite-carry-sum,loop
  end
; define-function

: name-hash-table,search,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    :name false
    end
  then
  :name name->string
  ::string string:equal? if
    :name true
    end
  then
  :name name,get-orbit-length
  :counter equal? if
    :name false
    end
  then
  ::string
  :number :counter add1
  loop
; define-function

: name-hash-table,search
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,search,loop
  end
; define-function

: name-hash-table,insert,loop
  << string[address, length], number, counter
     -- name, true
     -- name, false >>
  >:counter >:number >::string
  :number :counter name-hash-table,hash
  >:name
  :number 0 name-hash-table,hash
  >:orbit
  :name name,used? false? if
    ::string :name
    name,set-string
    :orbit :name
    name,set-orbiton
    :counter :orbit
    name,set-orbit-length
    1 address *name-hash-table,counter* add-set
    :name true
    end
  then
  :name name->string
  ::string string:equal? if
    :name true
    end
  then
  :counter *name-hash-table,size* equal? if
    :name false
    end
  then
  ::string
  :number
  :counter add1
  loop
; define-function

: name-hash-table,insert
  << string[address, length]
     -- name, true
     -- name, false >>
  dup2 string->finite-carry-sum
  0 name-hash-table,insert,loop
  end
; define-function

: string->name
  << string[address, length] -- name >>
  name-hash-table,insert
  false? if
    "* (string->name) *name-hash-table* is full!" .s .l
    end
  then
  end
; define-function

: name-hash-table,report,orbit
  << name, counter -- >>
  over name,get-orbit-length
  over less-than? if
    drop2
    end
  then
  over name->string string->finite-carry-sum
  over name-hash-table,hash
  dup name,get-orbiton
  << name, counter, new-name, orbiton >>
  x|over|xxx name->string string->finite-carry-sum
  0 name-hash-table,hash
  equal? if
    "  {" .s
    dup write-number
    "} " .s
    name->string .s
    .l
  else
    drop
  then
  add1
  loop
; define-function

: name-hash-table,report,loop
  << name -- >>
  dup *name-hash-table,size* equal? if
    drop
    end
  then
  dup name,used? if
  dup name,no-collision? if
    << * {index} string # orbit-lenght >>
    "* {" .s
    dup write-number
    "} " .s
    dup name->string .s
    " # " .s
    dup name,get-orbit-length
    write-number
    .l
    dup 1 name-hash-table,report,orbit
  then
  then
  add1
  loop
; define-function

: name-hash-table,report
  << -- >>
  0 name-hash-table,report,loop
  "* totally : " .s
  *name-hash-table,counter* write-number
  .l
  end
; define-function

: name-hash-table,find-jo
  << word[address, length]
     -- jo, true
     -- false >>
  name-hash-table,search if
  else
    drop
    false
    end
  then
  dup name,used-as-jo? if
    name,get-jo
    true
    end
  then
  drop
  false
  end
; define-function

100 1024 mul
: global-naming-stack:*size*
; define-variable,with-tos

3 *cell-size* mul
: global-naming-stack:*unit*
; define-variable,with-tos

global-naming-stack:*size*
global-naming-stack:*unit* mul allocate-memory
: *global-naming-stack*
; define-variable,with-tos

*global-naming-stack*
: global-naming-stack:*pointer*
; define-variable,with-tos

: name-record:get-old-jo
  << name-record -- old-jo >>
  get
  end
; define-function

: name-record:set-old-jo
  << old-jo, name-record -- >>
  set
  end
; define-function

: name-record:get-name
  << name-record -- name >>
  *cell-size* add get
  end
; define-function

: name-record:set-name
  << name, name-record -- >>
  *cell-size* add set
  end
; define-function

: name-record:get-new-jo
  << name-record -- new-jo >>
  *cell-size* 2 mul add get
  end
; define-function

: name-record:set-new-jo
  << new-jo, name-record -- >>
  *cell-size* 2 mul add set
  end
; define-function

: global-naming-stack:record-jo
  << jo, name -- >>
  dup name,get-jo
  global-naming-stack:*pointer* name-record:set-old-jo
  dup2 name,set-jo
  global-naming-stack:*pointer* name-record:set-name
  global-naming-stack:*pointer* name-record:set-new-jo
  global-naming-stack:*unit* address global-naming-stack:*pointer* add-set
  end
; define-function

: global-naming-stack:delete-last-record
  << -- >>
  global-naming-stack:*unit*
  address global-naming-stack:*pointer*
  sub-set
  global-naming-stack:*pointer* name-record:get-old-jo
  global-naming-stack:*pointer* name-record:get-name
  name,set-jo
  end
; define-function

: jo,find-name,loop
  << jo, current-record
     -- name, true
     -- false >>
  dup *global-naming-stack* equal? if
    drop2
    false
    end
  then
  global-naming-stack:*unit* sub
  dup >:name-record
  over
  :name-record name-record:get-new-jo equal? if
    drop2
    :name-record name-record:get-name
    true
    end
  then
  loop
; define-function

: jo,find-name
  << jo
     -- name, true
     -- false >>
  global-naming-stack:*pointer*
  jo,find-name,loop
  end
; define-function

: name-hash-table,record-jo,by-link
  << link -- >>
  >:link
  :link link->jo
  :link link->name-string string->name
  global-naming-stack:record-jo
  end
; define-function

: quote-word?
  << word[address, length] -- bool >>
  dup 1 less-or-equal? if
    drop2
    false
    end
  then
  string:byte "'" string:byte equal?
  end
; define-function

: jojo-compiler-syntax:quote
  << string[address, length], word[address, length] --
     string[address, length] >>
  jo instruction,literal
    jojo-area,stay
  string:byte-tail string->name
    jojo-area,stay
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  jo quote-word? jo jojo-compiler-syntax:quote syntax-rule:add
  end
; define-function
more,syntax-rule-set:jojo-compiler

10 1024 mul
: scope-stack:*size*
; define-variable,with-tos

2 *cell-size* mul
: scope-stack:*unit*
; define-variable,with-tos

scope-stack:*size*
scope-stack:*unit* mul allocate-memory
: *scope-stack*
; define-variable,with-tos

*scope-stack*
: scope-stack:*pointer*
; define-variable,with-tos

: offset-record,get-name
  << offset-record -- name >>
  get
  end
; define-function

: offset-record,set-name
  << name, offset-record -- >>
  set
  end
; define-function

: offset-record,get-offset
  << offset-record -- offset >>
  *cell-size* add get
  end
; define-function

: offset-record,set-offset
  << offset, offset-record -- >>
  *cell-size* add set
  end
; define-function

: offset-record,scope-delimiter?
  << offset-record -- bool >>
  offset-record,get-name zero?
  end
; define-function

: scope-stack:find,loop
  << name, cursor
     -- offset-record, true
     -- false >>
  dup *scope-stack* equal? if
    drop2
    false
    end
  then
  scope-stack:*unit* sub >:cursor
  >:name
  :cursor offset-record,get-name
  :name equal? if
    :cursor
    true
    end
  then
  :name
  :cursor
  loop
; define-function

: scope-stack:find
  << name
     -- offset-record, true
     -- false >>
  scope-stack:*pointer*
  scope-stack:find,loop
  end
; define-function

: scope-stack:get-current-offset
  << -- offset >>
  *scope-stack* scope-stack:*pointer* equal? if
    "* (scope-stack:get-current-offset) fail" .s .l
    "  for the scope-stack is empty" .s .l
    end
  then
  scope-stack:*pointer*
  scope-stack:*unit* sub
  dup offset-record,scope-delimiter? if
    drop
    0
    end
  then
  dup
  offset-record,get-name
  name->string count-front-colon *cell-size* mul
  swap
  offset-record,get-offset
  add
  end
; define-function

10 1024 mul
: awaiting-stack:*size*
; define-variable,with-tos

4 *cell-size* mul
: awaiting-stack:*unit*
; define-variable,with-tos

awaiting-stack:*size*
awaiting-stack:*unit* mul allocate-memory
: *awaiting-stack*
; define-variable,with-tos

*awaiting-stack*
: awaiting-stack:*pointer*
; define-variable,with-tos

: action,get-function
  << action -- function >>
  get
  end
; define-function

: action,set-function
  << function, action -- >>
  set
  end
; define-function

: action,get-argument-stack-pointer
  << action -- argument-stack-pointer >>
  *cell-size* add get
  end
; define-function

: action,set-argument-stack-pointer
  << argument-stack-pointer, action -- >>
  *cell-size* add set
  end
; define-function

: action,get-return-stack-pointer
  << action -- return-stack-pointer >>
  *cell-size* 2 mul add get
  end
; define-function

: action,set-return-stack-pointer
  << return-stack-pointer, action -- >>
  *cell-size* 2 mul add set
  end
; define-function

: action,get-name
  << action -- name >>
  *cell-size* 3 mul add get
  end
; define-function

: action,set-name
  << name, action -- >>
  *cell-size* 3 mul add set
  end
; define-function

: drop-awaiting-stack
  << -- >>
  awaiting-stack:*unit* address awaiting-stack:*pointer* sub-set
  end
; define-function

: awaiting-stack:find,loop
  << name, cursor
     -- action, true
     -- false >>
  dup *awaiting-stack* equal? if
    drop2
    false
    end
  then
  awaiting-stack:*unit* sub >:cursor
  >:name
  :cursor action,get-name
  :name equal? if
    :cursor
    true
    end
  then
  :name
  :cursor
  loop
; define-function

: awaiting-stack:find
  << name
     -- action, true
     -- false >>
  awaiting-stack:*pointer*
  awaiting-stack:find,loop
  end
; define-function

: await
  << function, name -- >>
  >:name
  >:function

  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot* >:argument-stack-pointer

  get-return-stack-pointer
  return-stack:*unit* 2 mul sub >:return-stack-pointer

  awaiting-stack:*pointer* >:action
  awaiting-stack:*unit* address awaiting-stack:*pointer* add-set

  :function
  :action
  action,set-function

  :argument-stack-pointer
  :action
  action,set-argument-stack-pointer

  :return-stack-pointer
  :action
  action,set-return-stack-pointer

  :name
  :action
  action,set-name

  jo drop-awaiting-stack
  :return-stack-pointer
  return-stack:insert-jo
  end
; define-function

: action,apply
  << action -- >>
  >:action
  :action address awaiting-stack:*pointer* set
  :action action,get-return-stack-pointer
  :action action,get-function
  apply-with-return-point
; define-function

: action,reset-the-stack
  << -- >>
  awaiting-stack:*pointer* action,get-argument-stack-pointer
  set-argument-stack-pointer
  end
; define-function

: awake
  << name -- >>
  >:name
  :name awaiting-stack:find if
    action,apply
    end
  then
  "* (awake) can not find action in awaiting-stack by : " .s :name name->string .s .l
  end
; define-function

1024 *cell-size* mul
: *syntax-rule-set:word-interpreter,size*
; define-variable,with-tos

<< for cursor >>
*cell-size* allocate-memory drop

*syntax-rule-set:word-interpreter,size*
allocate-memory
: syntax-rule-set:*word-interpreter*
; define-variable,with-tos

syntax-rule-set:*word-interpreter*
syntax-rule-set:*word-interpreter* *cell-size* sub
set

: word-interpreter
  << word[address, length] -- unknown >>
  dup2 find-syntax if
    apply
    end
  then
  dup2
  name-hash-table,find-jo if
    << function & primitive-function & variable >>
    xx|swap|x drop2
    apply
    end
  then
  "* (word-interpreter) meets undefined word : " .s
  .s .l
  end
; define-function

: word-interpreter-syntax:bye
  << literal-word:bye -- >>
  drop2
  'bye,basic-REPL awake
; define-function

: bye,basic-REPL
  << -- >>
  action,reset-the-stack
  drop-syntax-stack
  end
; define-function

: basic-REPL,loop
  << unknown -- unknown >>
  read-word
  word-interpreter
  loop
; define-function

: basic-REPL
  << unknown -- unknown >>
  jo bye,basic-REPL
  'bye,basic-REPL await
  syntax-rule-set:*word-interpreter* push-syntax-stack
  basic-REPL,loop
  end
; define-function

: remove-byte!,loop
  << cursor, length, byte -- cursor >>
  >:byte
  >:length
  >:cursor
  :length zero? if
    :cursor
    end
  then
  :cursor get-byte :byte equal? if
    :cursor add1 :length sub1
    :cursor
    string->buffer!
    :cursor
    :length sub1
    :byte
  else
    :cursor add1
    :length sub1
    :byte
  then
  loop
; define-function

: remove-byte!
  << string[address, length], byte -- string[address, length] >>
  x|over|xx >:address
  remove-byte!,loop >:cursor
  :address
  :cursor :address sub
  end
; define-function

: latin-byte?
  << byte -- bool >>
  dup "A" string:byte less-than? if
    drop false
    end
  then
  dup "Z" string:byte less-or-equal? if
    drop true
    end
  then
  dup "a" string:byte less-than? if
    drop false
    end
  then
  dup "z" string:byte less-or-equal? if
    drop true
    end
  then
  drop false
  end
; define-function

: latin-byte->number
  << latin-byte -- number >>
  dup "A" string:byte less-than? if
    "* (latin-byte->number) the argument must be a latin-byte" .s .l
    "  but the following byte is less-than 'A' : " .s
    .i .l
    end
  then
  dup "Z" string:byte less-or-equal? if
    "A" string:byte
    sub
    10 add
    end
  then
  dup "a" string:byte less-than? if
    "* (latin-byte->number) the argument must be a latin-byte" .s .l
    "  but the following byte is less-than 'a' but greater-then 'Z' : " .s
    .i .l
    end
  then
  dup "z" string:byte less-or-equal? if
    "a" string:byte
    sub
    10 add
    end
  then
  "* (latin-byte->number) the argument must be a latin-byte" .s .l
  "  but the following byte is greater-then 'z' : " .s
  .i .l
  end
; define-function

: number->latin-byte
  << number -- latin-byte >>
  10 sub
  "a" string:byte
  add
  end
; define-function

: wild-digit-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 true
    end
  then
  over get-byte
  dup digit-byte?
  swap latin-byte?
  or if
    string:byte-tail
    loop
  then
  drop2
  false
  end
; define-function

: wild-integer-string?
  << string[address, length] -- bool >>
  dup zero? if
    drop2 false
    end
  then
  dup2 string:byte
  "-" string:byte
  equal? if
    string:byte-tail
    wild-digit-string?
    end
  then
  wild-digit-string?
  end
; define-function

: base#wild-integer-string?
  << string[address, length] -- bool >>
  128 allocate-local-memory
  >:string-address
  tuck
  :string-address
  string->buffer!
  :string-address swap
  "_" string:byte
  remove-byte!
  >:new-string-length
  >:new-string-address
  << dup2 .s .l 0 end >>
  :new-string-address
  :new-string-length
  "#" string:byte
  string:find-byte if
  else
    false
    end
  then
  >:address-of-#
  :new-string-address
  :address-of-# :new-string-address sub
  >::base-string
  :address-of-# add1
  :address-of-# :new-string-address sub add1
  :new-string-length swap sub
  >::wild-integer-string
  ::base-string digit-string?
  ::base-string string:empty? not
  and if
  else
    false
    end
  then
  ::wild-integer-string wild-integer-string?
  ::wild-integer-string string:empty? not
  and if
    true
  else
    false
  then
  end
; define-function

: base#wild-integer-string->base-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string:byte
  string:find-byte if
  else
    "* (base#wild-integer-string->base-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address
  :address-of-# :address sub
  end
; define-function

: base#wild-integer-string->wild-integer-string
  << string[address, length] -- string[address, length] >>
  >:length
  >:address
  :address
  :length
  "#" string:byte
  string:find-byte if
  else
    "* (base#wild-integer-string->wild-integer-string)" .s .l
    "  the argument must be a base#wild-integer-string" .s .l
    "  but the following string does not even have a '#' in it :" .s .l
    "  " .s
    :address :length .s .l
    << to balance the argument-stack or not ??? >>
    << :address :length >>
    end
  then
  >:address-of-#
  :address-of-# add1
  :address-of-# :address sub add1
  :length swap sub
  end
; define-function

: wild-integer-string->integer,with-base,loop
  << string[address, length], base, sum, counter -- integer >>
  >:counter
  >:sum
  >:base
  >:length
  >:address
  :length zero? if
    :sum
    end
  then
  :address get-byte >:byte
  :byte digit-byte? if
    :byte digit-byte->number
  then
  :byte latin-byte? if
    :byte latin-byte->number
  then
  :base :counter power
  mul
  :sum add
  >:sum
  :address add1
  :length sub1
  :base
  :sum
  :counter add1
  loop
; define-function

: wild-integer-string->integer,with-base
  << string[address, length], base -- integer >>
  >:base
  dup zero? if
    drop2
    0
    end
  then
  dup2 string:byte
  "-" string:byte
  equal? if
    string:byte-tail
    -1 >:sign
  else
    1 >:sign
  then
  >::string
  ::string string-reverse!
  :base
  0 0 wild-integer-string->integer,with-base,loop
  :sign mul
  ::string string-reverse!
  drop2
  end
; define-function

: base#wild-integer-string->integer
  << string[address, length] -- integer >>
  128 allocate-local-memory
    >:address
  tuck :address string->buffer!
    >:length
  :address :length
  "_" string:byte remove-byte!
    >::string
  ::string
  base#wild-integer-string->base-string
    >::base-string
  ::string
  base#wild-integer-string->wild-integer-string
    >::wild-integer-string
  ::base-string
  digit-string->number
    >:base
  ::wild-integer-string
  :base
  wild-integer-string->integer,with-base
  end
; define-function

: .#,loop
  << number, base, cursor -- cursor >>
  >:cursor
  >:base
  >:number
  :number zero? if
    :cursor
    end
  then
  :number
  :base
  divmod >:mod >:div
  :mod 10 less-than? if
    :mod number->digit-byte
  else
    :mod number->latin-byte
  then
  :cursor
  set-byte
  :div
  :base
  :cursor add1
  loop
; define-function

: .#
  << integer, base -- >>
  over zero? if
    drop .i
    end
  then
  dup 36 greater-than?
  over 2 less-than?
  or if
    "* (.#) the base " .s .i " is not valid to write a number" .s .l
    "  a base should in between 2 and 36 includingly" .s .l
    "  the integer to be written is " .s .i .l
    end
  then
  dup .i
  "#" .s
  over negative? if
    swap negate swap
    "-" .s
  then
  128 allocate-local-memory >:buffer
  :buffer
  .#,loop >:cursor
  :buffer
  :cursor :buffer sub
  string-reverse! .s
  end
; define-function

: .#2  2  .# " " .s end ; define-function
: .#8  8  .# " " .s end ; define-function
: .#16 16 .# " " .s end ; define-function

: init,syntax-rule-set:basic-REPL
  << -- >>
  syntax-rule-set:*word-interpreter*
  dup jo integer-string? jo string->integer syntax-rule:add
      jo base#wild-integer-string? jo base#wild-integer-string->integer syntax-rule:add
  end
; define-function
init,syntax-rule-set:basic-REPL

: jojo-compiler,dispatch-word
  << jo, string[address, length], word[address, length] --
     jo, string[address, length] >>
  dup2 find-syntax if
    apply
    end
  then
  dup2 name-hash-table,find-jo if
    xx|swap|x drop2
    jojo-area,stay
    end
  then
  "* (jojo-compiler) meets undefined word : " .s .s .l
  global-naming-stack:delete-last-record
  'jojo-compiler,dispatch-word,fail awake
; define-function

: jojo-compiler,dispatch-word,fail
  "* (jojo-compiler,dispatch-word,fail)" .s .l
  drop-syntax-stack
  action,reset-the-stack
  << scope-stack-pointer -- >>
  address scope-stack:*pointer* set
  'undo-jojo-compiler awake
; define-function

: jojo-compiler,loop
  << jo, string[address, length] -- >>
  dup2 string:space? if
    drop2
    drop
    end
  then
  dup2
  string:word-tail
  xx|swap|xx
  string:word
  jojo-compiler,dispatch-word
  loop
; define-function

: jojo-compiler
  << jo, string[address, length] -- >>
  >::string
  >:jo

  << this is an ad hoc
  >> local-variable-table,clear

  scope-stack:*pointer* >:scope-stack-pointer
  0 :scope-stack-pointer offset-record,set-name
  0 :scope-stack-pointer offset-record,set-offset
  scope-stack:*unit* address scope-stack:*pointer* add-set

  :scope-stack-pointer

  jo jojo-compiler,dispatch-word,fail
  'jojo-compiler,dispatch-word,fail await

  jojo-compiler:*syntax-rule-set* push-syntax-stack
  :jo ::string jojo-compiler,loop
  drop-syntax-stack

  address scope-stack:*pointer* set
  end
; define-function

: init,name-hash-table,by-link
  << link -- >>
  >:link
  :link zero? if
    end
  then
  :link link->next-link recur
  :link name-hash-table,record-jo,by-link
  end
; define-function

: n-string->buffer!,loop
  << string-1[address, length],
     ...
     string-2[address, length],
     buffer, n, cursor
     -- length >>
  >:cursor
  >:n
  >:buffer
  :n zero? if
    :buffer
    :cursor :buffer sub
    string-reverse!
    swap drop
    end
  then
  dup zero? if
    drop2
    :buffer
    :n sub1
    :cursor
    loop
  then
  dup2 add sub1 get-byte :cursor set-byte
  sub1
  :buffer
  :n
  :cursor add1
  loop
; define-function

: n-string->buffer!
  << string-1[address, length],
     ...
     string-2[address, length],
     buffer, n
     -- length >>
  over n-string->buffer!,loop
  end
; define-function

: undo-jojo-compiler
  action,reset-the-stack
  << *string-area,current-free-address*
     *jojo-area,current-free-address*
     string[address, length] >>
  "  the following jojo is not made :" .s .l
  ":" .s
  .s .l
  ";" .s .l
  address *jojo-area,current-free-address* set
  address *string-area,current-free-address* set
  drop-syntax-stack
  end
; define-function

: define-function
  << string[address, length] -- >>
  *string-area,current-free-address* xx|swap|x
  *jojo-area,current-free-address* xx|swap|x
  << *string-area,current-free-address*
     *jojo-area,current-free-address*
     string[address, length] >>
  jo undo-jojo-compiler
  'undo-jojo-compiler await

  dup2 >::string

  ::string string:word >::name
  ::string string:word-tail >::body

  *explainer,function* 0
  make-jo-head >:jo

  :jo
  ::name string->name
  global-naming-stack:record-jo

  *jojo-area,current-free-address* >:old-address

  :jo ::body jojo-compiler

  *jojo-area,current-free-address*
  :old-address sub *cell-size* div
  :jo jo,set-length

  drop2
  drop
  drop
  end
; define-function

*link* init,name-hash-table,by-link
basic-REPL

: jojo-compiler-syntax:local-variable-get
  << string[address, length], word[address, length] --
     string[address, length] >>
  dup2 string->name scope-stack:find if
    jo instruction,local-variable,n-get
      jojo-area,stay
    << offset >>
    offset-record,get-offset
      jojo-area,stay
    << number >>
    count-front-colon
      jojo-area,stay
    end
  then
  "* (jojo-compiler-syntax:local-variable-get)" .s .l
  "  local-variable not bound : " .s
     .s .l
  'undo-jojo-compiler await
; define-function

: jojo-compiler-syntax:local-variable-set
  << string[address, length], word[address, length] --
     string[address, length] >>
  string:byte-tail
  >::local-variable-name
  ::local-variable-name count-front-colon >:number
  ::local-variable-name string->name >:name

  :name scope-stack:find if
    jo instruction,local-variable,n-set
      jojo-area,stay
    << offset >>
    offset-record,get-offset
      jojo-area,stay
    :number
      jojo-area,stay
    end
  then

  scope-stack:get-current-offset >:current-offset
  :current-offset
  scope-stack:*pointer*
  offset-record,set-offset
  :name
  scope-stack:*pointer*
  offset-record,set-name
  scope-stack:*unit* address scope-stack:*pointer* add-set

  jo instruction,literal
    jojo-area,stay
  :number
    jojo-area,stay
  jo allocate-local-variable
    jojo-area,stay

  jo instruction,local-variable,n-set
    jojo-area,stay
  :current-offset
    jojo-area,stay
  :number
    jojo-area,stay
  end
; define-function

: jojo-compiler-syntax:if
  << jo, string[address, length], literal-word:if --
     scope-stack-pointer,
     address,
     jo, string[address, length] >>
  drop2
  >::string
  >:jo

  jo instruction,false?branch
    jojo-area,stay

  scope-stack:*pointer*
  *jojo-area,current-free-address*
  :jo
  ::string

  0 jojo-area,stay
  end
; define-function

: jojo-compiler-syntax:else
  << scope-stack-pointer,
     address,
     jo, string[address, length], literal-word:else --
     scope-stack-pointer,
     address,
     jo, string[address, length] >>
  drop2
  >::string
  >:jo
  >:address
  >:scope-stack-pointer

  :scope-stack-pointer address scope-stack:*pointer* set

  jo instruction,branch
    jojo-area,stay

  scope-stack:*pointer*
  *jojo-area,current-free-address*
  :jo
  ::string

  0 jojo-area,stay

  <<
  set offset of (instruction,false?branch)
  over (instruction,branch) and its offset
  >>
  *jojo-area,current-free-address* :address sub
  *cell-size* div
  :address set
  end
; define-function

: jojo-compiler-syntax:then
  << scope-stack-pointer,
     address,
     jo, string[address, length], literal-word:then --
     jo, string[address, length] >>
  drop2
  >::string
  >:jo
  >:address
  >:scope-stack-pointer

  *jojo-area,current-free-address* :address sub
  *cell-size* div
  :address set

  :jo
  ::string
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  jo local-variable-get-word?
  jo jojo-compiler-syntax:local-variable-get
  syntax-rule:add
  jojo-compiler:*syntax-rule-set*
  jo local-variable-set-word?
  jo jojo-compiler-syntax:local-variable-set
  syntax-rule:add
  jojo-compiler:*syntax-rule-set*
  dup jo literal-word:if?    jo jojo-compiler-syntax:if    syntax-rule:add
  dup jo literal-word:else?  jo jojo-compiler-syntax:else  syntax-rule:add
      jo literal-word:then?  jo jojo-compiler-syntax:then  syntax-rule:add
  end
; define-function
more,syntax-rule-set:jojo-compiler

: argument-stack:print,loop
  << address, counter -- >>
  dup zero? if
    drop2
    end
  then
  sub1 swap
    dup get .
  *cell-size* add
  swap
  loop
; define-function

: argument-stack:print
  << -- >>
  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot*
  *the-stack* greater-or-equal? if
    *the-stack*   << address as return value >>
    *the-stack-pointer-snapshot* *the-stack* sub
    *cell-size* div << counter as return value >>
    argument-stack:print,loop
    end
  then
  "below the stack " .s
  end
; define-function

: argument-stack:pretty-print
  << -- >>
  snapshot-the-stack-pointer
  .l
  "  * " .s
     *the-stack-pointer-snapshot*
     *the-stack* sub
     << ad hoc for the BUG of div >>
     dup negative? if
       negate
       *cell-size* div
       negate
     else
       *cell-size* div
     then
     .i
  " * " .s
  " -- " .s
    argument-stack:print
  "--" .s
  .l
  end
; define-function

: define-variable,with-tos
  << value, string[address, length] -- >>
  >::string
  >:value

  ::string string:word >::name

  *explainer,variable* 0
  make-jo-head >:jo

  :jo
  ::name string->name
  global-naming-stack:record-jo

  1 :jo jo,set-length

  :value jojo-area,stay
  end
; define-function

: alias
  << alias[address, length], name[address, length] -- >>
  >::name >::alias
  ::name name-hash-table,find-jo if
  else
    "* (alias) fail" .s .l
    "  because can not find name in name-hash-table" .s .l
    "  alias : " .s ::alias .s .l
    "  name : " .s ::name .s .l
    end
  then
  >:jo
  :jo
  ::alias string->name
  global-naming-stack:record-jo
  end
; define-function

: string:find-word
  << string[address, length], word[address, length]
     -- sub-string[address, length], true
     -- false >>
  xx|over|xx string:space? if
    drop2 drop2
    false
    end
  then
  xx|over|xx string:word
  xx|over|xx string:equal? if
    drop2
    true
    end
  then
  xx|swap|xx string:word-tail
  xx|swap|xx
  loop
; define-function

: literal-word:square-bar?
  << word[address, length] -- bool >>
  "[" string:equal?
  end
; define-function

: literal-word:square-ket?
  << word[address, length] -- bool >>
  "]" string:equal?
  end
; define-function

: jojo-compiler-syntax:square-bar
  << jo, string[address, length], literal-word:square-bar --
     scope-stack-pointer,
     offset-address,
     new-jo,
     jo, string[address, length] >>
  drop2
  >::string
  >:jo

  jo instruction,branch
    jojo-area,stay
  *jojo-area,current-free-address* >:offset-address
  0 jojo-area,stay

  *explainer,function* 0
  make-jo-head >:new-jo

  scope-stack:*pointer* >:scope-stack-pointer
  0
  :scope-stack-pointer
  offset-record,set-name
  0
  :scope-stack-pointer
  offset-record,set-offset
  scope-stack:*unit* address scope-stack:*pointer* add-set

  :scope-stack-pointer
  :offset-address
  :new-jo
  :jo
  ::string
  end
; define-function

: jojo-compiler-syntax:square-ket
  << scope-stack-pointer,
     offset-address,
     new-jo,
     jo, string[address, length], literal-word:square-ket --
     jo, string[address, length] >>
  drop2
  >::string
  >:jo
  >:new-jo
  >:offset-address
  >:scope-stack-pointer

  :scope-stack-pointer address scope-stack:*pointer* set

  *jojo-area,current-free-address*
  :offset-address sub
  *cell-size* div
  :offset-address set

  jo instruction,literal
    jojo-area,stay
  :new-jo
    jojo-area,stay

  :jo
  ::string
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  dup jo literal-word:square-bar? jo jojo-compiler-syntax:square-bar syntax-rule:add
      jo literal-word:square-ket? jo jojo-compiler-syntax:square-ket syntax-rule:add
  end
; define-function

more,syntax-rule-set:jojo-compiler

: jojo-compiler-syntax:name
  << string[address, length], word[address, length] --
     string[address, length] >>
  drop2
  jo instruction,literal
    jojo-area,stay
  dup2
  string:word
  string->name
    jojo-area,stay
  string:word-tail
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  ["name" string:equal? end] jo jojo-compiler-syntax:name
  syntax-rule:add
  end
; define-function
more,syntax-rule-set:jojo-compiler

: jojo-compiler-syntax:base#wild-integer-string
  << string[address, length], word[address, length] --
     string[address, length] >>
  jo instruction,literal
    jojo-area,stay
  base#wild-integer-string->integer
    jojo-area,stay
  end
; define-function

: more,syntax-rule-set:jojo-compiler
  << -- >>
  jojo-compiler:*syntax-rule-set*
  jo base#wild-integer-string?
  jo jojo-compiler-syntax:base#wild-integer-string
  syntax-rule:add
  end
; define-function
more,syntax-rule-set:jojo-compiler

: word-interpreter-syntax:jo
  << literal-word:jo -- jo >>
  drop2
  read-word
  >::word
  ::word name-hash-table,find-jo if
    end
  then
  "* (word-interpreter-syntax:jo) meet undefined word after jo : " .s ::word .s .l
  end
; define-function

: more,syntax-rule-set:basic-REPL
  << -- >>
  syntax-rule-set:*word-interpreter*
  ["bye" string:equal? end] jo word-interpreter-syntax:bye
  syntax-rule:add

  syntax-rule-set:*word-interpreter*
  ["jo" string:equal? end] jo word-interpreter-syntax:jo
  syntax-rule:add
  end
; define-function
more,syntax-rule-set:basic-REPL

: word-interpreter-syntax:if,meet-true,else
  << -- >>
  read-word
  "then" string:equal? if
    end
  then
  loop
; define-function

: word-interpreter-syntax:if,meet-true
  << -- >>
  read-word
  dup2 "then" string:equal? if
    drop2
    end
  then
  dup2 "else" string:equal? if
    drop2
    word-interpreter-syntax:if,meet-true,else
    end
  then
  word-interpreter
  loop
; define-function

: word-interpreter-syntax:if,meet-false,else
  << -- >>
  read-word
  dup2 "then" string:equal? if
    drop2
    end
  then
  word-interpreter
  loop
; define-function

: word-interpreter-syntax:if,meet-false
  << -- >>
  read-word
  dup2 "then" string:equal? if
    drop2
    end
  then
  dup2 "else" string:equal? if
    drop2
    word-interpreter-syntax:if,meet-false,else
    end
  then
  drop2
  loop
; define-function

: word-interpreter-syntax:if
  << bool, literal-word:if -- >>
  drop2 if
    word-interpreter-syntax:if,meet-true
  else
    word-interpreter-syntax:if,meet-false
  then
  end
; define-function

syntax-rule-set:*word-interpreter*
jo literal-word:if? jo word-interpreter-syntax:if
syntax-rule:add

1024 1024 mul
: *circular-string-area,size*
; define-variable,with-tos


*circular-string-area,size* allocate-memory
: *circular-string-area*
; define-variable,with-tos

*circular-string-area*
: *circular-string-area,current-free-address*
; define-variable,with-tos

: circular-string-area,stay
  << string[address, length] -- >>
  dup *circular-string-area,current-free-address* add
  *circular-string-area,size* *circular-string-area* add
  greater-or-equal? if
    *circular-string-area*
    address *circular-string-area,current-free-address* set
  then
  tuck
  *circular-string-area,current-free-address*
  string->buffer!
  address *circular-string-area,current-free-address*
  add-set
  0 *circular-string-area,current-free-address*
  set-byte
  1 address *circular-string-area,current-free-address*
  add-set
  end
; define-function

: word-interpreter-syntax:double-quote,loop
  << cursor -- cursor >>
  read-byte
  dup 34 equal? if
    drop
    end
  then
  over set-byte
  add1
  loop
; define-function

: word-interpreter-syntax:double-quote
  << literal-word:double-quote -- string[address, length] >>
  drop2
  1024 2 mul allocate-local-memory >:buffer
  :buffer
  word-interpreter-syntax:double-quote,loop
  >:cursor
  *circular-string-area,current-free-address* >:address
  :buffer
  :cursor :buffer sub dup >:length
  circular-string-area,stay
  :address
  :length
  end
; define-function

syntax-rule-set:*word-interpreter*
jo literal-word:double-quote? jo word-interpreter-syntax:double-quote
syntax-rule:add

: word-interpreter-syntax:address
  << literal-word:address -- address >>
  drop2
  read-word
  >::word

  ::word name-hash-table,find-jo if
  else
    "* (word-interpreter-syntax:address) meet undefined word : " .s ::word .s .l
    end
  then

  >:jo
  :jo variable-jo? if
  else
    "* (word-interpreter-syntax:address) meet a not variable-jo : " .s ::word .s .l
    end
  then
  :jo *cell-size* add
  end
; define-function

syntax-rule-set:*word-interpreter*
jo literal-word:address?
jo word-interpreter-syntax:address
syntax-rule:add

: literal-word:name?
  << word[address, length] -- bool >>
  "name" string:equal?
  end
; define-function

: word-interpreter-syntax:name
  << literal-word:name -- name >>
  drop2
  read-word
  >::word

  ::word string->name
  end
; define-function

syntax-rule-set:*word-interpreter*
jo literal-word:name?
jo word-interpreter-syntax:name
syntax-rule:add

: word-interpreter-syntax:quote
  << quote-word -- name >>
  string:byte-tail string->name
  end
; define-function

syntax-rule-set:*word-interpreter*
jo quote-word?
jo word-interpreter-syntax:quote
syntax-rule:add

: syntax-rule-set:list,loop
  << syntax-rule-set: cursor, counter -- >>
  xx|over|x equal? if
    drop drop2
    end
  then
  "  * " .s
  "(" .s
  add1 dup .i
  ")" .s .l
  swap
    dup syntax-rule:*unit* sub syntax-rule:get-predicate
    "    " .s jo,find-name if name->string else "  unnamed jo" then .s .l
    dup syntax-rule:*unit* sub syntax-rule:get-function
    "    " .s jo,find-name if name->string else "  unnamed jo" then .s .l
    *cell-size* sub *cell-size* sub
  swap
  loop
; define-function

: syntax-rule-set:list
  << syntax-rule-set -- >>
  dup syntax-rule-set:get-border
  0 syntax-rule-set:list,loop
  end
; define-function

: syntax-rule:sub,move-one
  << cursor -- >>
  >:cursor
  :cursor 2 n-get
  :cursor *cell-size* 2 mul sub
  2 n-set
  end
; define-function

: syntax-rule:sub,move
  << syntax-rule-set: cursor -- >>
  >:cursor
  >:syntax-rule-set
  :syntax-rule-set syntax-rule-set:get-border >:border
  :cursor :border equal? if
    :border *cell-size* 2 mul sub
    :syntax-rule-set
    syntax-rule-set:set-border
    end
  then
  :cursor syntax-rule:sub,move-one
  :syntax-rule-set
  :cursor *cell-size* 2 mul add
  loop
; define-function

: syntax-rule:sub,loop
  << syntax-rule-set: syntax-rule[predicate, function], cursor -- >>
  >:cursor
  >::syntax-rule
  >:syntax-rule-set
  :cursor :syntax-rule-set equal? if
    end
  then
  ::syntax-rule
  :cursor syntax-rule:*unit* sub syntax-rule:get
  equal2? if
    :syntax-rule-set :cursor
    syntax-rule:sub,move
    end
  then
  :syntax-rule-set
  ::syntax-rule
  :cursor *cell-size* 2 mul sub
  loop
; define-function

: syntax-rule:sub
  << syntax-rule-set: syntax-rule[predicate, function] -- >>
  x|over|xx syntax-rule-set:get-border
  syntax-rule:sub,loop
  end
; define-function

: syntax-rule-set:mixin,loop
  << base-syntax-rule-set: border, cursor -- >>
  dup2 equal? if
    drop2
    drop
    end
  then
  dup syntax-rule:get >::syntax-rule
  x|over|xx ::syntax-rule syntax-rule:add
  syntax-rule:*unit* add
  loop
; define-function

: syntax-rule-set:mixin
  << base-syntax-rule-set: syntax-rule-set -- >>
  dup syntax-rule-set:get-border swap
  syntax-rule-set:mixin,loop
  end
; define-function

: syntax-rule-set:mixout,loop
  << base-syntax-rule-set: border, cursor -- >>
  dup2 equal? if
    drop2
    drop
    end
  then
  dup syntax-rule:get >::syntax-rule
  x|over|xx ::syntax-rule syntax-rule:sub
  syntax-rule:*unit* add
  loop
; define-function

: syntax-rule-set:mixout
  << base-syntax-rule-set: syntax-rule-set -- >>
  dup syntax-rule-set:get-border swap
  syntax-rule-set:mixout,loop
  end
; define-function

: stack-REPL,loop
  << unknown -- unknown >>
  read-word
  word-interpreter
  argument-stack:pretty-print
  loop
; define-function

: stack-REPL
  << unknown -- unknown >>
  jo bye,basic-REPL
  'bye,basic-REPL await
  syntax-rule-set:*word-interpreter* push-syntax-stack
  stack-REPL,loop
  end
; define-function

: eval-string,loop
  << unknown -- unknown >>
  tos-reading-stack string:space? if
    end
  then
  read-word
  word-interpreter
  loop
; define-function

: eval-string
  << string[address, length] -- unknown >>
  push-reading-stack
  eval-string,loop
  drop-reading-stack
  end
; define-function

: syntax,double-quote,define-variable,loop
  << cursor -- cursor >>
  read-byte
  dup 34 equal? if
    drop
    end
  then
  over set-byte
  add1
  loop
; define-function

: syntax,double-quote,define-variable
  << literal-word:double-quote -- string[address, length] >>
  drop2
  1024 2 mul allocate-local-memory >:buffer
  :buffer
  syntax,double-quote,define-variable,loop
  >:cursor
  :buffer
  :cursor :buffer sub
  make-string
  end
; define-function

: define-variable
  << string[address, length] -- >>
  >::string

  ::string string:word >::name
  ::string string:word-tail >::body

  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot* >:old-snapshot

  syntax-rule-set:*word-interpreter*
  jo literal-word:double-quote?
  jo syntax,double-quote,define-variable
  syntax-rule:add

  ::body eval-string

  syntax-rule-set:*word-interpreter*
  jo literal-word:double-quote?
  jo syntax,double-quote,define-variable
  syntax-rule:sub

  snapshot-the-stack-pointer
  *the-stack-pointer-snapshot* >:new-snapshot

  :new-snapshot :old-snapshot sub

  dup negative? if
    negate *cell-size* div
    "* (define-variable) fail to define variable : " .s ::name .s .l
    "  because after eval the following body" .s .l
    "  the stack is " .s .i " below what it use to be" .s .l
    ::body .s .l
    end
  then
  dup zero? if
    drop
    "* (define-variable) fail to define variable : " .s ::name .s .l
    "  because after eval the following body" .s .l
    "  the stack is still where it use to be" .s .l
    ::body .s .l
    end
  then

  *cell-size* div >:length

  ::name make-string >::name

  ::name *link* 0
  make-link >:link

  :link address *link* set

  *explainer,variable* 0
  make-jo-head >:jo

  :jo :link link,set-jo

  :link name-hash-table,record-jo,by-link

  :length
  :jo jo,set-length

  *jojo-area,current-free-address*
  :length
  n-set

  :length *cell-size* mul
  address *jojo-area,current-free-address*
  add-set
  end
; define-function

*cell-size* 4 equal? if
  5   : syscall-number:*open*       ; define-variable,with-tos
  6   : syscall-number:*close*      ; define-variable,with-tos
  3   : syscall-number:*read*       ; define-variable,with-tos
  4   : syscall-number:*write*      ; define-variable,with-tos
  9   : syscall-number:*link*       ; define-variable,with-tos
  10  : syscall-number:*unlink*     ; define-variable,with-tos
  39  : syscall-number:*mkdir*      ; define-variable,with-tos
  40  : syscall-number:*rmdir*      ; define-variable,with-tos
  141 : syscall-number:*getdents*   ; define-variable,with-tos
  220 : syscall-number:*getdents64* ; define-variable,with-tos
  106 : syscall-number:*stat*       ; define-variable,with-tos
  1   : syscall-number:*exit*       ; define-variable,with-tos
  43  : syscall-number:*times*      ; define-variable,with-tos
  20  : syscall-number:*getpid*     ; define-variable,with-tos
  183 : syscall-number:*getcwd*     ; define-variable,with-tos
  12  : syscall-number:*chdir*      ; define-variable,with-tos
then

*cell-size* 8 equal? if
  2   : syscall-number:*open*       ; define-variable,with-tos
  3   : syscall-number:*close*      ; define-variable,with-tos
  0   : syscall-number:*read*       ; define-variable,with-tos
  1   : syscall-number:*write*      ; define-variable,with-tos
  86  : syscall-number:*link*       ; define-variable,with-tos
  87  : syscall-number:*unlink*     ; define-variable,with-tos
  83  : syscall-number:*mkdir*      ; define-variable,with-tos
  84  : syscall-number:*rmdir*      ; define-variable,with-tos
  78  : syscall-number:*getdents*   ; define-variable,with-tos
  217 : syscall-number:*getdents64* ; define-variable,with-tos
  4   : syscall-number:*stat*       ; define-variable,with-tos
  60  : syscall-number:*exit*       ; define-variable,with-tos
  100 : syscall-number:*times*      ; define-variable,with-tos
  39  : syscall-number:*getpid*     ; define-variable,with-tos
  79  : syscall-number:*getcwd*     ; define-variable,with-tos
  80  : syscall-number:*chdir*      ; define-variable,with-tos
then

: error-code->string
  << error-code -- string[address, length] >>
  dup -1  equal? if drop  << EPERM   >>   "Operation not permitted " end then
  dup -2  equal? if drop  << ENOENT  >>   "No such file or directory " end then
  dup -3  equal? if drop  << ESRCH   >>   "No such process " end then
  dup -4  equal? if drop  << EINTR   >>   "Interrupted system call " end then
  dup -5  equal? if drop  << EIO     >>   "I/O error " end then
  dup -6  equal? if drop  << ENXIO   >>   "No such device or address " end then
  dup -7  equal? if drop  << E2BIG   >>   "Argument list too long " end then
  dup -8  equal? if drop  << ENOEXEC >>   "Exec format error " end then
  dup -9  equal? if drop  << EBADF   >>   "Bad file number " end then
  dup -10 equal? if drop  << ECHILD  >>   "No child processes " end then
  dup -11 equal? if drop  << EAGAIN  >>   "Try again " end then
  dup -12 equal? if drop  << ENOMEM  >>   "Out of memory " end then
  dup -13 equal? if drop  << EACCES  >>   "Permission denied " end then
  dup -14 equal? if drop  << EFAULT  >>   "Bad address " end then
  dup -15 equal? if drop  << ENOTBLK >>   "Block device required " end then
  dup -16 equal? if drop  << EBUSY   >>   "Device or resource busy " end then
  dup -17 equal? if drop  << EEXIST  >>   "File exists " end then
  dup -18 equal? if drop  << EXDEV   >>   "Cross-device link " end then
  dup -19 equal? if drop  << ENODEV  >>   "No such device " end then
  dup -20 equal? if drop  << ENOTDIR >>   "Not a directory " end then
  dup -21 equal? if drop  << EISDIR  >>   "Is a directory " end then
  dup -22 equal? if drop  << EINVAL  >>   "Invalid argument " end then
  dup -23 equal? if drop  << ENFILE  >>   "File table overflow " end then
  dup -24 equal? if drop  << EMFILE  >>   "Too many open files " end then
  dup -25 equal? if drop  << ENOTTY  >>   "Not a typewriter " end then
  dup -26 equal? if drop  << ETXTBSY >>   "Text file busy " end then
  dup -27 equal? if drop  << EFBIG   >>   "File too large " end then
  dup -28 equal? if drop  << ENOSPC  >>   "No space left on device " end then
  dup -29 equal? if drop  << ESPIPE  >>   "Illegal seek " end then
  dup -30 equal? if drop  << EROFS   >>   "Read-only file system " end then
  dup -31 equal? if drop  << EMLINK  >>   "Too many links " end then
  dup -32 equal? if drop  << EPIPE   >>   "Broken pipe " end then
  dup -33 equal? if drop  << EDOM    >>   "Math argument out of domain of func " end then
  dup -34 equal? if drop  << ERANGE  >>   "Math result not representable " end then
  "unknow error-code : " .s .i .l
  "* (error-code->string) fail" << to balance the argument-stack >>
  end
; define-function

: file-type-code->string
  << file-type-code -- string[address, length] >>
  dup 1  equal?  << DT_FIFO  >>  if drop "named pipe i.e. FIFO"  end then
  dup 2  equal?  << DT_CHR   >>  if drop "Character device"      end then
  dup 4  equal?  << DT_DIR   >>  if drop "directory"             end then
  dup 6  equal?  << DT_BLK   >>  if drop "block device"          end then
  dup 8  equal?  << DT_REG   >>  if drop "regular file"          end then
  dup 10 equal?  << DT_LNK   >>  if drop "symbolic link"         end then
  dup 12 equal?  << DT_SOCK  >>  if drop "UNIX domain socket"    end then
  drop
  "unknow file type"
  end
; define-function

: port:open
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  0 <<
  O_RDONLY
  >>
  :syscall-path
  syscall-number:*open*
  2 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port:create
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#1102 <<
  O_RDWR   0002
  O_CREAT  0100
  O_TRUNC  1000
  >>
  :syscall-path
  syscall-number:*open*
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port:update
  << path[address, length]
     -- port, true
     -- error-code, false >>
  string->syscall-string
  >:syscall-path
  8#644 <<
  110100100b
  >>
  8#1002 <<
  O_RDWR   0002
  O_TRUNC  1000
  >>
  :syscall-path
  syscall-number:*open*
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port:close
  << port
     -- true
     -- error-code, false >>
  syscall-number:*close*
  1 syscall
  dup
  negative? if
    false
    end
  then
  drop true
  end
; define-function

: port:read
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  syscall-number:*read*
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: port:write
  << buffer, max-size, port
     -- counter, true
     -- error-code, false >>
  >:port
  swap
  :port
  syscall-number:*write*
  3 syscall
  dup
  negative? if
    false
    end
  then
  true
  end
; define-function

: file:create
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#0200
  8#0100 bit-or <<
  O_EXCL   0200
  O_CREAT  0100
  >>
  :syscall-path
  syscall-number:*open*
  3 syscall
  dup
  negative? if
    "* (file:create) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  port:close if
    end
  then
  "* (file:create) fail to close port for the following path :" .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: file:write
  << string[address, length], path[address, length] -- >>
  >::path
  >::string
  ::path
  string->syscall-string
  >:syscall-path
  8#644 <<
  2#110100100
  >>
  8#1002 <<
  O_RDWR   0002
  O_TRUNC  1000
  >>
  :syscall-path
  syscall-number:*open*
  3 syscall
  dup
  negative? if
    "* (file:write) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:port
  ::string swap
  :port
  syscall-number:*write*
  3 syscall
  dup
  negative? if
    "* (file:write) fail to write port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:counter << bytes been written >>
  :port
  port:close if
    end
  then
  "* (file:write) fail to close port for the following path : " .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: file:read
  << string[address, max-length], path[address, length] -- counter >>
  >::path
  >::string
  ::path
  string->syscall-string
  >:syscall-path
  0 <<
  O_RDONLY
  >>
  :syscall-path
  syscall-number:*open*
  2 syscall
  dup
  negative? if
    "* (file:read) fail to open port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    0
    end
  then
  >:port
  ::string swap
  :port
  syscall-number:*read*
  3 syscall
  dup
  negative? if
    "* (file:read) fail to read port for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    0
    end
  then
  >:counter << bytes been readed >>
  :port
  port:close if
    :counter
    end
  then
  "* (file:read) fail to close port for the following path : " .s .l
  "  " .s ::path .s .l
  "  " .s error-code->string .s .l
  0
  end
; define-function

: file:remove
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  :syscall-path
  syscall-number:*unlink*
  1 syscall
  dup
  negative? if
    "* (file:remove) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

: directory:create
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  8#755 <<
  2#111101101
  >>
  :syscall-path
  syscall-number:*mkdir*
  2 syscall
  dup
  negative? if
    "* (directory:create) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

: directory:remove
  << path[address, length] -- >>
  >::path
  ::path
  string->syscall-string
  >:syscall-path
  :syscall-path
  syscall-number:*rmdir*
  1 syscall
  dup
  negative? if
    "* (directory:remove) fail for the following path :" .s .l
    "  " .s ::path .s .l
    "  " .s error-code->string .s .l
    end
  then
  drop
  end
; define-function

0 : +getdents64,ino+        ; define-variable,with-tos
0 : +getdents64,off+        ; define-variable,with-tos
0 : +getdents64,reclen+     ; define-variable,with-tos
0 : +getdents64,type+       ; define-variable,with-tos
0 : +getdents64,name+       ; define-variable,with-tos
0 : +getdents64,end+          ; define-variable,with-tos

: init,getdents64
  << offset -- >>
  *cell-size* 4 equal? if
    dup address +getdents64,ino+    set    8 add
    dup address +getdents64,off+    set    8 add
    dup address +getdents64,reclen+ set    2 add
    dup address +getdents64,type+   set    1 add
    dup address +getdents64,name+   set    256 add
        address +getdents64,end+      set
    end
  then
  *cell-size* 8 equal? if
    dup address +getdents64,ino+    set    8 add
    dup address +getdents64,off+    set    8 add
    dup address +getdents64,reclen+ set    2 add
    dup address +getdents64,type+   set    1 add
    dup address +getdents64,name+   set    256 add
        address +getdents64,end+      set
    end
  then
  end
; define-function

0 init,getdents64
+getdents64,end+ : +getdents64,length+ ; define-variable,with-tos

: directory:empty?
  << path[address, length] -- bool >>
  >::path
  ::path port:open if
  else
    "* (directory:empty?) fail to open : " .s ::path .s .l
    "  " .s error-code->string .s .l
    false
    end
  then
  >:port
  128 allocate-local-memory >:getdents64-structure-list
  128
  :getdents64-structure-list
  :port
  syscall-number:*getdents64*
  3 syscall
  48 equal? << this call to equal? returns the needed bool >>
  :port port:close if
    end
  then
  "* (directory:empty?) fail to close : " .s ::path .s .l
  "  " .s error-code->string .s .l
  false
  end
; define-function

: directory:map,loop,apply
  << end, cursor, function -- >>
  >:function
  dup2 less-or-equal? if
    drop2
    end
  then
  >:cursor
  >:end
  :cursor init,getdents64
  :function apply
  :end
  :cursor +getdents64,reclen+ get-two-bytes add
  :function
  loop
; define-function

: directory:map,loop
  << port, function -- >>
  >:function
  >:port
  1024 allocate-local-memory >:getdents64-structure-list
  1024
  :getdents64-structure-list
  :port
  syscall-number:*getdents64*
  3 syscall
  dup negative? if
    "* (directory:map,loop) syscall fail" .s .l
    "  " .s error-code->string .s .l
    end
  then
  dup zero? if
    drop
    end
  then
  :getdents64-structure-list add
  :getdents64-structure-list
  :function
  directory:map,loop,apply
  :port
  :function
  loop
; define-function

: directory:map
  << directory-path[address, length],
     function
     -- true
     -- false >>
  >:function
  >::directory-path
  ::directory-path port:open if
  else
    "* (directory:map) fail to open : " .s ::directory-path .s .l
    "  " .s error-code->string .s .l
    end
  then
  >:port
  :port :function directory:map,loop
  :port port:close if
    end
  then
  "* (directory:map) fail to close : " .s ::directory-path .s .l
  "  " .s error-code->string .s .l
  end
; define-function

: directory:list-file
  << directory-path[address, length] -- >>
  [ << -- >>
    +getdents64,type+ get-byte
    8 equal? if
      "  " .s
      +getdents64,name+
      dup 256
      0 string:find-byte
      drop  << drop 0 >>
      over sub .s .l
    then
    end ]
  directory:map
  end
; define-function

: directory:list-directory
  << directory-path[address, length] -- >>
  [ << -- >>
    +getdents64,type+ get-byte
    4 equal? if
      +getdents64,name+
      dup 256
      0 string:find-byte
      drop  << drop 0 >>
      over sub >::name
      ".." ::name string:equal? if
        end
      then
      "." ::name string:equal? if
        end
      then
      "  " .s ::name .s .l
      end
    then
    end ]
  directory:map
  end
; define-function

: directory:find-file
  << directory-path[address, length], file-name[address, length] -- bool >>
  xx|swap|xx
  false
  xx|swap|x
  [ << file-name[address, length], bool --
       file-name[address, length], bool >>
    +getdents64,type+ get-byte 8 equal? not if
      end
    then
    >:bool
    >:file-name,lenght
    >:file-name,address
    :file-name,lenght +getdents64,name+ add
    get-byte zero? not if
      :file-name,address
      :file-name,lenght
      :bool
      end
    then
    :file-name,address :file-name,lenght
    +getdents64,name+ :file-name,lenght
    string:equal? if
      :file-name,address
      :file-name,lenght
      true
      end
    then
    :file-name,address
    :file-name,lenght
    :bool
    end ]
  directory:map
  xx|swap|x drop2
  end
; define-function

: directory:find-directory
  << directory-path[address, length], file-name[address, length] -- bool >>
  xx|swap|xx
  false
  xx|swap|x
  [ << file-name[address, length], bool --
       file-name[address, length], bool >>
    +getdents64,type+ get-byte 4 equal? not if
      end
    then
    >:bool
    >:file-name,lenght
    >:file-name,address
    :file-name,lenght +getdents64,name+ add
    get-byte zero? not if
      :file-name,address
      :file-name,lenght
      :bool
      end
    then
    :file-name,address :file-name,lenght
    +getdents64,name+ :file-name,lenght
    string:equal? if
      :file-name,address
      :file-name,lenght
      true
      end
    then
    :file-name,address
    :file-name,lenght
    :bool
    end ]
  directory:map
  xx|swap|x drop2
  end
; define-function

0 : *pid* ; define-variable,with-tos

: init-pid
  << -- >>
  syscall-number:*getpid*
  0 syscall
  address *pid* set
  end
; define-function

: get-pid
  << -- pid >>
  *pid*
  end
; define-function

512 allocate-memory
: *address,command-line*
; define-variable,with-tos

512
: *length,command-line*
; define-variable,with-tos

: init-command-line
  << -- >>
  64 allocate-local-memory >:path-buffer
  :path-buffer >:cursor

  get-pid write-number,fill-buffer >::pid-string

  "/proc/" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  ::pid-string dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  "/cmdline" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  :path-buffer
  :cursor :path-buffer sub dup2 >::path
  port:open if
  else
    "* (init-command-line) fail to open : " .s ::path .s .l
    end
  then
  >:port

  *address,command-line*
  *length,command-line*
  :port
  port:read if
  else
    "* (init-command-line) fail to read : " .s ::path .s .l
    end
  then
  address *length,command-line* set
  end
; define-function

: get-command-line
  << -- string[address, length] >>
  *address,command-line* *length,command-line*
  end
; define-function

1024 4 mul allocate-memory
: *address,environment-variable-list*
; define-variable,with-tos

1024 4 mul
: *length,environment-variable-list*
; define-variable,with-tos

: init-environment-variable-list
  << -- >>
  64 allocate-local-memory >:path-buffer
  :path-buffer >:cursor

  get-pid write-number,fill-buffer >::pid-string

  "/proc/" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  ::pid-string dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  "/environ" dup >:add-to-cursor
  :cursor string->buffer!
  :add-to-cursor :cursor add >:cursor

  :path-buffer
  :cursor :path-buffer sub dup2 >::path
  port:open if
  else
    "* (init-environment-variable-list) fail to open : " .s ::path .s .l
    end
  then
  >:port

  *address,environment-variable-list*
  *length,environment-variable-list*
  :port
  port:read if
  else
    "* (init-environment-variable-list) fail to read : " .s ::path .s .l
    end
  then
  address *length,environment-variable-list* set
  end
; define-function

: get-environment-variable-list
  << -- string[address, length] >>
  *address,environment-variable-list*
  *length,environment-variable-list*
  end
; define-function

: find-environment-variable,loop
  << string[address, length], cursor
     -- string[address, length], true
     -- false >>
  dup
  get-environment-variable-list add
  greater-than? if
    drop drop2
    false
    end
  then
  >:cursor
  >:length
  >:address
  :address :cursor :length
  compare-buffer not if
    :address :length
    :cursor 0 cursor->next-matching-byte add1
    loop
  then
  :cursor :length add get-byte
  "=" string:byte
  equal? not if
    :address :length
    :cursor 0 cursor->next-matching-byte add1
    loop
  then
  :cursor :length add add1 << over "=" >>
  >:find-address
  :find-address 0 cursor->next-matching-byte
  :find-address sub >:find-length
  :find-address
  :find-length
  end
; define-function

: find-environment-variable
  << string[address, length]
     -- string[address, length], true
     -- false >>
  get-environment-variable-list drop
  find-environment-variable,loop
  end
; define-function

init-pid
init-command-line
init-environment-variable-list

: *home-directory*
  "HOME" find-environment-variable
; define-variable

: report:environment-variable,loop
  << environment-variable-list[address, length]-- >>
  dup2 string:space? if
    drop2
    end
  then

  >:length
  >:address

  :address :length 0 string:find-byte drop add1 >:cursor
  :cursor :address sub >:length-of-one-variable

  :address
  :length-of-one-variable sub1 .s .l

  :cursor
  :length :length-of-one-variable sub
  loop
; define-function

: report:environment-variable
  << -- >>
  get-environment-variable-list
  report:environment-variable,loop
  end
; define-function

: report:command-line,loop
  << command-line[address, length] -- >>
  dup2 string:space? if
    drop2
    end
  then
  dup2 string:word .s 32 .b
  string:word-tail
  loop
; define-function

: report:command-line
  << -- >>
  get-command-line
  report:command-line,loop
  end
; define-function

512 allocate-memory
: *buffer,work-directory*
; define-variable,with-tos

: work-directory:get
  << -- directory[address, length] >>
  512
  *buffer,work-directory*
  syscall-number:*getcwd*
  2 syscall
  dup negative? if
    "* (work-directory:get) fail" .s .l
    "  " .s error-code->string .s .l
    end
  then
  *buffer,work-directory*
  swap
  sub1 << for the ending zero >>
  end
; define-function

: work-directory:change
  << directory-path[address, length] -- >>
  >::directory-path
  ::directory-path
  string->syscall-string
  syscall-number:*chdir*
  1 syscall
  dup negative? if
    "* (work-directory:change) fail" .s .l
    "  can not change the work directory into : " .s ::directory-path .s .l
    "  thus the argument in the stack is not consumed" .s .l
    "  " .s error-code->string .s .l
    ::directory-path
    end
  then
  drop
  end
; define-function

: pwd
  << -- >>
  work-directory:get .s .l
  end
; define-function

"cd" "work-directory:change" alias

0 : +stat,dev+        ; define-variable,with-tos
0 : +stat,ino+        ; define-variable,with-tos
0 : +stat,mode+       ; define-variable,with-tos
0 : +stat,nlink+      ; define-variable,with-tos
0 : +stat,uid+        ; define-variable,with-tos
0 : +stat,gid+        ; define-variable,with-tos
0 : +stat,rdev+       ; define-variable,with-tos
0 : +stat,size+       ; define-variable,with-tos
0 : +stat,blksize+    ; define-variable,with-tos
0 : +stat,blocks+     ; define-variable,with-tos
0 : +stat,atime+      ; define-variable,with-tos
0 : +stat,atime_nsec+ ; define-variable,with-tos
0 : +stat,mtime+      ; define-variable,with-tos
0 : +stat,mtime_nsec+ ; define-variable,with-tos
0 : +stat,ctime+      ; define-variable,with-tos
0 : +stat,ctime_nsec+ ; define-variable,with-tos
0 : +stat,__unused4+     ; define-variable,with-tos
0 : +stat,__unused5+     ; define-variable,with-tos
0 : +stat,end+           ; define-variable,with-tos

: init,stat
  << offset -- >>
  *cell-size* 4 equal? if
    dup address +stat,dev+        set *cell-size* add
    dup address +stat,ino+        set *cell-size* add
    dup address +stat,mode+       set 2 add
    dup address +stat,nlink+      set 2 add
    dup address +stat,uid+        set 2 add
    dup address +stat,gid+        set 2 add
    dup address +stat,rdev+       set *cell-size* add
    dup address +stat,size+       set *cell-size* add
    dup address +stat,blksize+    set *cell-size* add
    dup address +stat,blocks+     set *cell-size* add
    dup address +stat,atime+      set *cell-size* add
    dup address +stat,atime_nsec+ set *cell-size* add
    dup address +stat,mtime+      set *cell-size* add
    dup address +stat,mtime_nsec+ set *cell-size* add
    dup address +stat,ctime+      set *cell-size* add
    dup address +stat,ctime_nsec+ set *cell-size* add
    dup address +stat,__unused4+     set *cell-size* add
    dup address +stat,__unused5+     set *cell-size* add
        address +stat,end+           set
    end
  then
  *cell-size* 8 equal? if
    dup address +stat,dev+        set *cell-size* add
    dup address +stat,ino+        set *cell-size* add
    <<
    note the following order changing
    this is linux' bad
    >>
    dup address +stat,nlink+      set 8 add
    dup address +stat,mode+       set 4 add

    dup address +stat,uid+        set 4 add
    dup address +stat,gid+        set 4 add
                                         4 add << padding >>
    dup address +stat,rdev+       set *cell-size* add
    dup address +stat,size+       set *cell-size* add
    dup address +stat,blksize+    set *cell-size* add
    dup address +stat,blocks+     set *cell-size* add
    dup address +stat,atime+      set *cell-size* add
    dup address +stat,atime_nsec+ set *cell-size* add
    dup address +stat,mtime+      set *cell-size* add
    dup address +stat,mtime_nsec+ set *cell-size* add
    dup address +stat,ctime+      set *cell-size* add
    dup address +stat,ctime_nsec+ set *cell-size* add
    dup address +stat,__unused4+     set *cell-size* add
    dup address +stat,__unused5+     set *cell-size* add
        address +stat,end+           set
    end
  then
  end
; define-function

0 init,stat
+stat,end+ : +stat,length+ ; define-variable,with-tos

: path:nothing?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  syscall-number:*stat*
  2 syscall
  -2 equal?
  end
; define-function

: path:file?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  syscall-number:*stat*
  2 syscall
  dup
  negative? if
    drop
    false
    end
  then
  drop
  :stat-structure init,stat
  *cell-size* 4 equal? if
    +stat,mode+
    get-two-bytes
  then
  *cell-size* 8 equal? if
    +stat,mode+
    get-four-bytes
  then
  12 bit-right
  8#0010
  equal?
  <<
  0170000
  S_IFDIR       0040000 /* Directory.  */
  S_IFCHR       0020000 /* Character device.  */
  S_IFBLK       0060000 /* Block device.  */
  S_IFREG       0100000 /* Regular file.  */
  S_IFIFO       0010000 /* FIFO.  */
  S_IFLNK       0120000 /* Symbolic link.  */
  S_IFSOCK      0140000 /* Socket.  */
  >>
  end
; define-function

: path:directory?
  << path[address, length] -- bool >>
  string->syscall-string
  >:syscall-path
  +stat,length+ allocate-local-memory
  >:stat-structure
  :stat-structure
  :syscall-path
  syscall-number:*stat*
  2 syscall
  dup
  negative? if
    drop
    false
    end
  then
  drop
  :stat-structure init,stat
  *cell-size* 4 equal? if
    +stat,mode+
    get-two-bytes
  then
  *cell-size* 8 equal? if
    +stat,mode+
    get-four-bytes
  then
  12 bit-right
  8#0004
  equal?
  <<
  0170000
  S_IFDIR       00040000 /* Directory.  */
  S_IFCHR       00020000 /* Character device.  */
  S_IFBLK       00060000 /* Block device.  */
  S_IFREG       00100000 /* Regular file.  */
  S_IFIFO       00010000 /* FIFO.  */
  S_IFLNK       00120000 /* Symbolic link.  */
  S_IFSOCK      00140000 /* Socket.  */
  >>
  end
; define-function

: path:relative?
  << string[address, length] -- bool >>
  dup zero? if
    drop2
    false
    end
  then
  string:byte
  47 equal? not
  end
; define-function

: path:full?
  << string[address, length] -- bool >>
  dup zero? if
    drop2
    false
    end
  then
  string:byte
  47 equal?
  end
; define-function

: *poi-directory,user,address*
  512 allocate-memory
; define-variable

: *poi-directory*
  *home-directory* "/.cicada/poi"
  *poi-directory,user,address*
  2 n-string->buffer!
  *poi-directory,user,address* swap
; define-variable

: poi:find
  << name[address, length]
     -- path[address, length], true
     -- false >>
  >::name
  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  path:file? not if
    false
    end
  then

  512 allocate-local-memory >:read-buffer
  :read-buffer 512
  :buffer :length
  file:read >:read-length

  *circular-string-area,current-free-address*
  >:path-address

  :read-buffer :read-length
  circular-string-area,stay

  :path-address
  :read-length
  true
  end
; define-function

: poi:add
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path path:relative? not if
    "* (poi:add) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path:directory? not if
    "* (poi:add) the argument must be a relative-path to a existing directory" .s .l
    "  but the following path is not to a directory : " .s ::relative-path .s .l
    end
  then

  ::name poi:find if
    "* (poi:add) can not add" .s .l
    "  for the following poi already exist : " .s ::name .s .l
    "  name is use as the following directory's name : " .s .s .l
    end
  then

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory:create

  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer!
  >:length
  :buffer :length
  file:create

  512 allocate-local-memory >:address,full-path
  work-directory:get "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file:write
  end
; define-function

: poi:sub
  << name[address, length] -- >>
  >::name

  ::name poi:find not if
    "* (poi:sub) can not sub" .s .l
    "  for the following poi does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  file:remove

  *poi-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory:remove
  end
; define-function

: poi:up
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path path:relative? not if
    "* (poi:up) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path:directory? not if
    "* (poi:up) the argument must be a relative-path to a existing directory" .s .l
    "  but the following directory is not exist : " .s ::relative-path .s .l
    end
  then

  ::name poi:find not if
    "* (poi:up) can not up" .s .l
    "  for the following poi does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *poi-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  512 allocate-local-memory >:address,full-path
  work-directory:get "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file:write
  end
; define-function

: poi:list
  << -- >>
  *poi-directory*
  [ << -- >>
    +getdents64,type+ get-byte
    4 equal? if
      512 allocate-local-memory >:path-buffer
      +getdents64,name+
      dup 256
      0 string:find-byte
      drop  << drop 0 >>
      over sub >::name

      ".." ::name string:equal? if
        end
      then

      "." ::name string:equal? if
        end
      then

      "  * " .s ::name .s .l
      "      " .s

      *poi-directory* "/" ::name "/path"
      :path-buffer
      4 n-string->buffer! >:path-length

      512 allocate-local-memory >:reading-buffer
      :reading-buffer 512
      :path-buffer :path-length
      file:read >:reading-length

      :reading-buffer :reading-length
      .s .l
    then
    end ]
  directory:map
  end
; define-function

: poi:help
  << -- >>
  "* (poi:help)" .s .l
  "  * cn poi add  <new-name> <relative-path-to-existing-directory>" .s .l
  "  * cn poi sub  <old-name>" .s .l
  "  * cn poi up   <old-name> <relative-path-to-existing-directory>" .s .l
  "  * cn poi find <old-name>" .s .l
  "  * cn poi list" .s .l
  end
; define-function

: +word+?
  << string[address, length] -- bool >>
  dup 1 less-or-equal? if
    drop2
    false
    end
  then
  over get-byte
  "+" string:byte equal? not if
    drop2
    false
    end
  then
  add sub1 get-byte
  "+" string:byte equal?
  end
; define-function

: +word+->word
  << +word+[address, length] -- name[address, length] >>
  sub2 swap
  add1 swap
  end
; define-function

: path-syntax-word->path
  << word[address, length] -- path[address, length] >>
  >::word
  ::word "+root+" string:equal? if
    "/"
    end
  then
  ::word "+work+" string:equal? if
    work-directory:get
    end
  then
  ::word "+home+" string:equal? if
    *home-directory*
    end
  then
  ::word "+back+" string:equal? if
    ".."
    end
  then
  ::word +word+? not if
    ::word
    end
  then
  ::word +word+->word poi:find if
    end
  then
  ::word
  'bad-path-syntax-word awake
; define-function

: bad-path-syntax-word,loop
  << -- >>
  read-word
  dup2 ";" string:equal? if
    .s 32 .b
    end
  then
  .s 32 .b
  loop
; define-function

: word-interpreter-syntax:path,loop
  << cursor -- cursor >>
  >:cursor
  read-word >::word

  ";" ::word string:equal? if
    :cursor
    end
  then

  ::word path-syntax-word->path dup >:length
  :cursor
  string->buffer!

  :cursor :length add
    dup
    "/" string:byte
    swap
    set-byte
  add1
  loop
; define-function

: word-interpreter-syntax:path
  << literal-word:path: -- path[address, length] >>
  drop2

  [ << word -- >>
    "* (word-interpreter-syntax:path) the following word is of bad syntax : " .s .l
    "    " .s .s .l
    action,reset-the-stack
    << -- >>
    "  the rest of the words in path syntax is as following :" .s .l
    "    " .s bad-path-syntax-word,loop .l
    end ]
  'bad-path-syntax-word await

  512 allocate-local-memory >:buffer
  :buffer word-interpreter-syntax:path,loop >:cursor

  :cursor :buffer sub >:length

  *circular-string-area,current-free-address*
  >:address

  :buffer
  :length
  circular-string-area,stay

  :address
  :length
  end
; define-function

: more,syntax-rule-set:basic-REPL
  << -- >>
  syntax-rule-set:*word-interpreter*
  ["path:" string:equal? end]
  jo word-interpreter-syntax:path
  syntax-rule:add
  end
; define-function
more,syntax-rule-set:basic-REPL

: string:full-of-the-same-byte?
  << string[address, length], byte -- bool >>
  >:byte
  >::string
  ::string dup zero? if
    drop2
    true
    end
  then
  string:byte :byte equal? not if
    false
    end
  then
  ::string string:byte-tail
  :byte
  loop
; define-function

: string:any-word
  << string[address, length]
     function : < word[address, length] -- bool >
     -- bool >>
  >:function
  >::string
  ::string string:space? if
    false
    end
  then
  ::string string:word :function apply if
    true
    end
  then
  ::string string:word-tail
  :function
  loop
; define-function

: string:every-word
  << string[address, length]
     function : < word[address, length] -- bool >
     -- bool >>
  >:function
  >::string
  ::string string:space? if
    true
    end
  then
  ::string string:word :function apply not if
    false
    end
  then
  ::string string:word-tail
  :function
  loop
; define-function

: string:word-end-back
  << string[address, length] -- string[address, length] >>
  dup zero? if
    <<
    no error handling
    the same empty-string is returned
    >>
    end
  then
  dup2 string:byte-back
  string:byte space-byte? not if
    end
  then
  string:byte-back
  loop
; define-function

: string:word-begin-back,loop
  << string[address, length] -- string[address, length] >>
  dup zero? if
    <<
    no error handling
    the current empty-string is returned
    >>
    end
  then
  dup2 string:byte-back
  string:byte space-byte? if
    end
  then
  dup2 string:byte-back
  string:byte bar-ket-byte? if
    end
  then
  string:byte-back
  loop
; define-function

: string:word-begin-back
  << string[address, length] -- string[address, length] >>
  dup zero? if
    <<
    no error handling
    the same empty-string is returned
    >>
    end
  then
  dup2 string:byte-back
  string:byte bar-ket-byte? if
    string:byte-back
    end
  then
  string:word-begin-back,loop
  end
; define-function

: string:word-back
  << string[address, length] -- string[address, length] >>
  string:word-end-back
  string:word-begin-back
  end
; define-function

: unread-word
  << -- >>
  pop-reading-stack
  string:word-back
  push-reading-stack
  end
; define-function

100 1024 mul
: module-naming-stack:*size*
; define-variable,with-tos

3 *cell-size* mul
: module-naming-stack:*unit*
; define-variable,with-tos

module-naming-stack:*size*
module-naming-stack:*unit* mul allocate-memory
: *module-naming-stack*
; define-variable,with-tos

*module-naming-stack*
: module-naming-stack:*pointer*
; define-variable,with-tos

: *module-directory,user,address*
  512 allocate-memory
; define-variable

: *module-directory*
  *home-directory* "/.cicada/moi"
  *module-directory,user,address*
  2 n-string->buffer!
  *module-directory,user,address* swap
; define-variable

: moi:find
  << name[address, length]
     -- path[address, length], true
     -- false >>
  >::name
  512 allocate-local-memory >:buffer
  *module-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  path:file? not if
    false
    end
  then

  512 allocate-local-memory >:read-buffer
  :read-buffer 512
  :buffer :length
  file:read >:read-length

  *circular-string-area,current-free-address*
  >:path-address

  :read-buffer :read-length
  circular-string-area,stay

  :path-address
  :read-length
  true
  end
; define-function

: moi:add
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path path:relative? not if
    "* (moi:add) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path:file? not if
    "* (moi:add) the argument must be a relative-path to a existing file" .s .l
    "  but the following path is not to a file : " .s ::relative-path .s .l
    end
  then

  ::name moi:find if
    "* (moi:add) can not add" .s .l
    "  for the following module already exist : " .s ::name .s .l
    "  name is use as the following directory's name : " .s .s .l
    end
  then

  512 allocate-local-memory >:buffer
  *module-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory:create

  *module-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer!
  >:length
  :buffer :length
  file:create

  512 allocate-local-memory >:address,full-path
  work-directory:get "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file:write
  end
; define-function

: moi:sub
  << name[address, length] -- >>
  >::name

  ::name moi:find not if
    "* (moi:sub) can not sub" .s .l
    "  for the following module does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *module-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  :buffer :length
  file:remove

  *module-directory* "/" ::name
  :buffer
  3 n-string->buffer!
  >:length
  :buffer :length
  directory:remove
  end
; define-function

: moi:up
  << name[address, length], relative-path[address, length] -- >>
  >::relative-path
  >::name

  ::relative-path path:relative? not if
    "* (moi:up) the argument must be a relative-path" .s .l
    "  but the following is not : " .s ::relative-path .s .l
    end
  then

  ::relative-path path:file? not if
    "* (moi:up) the argument must be a relative-path to a existing file" .s .l
    "  but the following file is not exist : " .s ::relative-path .s .l
    end
  then

  ::name moi:find not if
    "* (moi:up) can not up" .s .l
    "  for the following module does not exist : " .s ::name .s .l
    end
  then
  >::named-directory

  512 allocate-local-memory >:buffer
  *module-directory* "/" ::name "/path"
  :buffer
  4 n-string->buffer! >:length

  512 allocate-local-memory >:address,full-path
  work-directory:get "/" ::relative-path
  :address,full-path
  3 n-string->buffer! >:length,full-path

  :address,full-path :length,full-path
  :buffer :length
  file:write
  end
; define-function

: moi:list
  << -- >>
  *module-directory*
  [ << -- >>
    +getdents64,type+ get-byte
    4 equal? if
      512 allocate-local-memory >:path-buffer
      +getdents64,name+
      dup 256
      0 string:find-byte
      drop  << drop 0 >>
      over sub >::name

      ".." ::name string:equal? if
        end
      then

      "." ::name string:equal? if
        end
      then

      "  * " .s ::name .s .l
      "      " .s

      *module-directory* "/" ::name "/path"
      :path-buffer
      4 n-string->buffer! >:path-length

      512 allocate-local-memory >:reading-buffer
      :reading-buffer 512
      :path-buffer :path-length
      file:read >:reading-length

      :reading-buffer :reading-length
      .s .l
    then
    end ]
  directory:map
  end
; define-function

: moi:help
  << -- >>
  "* (moi:help)" .s .l
  "  * cn moi add  <new-module-name>      <relative-path-to-existing-file>" .s .l
  "  * cn moi sub  <existing-module-name>" .s .l
  "  * cn moi up   <existing-module-name> <relative-path-to-existing-file>" .s .l
  "  * cn moi find <existing-module-name>" .s .l
  "  * cn moi list" .s .l
  end
; define-function

10 1024 mul
: module-stack:*size*
; define-variable,with-tos

8 *cell-size* mul
: module-stack:*unit*
; define-variable,with-tos

module-stack:*size*
module-stack:*unit* mul allocate-memory
: *module-stack*
; define-variable,with-tos

*module-stack*
: module-stack:*pointer*
; define-variable,with-tos

: module-info:get-meta-string
  << module-info -- meta-string[address, length] >>
  2 n-get
  end
; define-function

: module-info:set-meta-string
  << meta-string[address, length], module-info -- >>
  xx|swap|x make-string x|swap|xx
  2 n-set
  end
; define-function

: module-info:get-name
  << module-info -- name >>
  *cell-size* 2 mul add
  get
  end
; define-function

: module-info:set-name
  << name, module-info -- >>
  *cell-size* 2 mul add
  set
  end
; define-function

: module-info:get-name-record-begin
  << module-info -- name >>
  *cell-size* 3 mul add
  get
  end
; define-function

: module-info:set-name-record-begin
  << name, module-info -- >>
  *cell-size* 3 mul add
  set
  end
; define-function

: module-info:get-name-record-end
  << module-info -- name >>
  *cell-size* 4 mul add
  get
  end
; define-function

: module-info:set-name-record-end
  << name, module-info -- >>
  *cell-size* 4 mul add
  set
  end
; define-function

: module-info:get-tested-flag
  << module-info -- name >>
  *cell-size* 5 mul add
  get
  end
; define-function

: module-info:set-tested-flag
  << name, module-info -- >>
  *cell-size* 5 mul add
  set
  end
; define-function

: module-info:get-success-counter
  << module-info -- name >>
  *cell-size* 6 mul add
  get
  end
; define-function

: module-info:set-success-counter
  << name, module-info -- >>
  *cell-size* 6 mul add
  set
  end
; define-function

: module-info:inc-success-counter
  << module-info -- >>
  *cell-size* 6 mul add
  1 swap
  add-set
  end
; define-function

: module-info:get-fail-counter
  << module-info -- name >>
  *cell-size* 7 mul add
  get
  end
; define-function

: module-info:set-fail-counter
  << name, module-info -- >>
  *cell-size* 7 mul add
  set
  end
; define-function

: module-info:inc-fail-counter
  << module-info -- >>
  *cell-size* 7 mul add
  1 swap
  add-set
  end
; define-function

: module-stack:find,loop
  << name, cursor
     -- module-info, true
     -- false >>
  dup module-stack:*pointer* equal? if
    drop2
    false
    end
  then
  >:cursor
  >:name
  :cursor module-info:get-name
  :name equal? if
    :cursor
    true
    end
  then
  :name
  :cursor module-stack:*unit* add
  loop
; define-function

: module-stack:find
  << name
     -- module-info, true
     -- false >>
  *module-stack*
  module-stack:find,loop
  end
; define-function

10 1024 mul
: importing-stack:*size*
; define-variable,with-tos

2 *cell-size* mul
: importing-stack:*unit*
; define-variable,with-tos

*cell-size* allocate-memory drop
*cell-size* allocate-memory
: *testing-flag*
; define-variable,with-tos

importing-stack:*size*
importing-stack:*unit* mul allocate-memory
: *importing-stack*
; define-variable,with-tos

*importing-stack*
: importing-stack:*pointer*
; define-variable,with-tos

: importing-record:get-name
  << module-info -- name >>
  get
  end
; define-function

: importing-record:set-name
  << name, module-info -- >>
  set
  end
; define-function

: importing-record:get-testing-flag
  << module-info -- bool >>
  *cell-size* add get
  end
; define-function

: importing-record:set-testing-flag
  << bool, module-info -- >>
  *cell-size* add set
  end
; define-function

: importing-stack:find,loop
  << name, cursor
     -- importing-record, true
     -- false >>
  dup importing-stack:*pointer* equal? if
    drop2
    false
    end
  then
  >:cursor
  >:name
  :cursor importing-record:get-name
  :name equal? if
    :cursor
    true
    end
  then
  :name
  :cursor importing-stack:*unit* add
  loop
; define-function

: importing-stack:find
  << name
     -- importing-record, true
     -- false >>
  *importing-stack*
  importing-stack:find,loop
  end
; define-function

: importing-stack:drop
  << -- >>
  importing-stack:*unit* address importing-stack:*pointer* sub-set
  end
; define-function

: t
  << -- >>
  *testing-flag* get if
    0 *testing-flag* set
    "* (testing) *testing-flag* off" .s .l
    end
  else
    1 *testing-flag* set
    "* (testing) *testing-flag* on" .s .l
    end
  then
; define-function

: module-naming-stack:record-jo
  << jo, name -- >>
  dup name,get-jo
  module-naming-stack:*pointer* name-record:set-old-jo
  dup2 name,set-jo
  module-naming-stack:*pointer* name-record:set-name
  module-naming-stack:*pointer* name-record:set-new-jo
  module-naming-stack:*unit* address module-naming-stack:*pointer* add-set
  end
; define-function

: module-naming-stack:delete-last-record
  << -- >>
  module-naming-stack:*unit*
  address module-naming-stack:*pointer*
  sub-set
  module-naming-stack:*pointer* name-record:get-old-jo
  module-naming-stack:*pointer* name-record:get-name
  name,set-jo
  end
; define-function

: global-naming-stack:clear-naming
  << name-record-begin, name-record-end -- >>
  dup2 equal? if
    drop2
    end
  then
  global-naming-stack:*unit* sub
  dup >:name-record
  :name-record name-record:get-old-jo
  :name-record name-record:get-name
  name,set-jo
  loop
; define-function

: module-naming-stack:clear-naming
  << name-record-begin, name-record-end -- >>
  dup2 equal? if
    drop2
    end
  then
  module-naming-stack:*unit* sub
  dup >:name-record
  :name-record name-record:get-old-jo
  :name-record name-record:get-name
  name,set-jo
  loop
; define-function

: global-naming-stack:prefix-naming
  << name-record-begin, name-record-end, prefix[name-index] -- >>
  >:prefix
  >:end
  >:begin
  :end :begin equal? if
    end
  then

  512 allocate-local-memory >:buffer
  :prefix name->string " " :begin name-record:get-name name->string
  :buffer 3 n-string->buffer! >:length

  :begin name-record:get-new-jo
  :buffer :length string->name
  module-naming-stack:record-jo

  :begin global-naming-stack:*unit* add
  :end
  :prefix
  loop
; define-function

: module-naming-stack:expose-naming
  << name-record-begin, name-record-end -- >>
  >:end
  >:begin
  :end :begin equal? if
    end
  then

  :begin name-record:get-new-jo
  :begin name-record:get-name
  name->string
  string:word-tail string:byte-tail
  string->name
  global-naming-stack:record-jo

  :begin module-naming-stack:*unit* add
  :end
  loop
; define-function

60 1024 mul
: undo-stack:*size*
; define-variable,with-tos

7 *cell-size* mul
: undo-stack:*unit*
; define-variable,with-tos

undo-stack:*size*
undo-stack:*unit* mul allocate-memory
: *undo-stack*
; define-variable,with-tos

*undo-stack*
: undo-stack:*pointer*
; define-variable,with-tos

: undo-point:get-jojo-area
  << undo-point -- jojo-area current-free-address >>
  get
  end
; define-function

: undo-point:set-jojo-area
  << jojo-area current-free-address, undo-point -- >>
  set
  end
; define-function

: undo-point:get-string-area
  << undo-point -- jojo-area current-free-address >>
  *cell-size* add get
  end
; define-function

: undo-point:set-string-area
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* add set
  end
; define-function

: undo-point:get-global-naming-stack
  << undo-point -- jojo-area current-free-address >>
  *cell-size* 2 mul add get
  end
; define-function

: undo-point:set-global-naming-stack
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* 2 mul add set
  end
; define-function

: undo-point:get-module-naming-stack
  << undo-point -- jojo-area current-free-address >>
  *cell-size* 3 mul add get
  end
; define-function

: undo-point:set-module-naming-stack
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* 3 mul add set
  end
; define-function

: undo-point:get-syntax-backup-area
  << undo-point -- jojo-area current-free-address >>
  *cell-size* 4 mul add get
  end
; define-function

: undo-point:set-syntax-backup-area
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* 4 mul add set
  end
; define-function

: undo-point:get-number-of-syntax-rule-sets
  << undo-point -- jojo-area current-free-address >>
  *cell-size* 5 mul add get
  end
; define-function

: undo-point:set-number-of-syntax-rule-sets
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* 5 mul add set
  end
; define-function

: undo-point:get-importing-stack
  << undo-point -- jojo-area current-free-address >>
  *cell-size* 6 mul add get
  end
; define-function

: undo-point:set-importing-stack
  << jojo-area current-free-address, undo-point -- >>
  *cell-size* 6 mul add set
  end
; define-function

20 1024 mul
*cell-size* mul
: *syntax-backup-area,size*
; define-variable,with-tos

*syntax-backup-area,size* allocate-memory
: *syntax-backup-area*
; define-variable,with-tos

*syntax-backup-area*
: *syntax-backup-area,current-free-address*
; define-variable,with-tos

: undo-point:create,copy-syntax,one-syntax-rule-set
  << syntax-rule-set -- >>
  >:syntax-rule-set
  :syntax-rule-set syntax-rule-set:get-border >:border
  :border :syntax-rule-set sub
  *cell-size* div >:n

  :syntax-rule-set
  *syntax-backup-area,current-free-address* set
  *cell-size* address *syntax-backup-area,current-free-address* add-set

  :n
  *syntax-backup-area,current-free-address* set
  *cell-size* address *syntax-backup-area,current-free-address* add-set

  :syntax-rule-set
  :n n-get
  *syntax-backup-area,current-free-address*
  :n n-set
  *cell-size* :n mul
  address *syntax-backup-area,current-free-address* add-set
  end
; define-function

: undo-point:create,copy-syntax
  << cursor -- >>
  dup syntax-stack:*pointer* equal? if
    drop
    end
  then
  dup get undo-point:create,copy-syntax,one-syntax-rule-set
  *cell-size* add
  loop
; define-function

: undo-point:create
  << -- undo-point >>
  undo-stack:*pointer*
  >:undo-point

  undo-stack:*unit*
  address undo-stack:*pointer*
  add-set

  *jojo-area,current-free-address*
  :undo-point
  undo-point:set-jojo-area

  *string-area,current-free-address*
  :undo-point
  undo-point:set-string-area

  global-naming-stack:*pointer*
  :undo-point
  undo-point:set-global-naming-stack

  module-naming-stack:*pointer*
  :undo-point
  undo-point:set-module-naming-stack

  importing-stack:*pointer*
  :undo-point
  undo-point:set-importing-stack

  *syntax-backup-area,current-free-address*
  :undo-point
  undo-point:set-syntax-backup-area

  syntax-stack:*address*
  undo-point:create,copy-syntax

  syntax-stack:*pointer*
  syntax-stack:*address* sub
  *cell-size* div
  :undo-point
  undo-point:set-number-of-syntax-rule-sets

  :undo-point
  end
; define-function

: undo-point:restore-jojo-area
  << undo-point -- >>
  undo-point:get-jojo-area
  address *jojo-area,current-free-address*
  set
  end
; define-function

: undo-point:restore-string-area
  << undo-point -- >>
  undo-point:get-string-area
  address *string-area,current-free-address*
  set
  end
; define-function

: undo-point:restore-global-naming-stack
  << undo-point -- >>
  undo-point:get-global-naming-stack >:old-record

  :old-record
  global-naming-stack:*pointer*
  global-naming-stack:clear-naming

  :old-record address global-naming-stack:*pointer* set
  end
; define-function

: undo-point:restore-module-naming-stack
  << undo-point -- >>
  undo-point:get-module-naming-stack >:old-record

  :old-record
  module-naming-stack:*pointer*
  module-naming-stack:clear-naming

  :old-record address module-naming-stack:*pointer* set
  end
; define-function

: undo-point:restore-syntax-backup-area,set-syntax
  << cursor, syntax-rule-set-copy, number-of-syntax-rule-sets -- cursor >>
  dup zero? if
    drop2
    end
  then
  >:number-of-syntax-rule-sets
  >:syntax-rule-set-copy
  >:cursor

  :syntax-rule-set-copy get >:syntax-rule-set
  :syntax-rule-set-copy *cell-size* add get >:n

  :syntax-rule-set :cursor set

  :syntax-rule-set-copy *cell-size* 2 mul add
  :n n-get
  :syntax-rule-set
  :n n-set

  *cell-size*
  :n mul
  :syntax-rule-set add
  :syntax-rule-set syntax-rule-set:set-border

  :cursor *cell-size* add
  :syntax-rule-set-copy *cell-size* :n 2 add mul add
  :number-of-syntax-rule-sets sub1
  loop
; define-function

: undo-point:restore-syntax-backup-area
  << undo-point -- >>
  >:undo-point
  :undo-point undo-point:get-syntax-backup-area >:old-address
  :undo-point undo-point:get-number-of-syntax-rule-sets >:number-of-syntax-rule-sets

  syntax-stack:*address*
  :old-address
  :number-of-syntax-rule-sets
  undo-point:restore-syntax-backup-area,set-syntax >:cursor

  :cursor
  address syntax-stack:*pointer*
  set

  :old-address
  address *syntax-backup-area,current-free-address*
  set
  end
; define-function

: undo-point:restore-importing-stack
  << undo-point -- >>
  undo-point:get-importing-stack
  address importing-stack:*pointer*
  set
  end
; define-function

: undo-point:restore-undo-stack
  << undo-point -- >>
  address undo-stack:*pointer*
  set
  end
; define-function

: undo
  << undo-point -- >>
  >:undo-point
  :undo-point undo-point:restore-jojo-area
  :undo-point undo-point:restore-string-area
  :undo-point undo-point:restore-global-naming-stack
  :undo-point undo-point:restore-module-naming-stack
  :undo-point undo-point:restore-syntax-backup-area
  :undo-point undo-point:restore-importing-stack
  :undo-point undo-point:restore-undo-stack
  end
; define-function

: pre-module:*syntax-rule-set:size*
  1024 *cell-size* mul
; define-variable

<< for cursor >>
*cell-size* allocate-memory drop

: pre-module:*syntax-rule-set*
  pre-module:*syntax-rule-set:size* allocate-memory
; define-variable

pre-module:*syntax-rule-set*
pre-module:*syntax-rule-set* *cell-size* sub
set

: post-module:*syntax-rule-set:size*
  1024 *cell-size* mul
; define-variable

<< for cursor >>
*cell-size* allocate-memory drop

: syntax-rule-set:*post-module*
  post-module:*syntax-rule-set:size* allocate-memory
; define-variable

syntax-rule-set:*post-module*
syntax-rule-set:*post-module* *cell-size* sub
set

: module-meta-begin-word?
  << string[address, length] -- bool >>
  dup 6 less-than? if
    drop2
    false
    end
  then
  ":" string:byte
  string:full-of-the-same-byte?
  end
; define-function

: module-meta-end-word?
  << string[address, length] -- bool >>
  dup 6 less-than? if
    drop2
    false
    end
  then
  "=" string:byte
  string:full-of-the-same-byte?
  end
; define-function

: module-meta-word?
  << string[address, length] -- bool >>
  dup2 module-meta-begin-word? if
    drop2
    true
    end
  then
  dup2 module-meta-end-word? if
    drop2
    true
    end
  then
  dup 1 less-or-equal? if
    drop2
    false
    end
  then
  >:length
  >:address
  :address :length add sub1 get-byte >:last-byte
  :address :length add sub1 sub1 get-byte >:the-byte-before-last-byte
  :last-byte
  ":" string:byte equal? not if
    false
    end
  then
  :the-byte-before-last-byte
  ":" string:byte equal? if
    false
    end
  then
  true
  end
; define-function

: module-buffer:good-format?
  << module-buffer[address, length] -- bool >>
  dup2 string:space? if
    drop2
    false
    end
  then
  dup2 string:word
  module-meta-begin-word? not if
    drop2
    false
    end
  then
  jo module-meta-end-word? string:any-word
  end
; define-function

: module-buffer:get-code-string
  << module-buffer[address, length] -- meta-string[address, length] >>
  dup2 string:word
  module-meta-end-word? if
    string:word-tail
    end
  then
  string:word-tail
  loop
; define-function

: module-buffer:get-meta-string,loop
  << module-buffer[address, length] -- cursor >>
  dup2 string:word
  module-meta-end-word? if
    string:word-tail
    drop
    end
  then
  string:word-tail
  loop
; define-function

: module-buffer:get-meta-string
  << module-buffer[address, length] -- meta-string[address, length] >>
  dup2 module-buffer:get-meta-string,loop >:cursor
  drop >:address
  :address
  :cursor :address sub
  end
; define-function

: name->module-prefix
  << name -- module-prefix >>
  >:name

  512 allocate-local-memory >:buffer

  "|" :name name->string "|"
  :buffer
  3 n-string->buffer! >:length

  :buffer
  :length
  string->name
  end
; define-function

: import
  << module-name-string[address, length] -- >>
  >::module-name-string
  ::module-name-string string->name >:module-name-index
  :module-name-index name->module-prefix >:module-prefix

  :module-name-index module-stack:find if
    drop
    end
  then

  :module-name-index importing-stack:find if
    "* (import) circular import of : " .s ::module-name-string .s .l
    'fail-to-load awake
  then

  ::module-name-string moi:find not if
    "* (import) can not find module : " .s ::module-name-string .s .l
    'fail-to-load awake
  then
  >::module-path

  64 1024 mul allocate-local-memory >:buffer

  :buffer
  64 1024 mul
  ::module-path
  file:read >:length

  :buffer :length module-buffer:good-format? not if
    "* (import) fail to import module : " .s ::module-name-string .s .l
    "  for the file is not well formated cicada-nymph source code" .s .l
    'fail-to-load awake
  then

  :buffer :length module-buffer:get-meta-string >::meta-string
  :buffer :length module-buffer:get-code-string >::code-string

  false
  module-stack:*pointer*
  module-info:set-tested-flag

  false
  importing-stack:*pointer*
  importing-record:set-testing-flag
  :module-name-index
  importing-stack:*pointer*
  importing-record:set-name
  importing-stack:*unit* address importing-stack:*pointer* add-set

  global-naming-stack:*pointer* >:global-name-record-before-import

  pre-module:*syntax-rule-set* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  global-naming-stack:*pointer* >:global-name-record-begin
  syntax-rule-set:*word-interpreter* push-syntax-stack
  ::code-string eval-string
  drop-syntax-stack
  global-naming-stack:*pointer* >:global-name-record-end

  syntax-rule-set:*post-module* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  importing-stack:drop

  module-naming-stack:*pointer* >:module-name-record-begin
  :global-name-record-begin
  :global-name-record-end
  :module-prefix
  global-naming-stack:prefix-naming
  module-naming-stack:*pointer* >:module-name-record-end

  :global-name-record-before-import
  global-naming-stack:*pointer*
  global-naming-stack:clear-naming

  :global-name-record-before-import address global-naming-stack:*pointer* set

  :module-name-record-begin
  module-stack:*pointer*
  module-info:set-name-record-begin
  :module-name-record-end
  module-stack:*pointer*
  module-info:set-name-record-end
  ::meta-string
  module-stack:*pointer*
  module-info:set-meta-string
  :module-name-index
  module-stack:*pointer*
  module-info:set-name
  module-stack:*unit* address module-stack:*pointer* add-set
  end
; define-function

: module-syntax:unknow-meta-word,loop
  << -- >>
  read-word module-meta-word? if
    unread-word
    end
  then
  loop
; define-function

: module-syntax:unknow-meta-word
  << meta-word -- >>
  drop2
  module-syntax:unknow-meta-word,loop
  end
; define-function

: meta-literal-word:import?
  << word[address, length] -- bool >>
  "import:" string:equal?
  end
; define-function

: pre-module-syntax:import,loop
  << -- unknow >>
  read-word >::word
  ::word string->name >:name
  ::word module-meta-word? if
    unread-word
    end
  then
  ::word import
  :name module-stack:find not if
    "* (pre-module-syntax:import,loop) after import module : " .s
       :name name->string .s .l
    "  still can not find it in the module-stack" .s .l
    end
  then
  >:module-info
  :module-info module-info:get-name-record-begin
  :module-info module-info:get-name-record-end
  module-naming-stack:expose-naming
  loop
; define-function

: pre-module-syntax:import
  << meta-literal-word:import -- unknow >>
  drop2
  pre-module-syntax:import,loop
  end
; define-function

pre-module:*syntax-rule-set*
syntax-rule-set:*word-interpreter*
syntax-rule-set:mixin

pre-module:*syntax-rule-set*
jo module-meta-word?
jo module-syntax:unknow-meta-word
syntax-rule:add

pre-module:*syntax-rule-set*
jo module-meta-begin-word?
jo drop2
syntax-rule:add

pre-module:*syntax-rule-set*
jo module-meta-end-word?
jo drop2
syntax-rule:add

pre-module:*syntax-rule-set*
jo meta-literal-word:import?
jo pre-module-syntax:import
syntax-rule:add

: meta-literal-word:do?
  << word[address, length] -- bool >>
  "do:" string:equal?
  end
; define-function

: post-module-syntax:do,loop
  << -- >>
  read-word >::word
  ::word module-meta-word? if
    unread-word
    end
  then
  ::word word-interpreter
  loop
; define-function

: post-module-syntax:do
  << meta-literal-word:do -- >>
  drop2
  post-module-syntax:do,loop
  end
; define-function

syntax-rule-set:*post-module*
syntax-rule-set:*word-interpreter*
syntax-rule-set:mixin

syntax-rule-set:*post-module*
jo module-meta-word?
jo module-syntax:unknow-meta-word
syntax-rule:add

syntax-rule-set:*post-module*
jo module-meta-begin-word?
jo drop2
syntax-rule:add

syntax-rule-set:*post-module*
jo module-meta-end-word?
jo drop2
syntax-rule:add

syntax-rule-set:*post-module*
jo meta-literal-word:do?
jo post-module-syntax:do
syntax-rule:add

: load
  << module-name-string[address, length] -- >>
  >::module-name-string

  ::module-name-string
  undo-point:create
  reading-stack:*pointer*
  << module-name-string[address, length],
     undo-point
     reading-stack:*pointer*
     -- >>

  [ action,reset-the-stack
    << module-name-string[address, length],
       undo-point
       reading-stack:*pointer*
       -- >>
    address reading-stack:*pointer* set
    undo
    "* (load) can not load : " .s .s .l
    end ]
  'fail-to-load await

  ::module-name-string string->name >:module-name-index
  :module-name-index name->module-prefix >:module-prefix

  :module-name-index module-stack:find if
    drop
    "* (load) the following module is already loaded : " .s ::module-name-string .s .l
    'fail-to-load awake
  then

  :module-name-index importing-stack:find if
    "* (load) circular import of : " .s ::module-name-string .s .l
    'fail-to-load awake
  then

  ::module-name-string moi:find not if
    "* (load) can not find module : " .s ::module-name-string .s .l
    'fail-to-load awake
  then
  >::module-path

  64 1024 mul allocate-local-memory >:buffer

  :buffer
  64 1024 mul
  ::module-path
  file:read >:length

  :buffer :length module-buffer:good-format? not if
    "* (load) fail to import module : " .s ::module-name-string .s .l
    "  for the file is not well formated cicada-nymph source code" .s .l
    'fail-to-load awake
  then

  :buffer :length module-buffer:get-meta-string >::meta-string
  :buffer :length module-buffer:get-code-string >::code-string

  false
  module-stack:*pointer*
  module-info:set-tested-flag

  false
  importing-stack:*pointer*
  importing-record:set-testing-flag
  :module-name-index
  importing-stack:*pointer*
  importing-record:set-name
  importing-stack:*unit* address importing-stack:*pointer* add-set

  global-naming-stack:*pointer* >:global-name-record-before-import

  pre-module:*syntax-rule-set* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  global-naming-stack:*pointer* >:global-name-record-begin
  syntax-rule-set:*word-interpreter* push-syntax-stack
  ::code-string eval-string
  drop-syntax-stack
  global-naming-stack:*pointer* >:global-name-record-end

  syntax-rule-set:*post-module* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  importing-stack:drop

  module-naming-stack:*pointer* >:module-name-record-begin
  :global-name-record-begin
  :global-name-record-end
  :module-prefix
  global-naming-stack:prefix-naming
  module-naming-stack:*pointer* >:module-name-record-end

  :global-name-record-before-import
  global-naming-stack:*pointer*
  global-naming-stack:clear-naming

  :global-name-record-before-import address global-naming-stack:*pointer* set

  :module-name-record-begin
  module-stack:*pointer*
  module-info:set-name-record-begin
  :module-name-record-end
  module-stack:*pointer*
  module-info:set-name-record-end
  ::meta-string
  module-stack:*pointer*
  module-info:set-meta-string
  :module-name-index
  module-stack:*pointer*
  module-info:set-name
  module-stack:*unit* address module-stack:*pointer* add-set


  drop
  drop
  drop2
  end
; define-function

: load-with-test
  << module-name-string[address, length] -- >>
  >::module-name-string

  ::module-name-string
  undo-point:create
  reading-stack:*pointer*
  << module-name-string[address, length],
     undo-point
     reading-stack:*pointer*
     -- >>

  [ action,reset-the-stack
    << module-name-string[address, length],
       undo-point
       reading-stack:*pointer*
       -- >>
    address reading-stack:*pointer* set
    undo
    "* (load-with-test) can not load : " .s .s .l
    end ]
  'fail-to-load await

  ::module-name-string string->name >:module-name-index
  :module-name-index name->module-prefix >:module-prefix

  :module-name-index module-stack:find if
    drop
    "* (load-with-test) the following module is already loaded : " .s ::module-name-string .s .l
    'fail-to-load awake
  then

  :module-name-index importing-stack:find if
    "* (load-with-test) circular import of : " .s ::module-name-string .s .l
    'fail-to-load awake
  then

  ::module-name-string moi:find not if
    "* (load-with-test) can not find module : " .s ::module-name-string .s .l
    'fail-to-load awake
  then
  >::module-path

  64 1024 mul allocate-local-memory >:buffer

  :buffer
  64 1024 mul
  ::module-path
  file:read >:length

  :buffer :length module-buffer:good-format? not if
    "* (load-with-test) fail to import module : " .s ::module-name-string .s .l
    "  for the file is not well formated cicada-nymph source code" .s .l
    'fail-to-load awake
  then

  :buffer :length module-buffer:get-meta-string >::meta-string
  :buffer :length module-buffer:get-code-string >::code-string

  true
  module-stack:*pointer*
  module-info:set-tested-flag
  0
  module-stack:*pointer*
  module-info:set-success-counter
  0
  module-stack:*pointer*
  module-info:set-fail-counter

  true
  importing-stack:*pointer*
  importing-record:set-testing-flag
  :module-name-index
  importing-stack:*pointer*
  importing-record:set-name
  importing-stack:*unit* address importing-stack:*pointer* add-set

  global-naming-stack:*pointer* >:global-name-record-before-import

  pre-module:*syntax-rule-set* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  global-naming-stack:*pointer* >:global-name-record-begin
  syntax-rule-set:*word-interpreter* push-syntax-stack
  ::code-string eval-string
  drop-syntax-stack
  global-naming-stack:*pointer* >:global-name-record-end

  syntax-rule-set:*post-module* push-syntax-stack
  ::meta-string eval-string
  drop-syntax-stack

  importing-stack:drop

  module-naming-stack:*pointer* >:module-name-record-begin
  :global-name-record-begin
  :global-name-record-end
  :module-prefix
  global-naming-stack:prefix-naming
  module-naming-stack:*pointer* >:module-name-record-end

  :global-name-record-before-import
  global-naming-stack:*pointer*
  global-naming-stack:clear-naming

  :global-name-record-before-import address global-naming-stack:*pointer* set

  :module-name-record-begin
  module-stack:*pointer*
  module-info:set-name-record-begin
  :module-name-record-end
  module-stack:*pointer*
  module-info:set-name-record-end
  ::meta-string
  module-stack:*pointer*
  module-info:set-meta-string
  :module-name-index
  module-stack:*pointer*
  module-info:set-name

  "* (load-with-test) load : " .s ::module-name-string .s .l
  "  success : " .s
  module-stack:*pointer* module-info:get-success-counter
  .i .l
  "  fali : " .s
  module-stack:*pointer* module-info:get-fail-counter
  .i .l

  module-stack:*unit* address module-stack:*pointer* add-set


  drop
  drop
  drop2
  end
; define-function

: test-function
  << string[address, length] -- >>
  importing-stack:*pointer*
  importing-stack:*unit* sub
  importing-record:get-testing-flag if
    define-function
    end
  then
  drop2
  end
; define-function

: test-variable
  << string[address, length] -- >>
  importing-stack:*pointer*
  importing-stack:*unit* sub
  importing-record:get-testing-flag if
    define-variable
    end
  then
  drop2
  end
; define-function

: test-variable,with-tos
  << string[address, length] -- >>
  importing-stack:*pointer*
  importing-stack:*unit* sub
  importing-record:get-testing-flag if
    define-variable,with-tos
    end
  then
  drop2
  end
; define-function

: test-do
  << string[address, length] -- >>
  importing-stack:*pointer*
  importing-stack:*unit* sub
  importing-record:get-testing-flag if
    eval-string
    end
  then
  drop2
  end
; define-function

: test
  << bool -- >>
  if
    "  (success)" .s .l
    module-stack:*pointer* module-info:inc-success-counter
  else
    "  (fail)" .s .l
    module-stack:*pointer* module-info:inc-fail-counter
  then
  end
; define-function

: report:memory
  << -- >>
  "* *un-initialized-memory*" .s .l
  "  * size : " .s
       *un-initialized-memory,size*
       . .l
  "  * used : " .s
       *un-initialized-memory,current-free-address*
       *un-initialized-memory*
       sub . .l
  "  * free : " .s
       *un-initialized-memory,size*
       *un-initialized-memory,current-free-address*
       *un-initialized-memory*
       sub sub . .l
  "* *string-area*" .s .l
  "  * size : " .s
       *string-area,size*
       . .l
  "  * used : " .s
       *string-area,current-free-address*
       *string-area*
       sub . .l
  "  * free : " .s
       *string-area,size*
       *string-area,current-free-address*
       *string-area*
       sub sub . .l
  "* *jojo-area*" .s .l
  "  * size : " .s
       *jojo-area,size* . .l
  "  * used : " .s
       *jojo-area,current-free-address*
       *jojo-area*
       sub . .l
  "  * free : " .s
       *jojo-area,size*
       *jojo-area,current-free-address*
       *jojo-area*
       sub sub . .l
  end
; define-function

: report:syntax
  << -- >>
  "* jojo-compiler:*syntax-rule-set* :" .s .l
     jojo-compiler:*syntax-rule-set* syntax-rule-set:list
  "* syntax-rule-set:*word-interpreter* :" .s .l
     syntax-rule-set:*word-interpreter* syntax-rule-set:list
  "* tos-syntax-stack :" .s .l
     tos-syntax-stack syntax-rule-set:list
  end
; define-function

: global-naming-stack:list-by-jo-predicate,loop
  << jo-predicate, counter, cursor -- >>
  dup global-naming-stack:*pointer* equal? if
    drop
    drop
    drop
    end
  then
  >:cursor
  >:counter
  >:jo-predicate
  :cursor name-record:get-new-jo
  :jo-predicate apply if
    "  " .s
    :counter .i ". " .s :counter add1 >:counter
    :cursor name-record:get-name name->string .s
    .l
  then
  :jo-predicate
  :counter
  :cursor global-naming-stack:*unit* add
  loop
; define-function

: global-naming-stack:list-by-jo-predicate
  << jo-predicate -- >>
  1
  *global-naming-stack*
  global-naming-stack:list-by-jo-predicate,loop
  end
; define-function

: report:global-naming-stack
  << -- >>
  "* all primitive-function in global-naming-stack :" .s .l
  jo primitive-function-jo?
  global-naming-stack:list-by-jo-predicate

  "* all function in global-naming-stack :" .s .l
  jo function-jo?
  global-naming-stack:list-by-jo-predicate

  "* all variable in global-naming-stack :" .s .l
  jo variable-jo?
  global-naming-stack:list-by-jo-predicate
  end
; define-function

: report:system
  << -- >>
  "* (system) " .s
  *cell-size* 8 mul .i "bit" .s
  " " .s
  platform .s
  .l
  end
; define-function

0
: *hi,random-base*
; define-variable,with-tos

: hi,random
  << -- random-number >>
  0 syscall-number:*times*
  1 syscall
  13 mod
  <<
   *hi,random-base*
   *hi,random-base* add1 13 mod
   address *hi,random-base* set
  >>
  end
; define-function

: hi,say
  << number -- >>
  dup 0 equal? if drop "cica cica da yaya !!!" .s .l end then
  dup 1 equal? if drop "hi ^-^" .s .l end then
  dup 2 equal? if drop "hello :)" .s .l end then
  dup 3 equal? if drop "hey *^-^*" .s .l end then
  dup 4 equal? if drop "hiya \^o^/" .s .l end then
  dup 5 equal? if drop "I wish you a lovely day" .s .l end then
  dup 6 equal? if drop "I wish you a lovely day { or night :P }" .s .l end then
  dup 7 equal? if drop "o.o" .s .l end then
  dup 8 equal? if drop "O.o" .s .l end then
  dup 9 equal? if drop "o.O" .s .l end then
                  drop "lovely ^3^" .s .l end
; define-function

: hi
  << -- >>
  hi,random
  hi,say
  end
; define-function

: help
  << -- >>
  "* helpful documentations will be written soon" .s .l
  "  please wait ^-^" .s .l
  end
; define-function

: command-function:unknow-function
  << -- >>
  "* (cicada-nymph) unknow command-line-function : " .s
  get-command-line
  string:word-tail
  string:word .s .l
  "  good bye ^-^/" .s .l
  bye
; define-function

: command-function:stack-REPL
  << -- >>
  .l
  "* (cicada-nymph) " .s hi
  report:system
  "* (stack-REPL) is where you are now" .s .l
  "  eval a word print the stack" .s .l
  argument-stack:pretty-print
  jo stack-REPL
  reset-top-level-REPL
; define-function

: command-function:basic-REPL
  << -- >>
  .l
  "* (cicada-nymph) " .s hi
  report:system
  "* (basic-REPL) is where you are now" .s .l
  "  this REPL does not print any thing automaticly" .s .l
  jo basic-REPL
  reset-top-level-REPL
; define-function

: command-function:poi
  << -- >>
  get-command-line
  string:word-tail
  string:word-tail >::command-line

  ::command-line string:space? if
    poi:help
    bye
  then

  ::command-line string:word >::sub-function-name
  ::command-line string:word-tail >::command-line-arguments

  ::sub-function-name "help" string:equal? if
    poi:help
    bye
  then

  ::sub-function-name "add" string:equal? if
    ::command-line-arguments string:word
    ::command-line-arguments string:word-tail string:word
    poi:add
    bye
  then

  ::sub-function-name "sub" string:equal? if
    ::command-line-arguments string:word
    poi:sub
    bye
  then

  ::sub-function-name "up" string:equal? if
    ::command-line-arguments string:word
    ::command-line-arguments string:word-tail string:word
    poi:up
    bye
  then

  ::sub-function-name "find" string:equal? if
    ::command-line-arguments string:word
    poi:find if
      .s .l
    else
      "no found" .s .l
    then
    bye
  then

  ::sub-function-name "list" string:equal? if
    poi:list
    bye
  then

  "* (command-function:poi) meets argument that (command-function:poi) can not understand" .s .l
  "  it is the following command-line that is confusing (command-function:poi) :" .s .l
  "    " .s report:command-line .l
  "  to get some help info  you can type :" .s .l
  "    cn poi help" .s .l
  "  good bye ^-^/" .s .l
  bye
; define-function

: command-function:moi
  << -- >>
  get-command-line
  string:word-tail
  string:word-tail >::command-line

  ::command-line string:space? if
    moi:help
    bye
  then

  ::command-line string:word >::sub-function-name
  ::command-line string:word-tail >::command-line-arguments

  ::sub-function-name "help" string:equal? if
    moi:help
    bye
  then

  ::sub-function-name "add" string:equal? if
    ::command-line-arguments string:word
    ::command-line-arguments string:word-tail string:word
    moi:add
    bye
  then

  ::sub-function-name "sub" string:equal? if
    ::command-line-arguments string:word
    moi:sub
    bye
  then

  ::sub-function-name "up" string:equal? if
    ::command-line-arguments string:word
    ::command-line-arguments string:word-tail string:word
    moi:up
    bye
  then

  ::sub-function-name "find" string:equal? if
    ::command-line-arguments string:word
    moi:find if
      .s .l
    else
      "no found" .s .l
    then
    bye
  then

  ::sub-function-name "list" string:equal? if
    moi:list
    bye
  then

  "* (command-function:moi) meets argument that (command-function:moi) can not understand" .s .l
  "  it is the following command-line that is confusing (command-function:moi) :" .s .l
  "    " .s report:command-line .l
  "  to get some help info  you can type :" .s .l
  "    cn module help" .s .l
  "  good bye ^-^/" .s .l
  bye
; define-function

: command-function:load
  << -- >>
  get-command-line
  string:word-tail
  string:word-tail >::command-line
  ::command-line string:space? if
    "* (command-function:load) is called with no argument" .s .l
    "  it should be called with a name of module" .s .l
    bye
  then
  ::command-line string:word load
  bye
; define-function

: command-function:load-with-test
  << -- >>
  get-command-line
  string:word-tail
  string:word-tail >::command-line
  ::command-line string:space? if
    "* (command-function:load-with-test) is called with no argument" .s .l
    "  it should be called with a name of module" .s .l
    bye
  then
  ::command-line string:word load-with-test
  bye
; define-function

: command-function:no-function
  << -- >>
  command-function:stack-REPL
  end
; define-function

: command:dispatch
  << -- >>
  get-command-line
  string:word-tail
  dup2 string:space? if
    drop2
    command-function:no-function
    end
  then
  string:word
  >::1st-word
  ::1st-word "basic-REPL" string:equal? if
    command-function:basic-REPL
    end
  then
  ::1st-word "stack-REPL" string:equal? if
    command-function:stack-REPL
    end
  then
  ::1st-word "poi" string:equal? if
    command-function:poi
    end
  then
  ::1st-word "moi" string:equal? if
    command-function:moi
    end
  then
  ::1st-word "load" string:equal? if
    command-function:load
    end
  then
  ::1st-word "load-with-test" string:equal? if
    command-function:load-with-test
    end
  then
  command-function:unknow-function
  end
; define-function

command:dispatch
